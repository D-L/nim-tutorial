<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- Favicon -->
<link rel="shortcut icon" href="./nim.ico"/>
<link href="./tut1.css" rel="stylesheet">
<!-- Google fonts -->
<!-- 先屏蔽google 字体
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'>
-->
<!-- CSS -->
<title>Nim Tutorial (第一部分)</title>
</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim Tutorial (第一部分)</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="introduction_toc" href="#introduction">Introduction(介绍)</a></li>
<li><a class="reference" id="the-first-program_toc" href="#the-first-program">The first program(第一个程序)</a></li>
<li><a class="reference" id="lexical-elements_toc" href="#lexical-elements">Lexical elements(基础变量)</a></li>
<ul class="simple"><li><a class="reference" id="lexical-elements-string-and-character-literals_toc" href="#lexical-elements-string-and-character-literals">String and character literals(字符串和字符)</a></li>
<li><a class="reference" id="lexical-elements-comments_toc" href="#lexical-elements-comments">Comments(注释)</a></li>
<li><a class="reference" id="lexical-elements-numbers_toc" href="#lexical-elements-numbers">Numbers(数值)</a></li>
</ul><li><a class="reference" id="the-var-statement_toc" href="#the-var-statement">The var statement(var语句)</a></li>
<li><a class="reference" id="the-assignment-statement_toc" href="#the-assignment-statement">The assignment statement(赋值语句)</a></li>
<li><a class="reference" id="constants_toc" href="#constants">Constants(常量)</a></li>
<li><a class="reference" id="the-let-statement_toc" href="#the-let-statement">The let statement(let语句)</a></li>
<li><a class="reference" id="control-flow-statements_toc" href="#control-flow-statements">Control flow statements(流程控制语句)</a></li><ul class="simple"><li><a class="reference" id="control-flow-statements-if-statement_toc" href="#control-flow-statements-if-statement">If statement(If语句)</a></li>
<li><a class="reference" id="control-flow-statements-case-statement_toc" href="#control-flow-statements-case-statement">Case statement(Case语句)</a></li>
<li><a class="reference" id="control-flow-statements-while-statement_toc" href="#control-flow-statements-while-statement">While statement(While语句)</a></li>
<li><a class="reference" id="control-flow-statements-for-statement_toc" href="#control-flow-statements-for-statement">For statement</a></li>
<li><a class="reference" id="control-flow-statements-scopes-and-the-block-statement_toc" href="#control-flow-statements-scopes-and-the-block-statement">Scopes and the block statement</a></li>
<li><a class="reference" id="control-flow-statements-break-statement_toc" href="#control-flow-statements-break-statement">Break statement</a></li>
<li><a class="reference" id="control-flow-statements-continue-statement_toc" href="#control-flow-statements-continue-statement">Continue statement</a></li>
<li><a class="reference" id="control-flow-statements-when-statement_toc" href="#control-flow-statements-when-statement">When statement</a></li>
</ul><li><a class="reference" id="statements-and-indentation_toc" href="#statements-and-indentation">Statements and indentation</a></li>
<li><a class="reference" id="procedures_toc" href="#procedures">Procedures</a></li>
<ul class="simple"><li><a class="reference" id="procedures-result-variable_toc" href="#procedures-result-variable">Result variable</a></li>
<li><a class="reference" id="procedures-parameters_toc" href="#procedures-parameters">Parameters</a></li>
<li><a class="reference" id="procedures-discard-statement_toc" href="#procedures-discard-statement">Discard statement</a></li>
<li><a class="reference" id="procedures-named-arguments_toc" href="#procedures-named-arguments">Named arguments</a></li>
<li><a class="reference" id="procedures-default-values_toc" href="#procedures-default-values">Default values</a></li>
<li><a class="reference" id="procedures-overloaded-procedures_toc" href="#procedures-overloaded-procedures">Overloaded procedures</a></li>
<li><a class="reference" id="procedures-operators_toc" href="#procedures-operators">Operators</a></li>
<li><a class="reference" id="procedures-forward-declarations_toc" href="#procedures-forward-declarations">Forward declarations</a></li>
</ul><li><a class="reference" id="iterators_toc" href="#iterators">Iterators</a></li>
<li><a class="reference" id="basic-types_toc" href="#basic-types">Basic types</a></li>
<ul class="simple"><li><a class="reference" id="basic-types-booleans_toc" href="#basic-types-booleans">Booleans</a></li>
<li><a class="reference" id="basic-types-characters_toc" href="#basic-types-characters">Characters</a></li>
<li><a class="reference" id="basic-types-strings_toc" href="#basic-types-strings">Strings</a></li>
<li><a class="reference" id="basic-types-integers_toc" href="#basic-types-integers">Integers</a></li>
<li><a class="reference" id="basic-types-floats_toc" href="#basic-types-floats">Floats</a></li>
<li><a class="reference" id="basic-types-type-conversion_toc" href="#basic-types-type-conversion">Type Conversion</a></li>
</ul><li><a class="reference" id="internal-type-representation_toc" href="#internal-type-representation">Internal type representation</a></li>
<li><a class="reference" id="advanced-types_toc" href="#advanced-types">Advanced types</a></li>
<ul class="simple"><li><a class="reference" id="advanced-types-enumerations_toc" href="#advanced-types-enumerations">Enumerations</a></li>
<li><a class="reference" id="advanced-types-ordinal-types_toc" href="#advanced-types-ordinal-types">Ordinal types</a></li>
<li><a class="reference" id="advanced-types-subranges_toc" href="#advanced-types-subranges">Subranges</a></li>
<li><a class="reference" id="advanced-types-sets_toc" href="#advanced-types-sets">Sets</a></li>
<li><a class="reference" id="advanced-types-arrays_toc" href="#advanced-types-arrays">Arrays</a></li>
<li><a class="reference" id="advanced-types-sequences_toc" href="#advanced-types-sequences">Sequences</a></li>
<li><a class="reference" id="advanced-types-open-arrays_toc" href="#advanced-types-open-arrays">Open arrays</a></li>
<li><a class="reference" id="advanced-types-varargs_toc" href="#advanced-types-varargs">Varargs</a></li>
<li><a class="reference" id="advanced-types-slices_toc" href="#advanced-types-slices">Slices</a></li>
<li><a class="reference" id="advanced-types-tuples_toc" href="#advanced-types-tuples">Tuples</a></li>
<li><a class="reference" id="advanced-types-reference-and-pointer-types_toc" href="#advanced-types-reference-and-pointer-types">Reference and pointer types</a></li>
<li><a class="reference" id="advanced-types-procedural-type_toc" href="#advanced-types-procedural-type">Procedural type</a></li>
</ul><li><a class="reference" id="modules_toc" href="#modules">Modules</a></li>
<ul class="simple"><li><a class="reference" id="modules-excluding-symbols_toc" href="#modules-excluding-symbols">Excluding symbols</a></li>
<li><a class="reference" id="modules-from-statement_toc" href="#modules-from-statement">From statement</a></li>
<li><a class="reference" id="modules-include-statement_toc" href="#modules-include-statement">Include statement</a></li>
</ul><li><a class="reference" id="part-2_toc" href="#part-2">Part 2(第二部分)</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">作者:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">适用版本:</th><td> 0.11.2</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="introduction" href="#introduction">Introduction(介绍)</a></h1><blockquote><p>
"Der Mensch ist doch ein Augentier -- sch&ouml;ne Dinge w&uuml;nsch ich mir."
</p></blockquote>
<p>本文档是<em>Nim</em>编程语言的一个教程。你需要对基本的编程概念有个简单了解；比如变量，类型，语句。 高级语言特性的例子可以在<a class="reference external" href="manual.html">手册</a>中找到。</p>

<h1><a class="toc-backref" id="the-first-program" href="#the-first-program">The first program(第一个程序)</a></h1>
<p>我们从 &quot;hello world&quot; 开始：</p>
<pre><span class="Comment"># This is a comment 这是一个注释</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;What's your name? &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span><span class="Punctuation">)</span></pre>
将上面的代码复制到&quot;greetings.nim&quot;文件中。执行如下命令编译运行：
<pre>
nim compile --run greetings.nim</pre>
</p>
<p><tt class="docutils literal"><span class="pre">--run</span></tt> <a class="reference external" href="nimc.html#command-line-switches">编译选项</a>表示Nim将在编译完成后，自动执行相应的程序。你还可以在文件名后加上相应的命令行参数，如：
<pre>
nim compile --run greetings.nim arg1 arg2</pre>
</p>
<p>为了方便，通常都用编译命令和选项的缩写，因此你也可以这样：
<pre>
nim c -r greetings.nim #等于nim compile --run greetings.nim</pre>
</p>
<p>编译一个release版本可以这样：
<pre>
nim c -d:release greetings.nim #选项-d:release明确了release方式</pre>
</p>
<p>默认情况是采用debug方式。此时Num编译器会自动生成非常多运行期检查代码。<tt class="docutils literal"><span class="pre">-d:release</span></tt> 选项将<a class="reference external" href="nimc.html#compile-time-symbols">关闭这些检查并且进行优化</a>。</p>
<p>尽管上面的程序非常简单，我还是要解释一下：<br/>
1. 在程序运行的时候，没被缩进的语句将执行。<br/>
2. 缩进是Nim组织语句的方式。而且缩进只能用空格，Tab之类的是不行的。<br/>
3. string(字符串)用两个双引号"包裹。<br/>
4. <tt class="docutils literal"><span class="pre">var</span></tt>语句申明一个变量名为<tt class="docutils literal"><span class="pre">name</span></tt>的变量，其类型为<tt class="docutils literal"><span class="pre">string</span></tt>，值由<a class="reference external" href="system.html#readLine,File">readLine</a>函数返回。 <br/>

编译器可以知道<a class="reference external" href="system.html#readLine,File">readLine</a> 函数返回的是一个string，因此可在申明变量时省去类型的定义 (这个被称为<span id="local-type-inference_1">local type inference(局部类型推导)</span>)。所以下面这样也是可以的：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre>
<p>注意: Nim中的类型推导基本上就这一种形式，简洁和可读性的折中。</p>
<p>&quot;hello world&quot; 程序中包含了几个编译器已知的标识：<tt class="docutils literal"><span class="pre">echo</span></tt>, <a class="reference external" href="system.html#readLine,File">readLine</a>，等。这些内嵌的函数(built-ins)都在<a class="reference external" href="system.html">system</a>模块(module)中申明，并自动的导入到其他任何模块中。</p>
<h1><a class="toc-backref" id="lexical-elements" href="#lexical-elements">Lexical elements(基础变量)</a></h1>
和其他的编程语言类似,Nim也包含了string(字符串)，标识符，关键字，注释，操作符，以及其他的一些标点符号。</p>

<h2><a class="toc-backref" id="lexical-elements-string-and-character-literals" href="#lexical-elements-string-and-character-literals">String and character literals(字符串和字符)</a></h2>
<p>1. String(字符串)用"(双引号)包裹；字符用'(单引号)包裹。 特殊字符用<tt class="docutils literal"><span class="pre">\</span></tt>转义：<tt class="docutils literal"><span class="pre">\n</span></tt>表示新行，<tt class="docutils literal"><span class="pre">\t</span></tt> 表示Tab，等。<br/>
2. <em>raw</em>模式字符串</p>
<pre><span class="RawData">r&quot;C:\program files\nim&quot;</span></pre>
<p>在raw模式时，反斜杠将不在是转义符号。</p>

<p>3. <em>长字符串模式</em><br/>
用三个双引号包裹：<tt class="docutils literal"><span class="pre">&quot;&quot;&quot; ... &quot;&quot;&quot;</span></tt>；能够包含多行内容，同时 <tt class="docutils literal"><span class="pre">\</span></tt> 也不是转义符号。</p>

<h2><a class="toc-backref" id="lexical-elements-comments" href="#lexical-elements-comments">Comments(注释)</a></h2>
<p>在字符串和字符定义范围之外，以<tt class="docutils literal"><span class="pre">#</span></tt>开始的就是注释。
Documentation comments(文档注释)以 <tt class="docutils literal"><span class="pre">##</span></tt>开始</p>
<pre><span class="Comment"># 这是一个注释</span>
<span class="Keyword">var</span> <span class="Identifier">myVariable</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment">## 一个文档注释</span></pre>
<p>文档注释也是Token;也会在语法树上。可用来自动产生相应的文档类似(JavaDoc)。they are only allowed at certain places in the input file as they belong to the syntax tree! This feature enables simpler documentation generators.</p>
<p>可以用 <a class="reference external" href="#discard-statement">discard</a>语句跟着一个长字符串来创建一个注释块：</p>
<pre><span class="Keyword">discard</span> <span class="LongStringLit">&quot;&quot;&quot; You can have any Nim code text commented
out inside this with no indentation restrictions.
      yes(&quot;May I ask a pointless question?&quot;) &quot;&quot;&quot;</span></pre>

<h2><a class="toc-backref" id="lexical-elements-numbers" href="#lexical-elements-numbers">Numbers(数值)</a></h2>
<p>数值的写法和绝大多数其他的语言一样。<br/>
1. 特别的，下划线是被允许在数值中使用的，这样数值可以更直观：<tt class="docutils literal"><span class="pre">1_000_000</span></tt> (1百万)<br/>
2. 包含.或'e'或'E' 的是浮点数： <tt class="docutils literal"><span class="pre">1.0e9</span></tt> (10亿)<br/>
3. 以<tt class="docutils literal"><span class="pre">0x</span></tt>开始的是16进制数值<br/>
4. 以<tt class="docutils literal"><span class="pre">0b</span></tt>开始的是2进制数值<br/>
5. 以<tt class="docutils literal"><span class="pre">0o</span></tt>开始的是8进制数值，单纯前导0不是一个8进制数值</p>

<h1><a class="toc-backref" id="the-var-statement" href="#the-var-statement">The var statement(var语句)</a></h1>
<p>var用来申明一个新的局部或全局变量：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 申明变量 x 和 y 的类型为``int``</span></pre>
<p>可以在<tt class="docutils literal"><span class="pre">var</span></tt>后缩进的方式申明一堆变量：</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment">#申明变量的中间也可以写注释</span>
  <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre>

<h1><a class="toc-backref" id="the-assignment-statement" href="#the-assignment-statement">The assignment statement(赋值)</a></h1>
<p>赋值语句将一个新值赋给一个变量。更准确的说是赋给一个存储地址：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 申明一个新变量`x` 并且赋值</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># 赋新值给`x`</span></pre>
<p><tt class="docutils literal"><span class="pre">=</span></tt>是<em>赋值操作符</em>。<br/>
赋值操作符现在不能够 overloaded, overwritten和forbidden, 但将来有可能会改变。<br/>
你可以在一条语句中同时申明多个变量并给他们赋值，他们都将是同一个类型：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">3</span>  <span class="Comment"># 赋值 3 给变量`x` 和 `y`</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># 输出 &quot;x 3&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># 输出 &quot;y 3&quot;</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">42</span>        <span class="Comment"># 将 `x`修改为 42,`y`不变</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># 输出 &quot;x 42&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># 输出 &quot;y 3&quot;</span></pre>
<p>注意：在一条语句中申明多个变量，并通过函数来给他们赋值将可能是不期望的结果：编译器将<em>展开</em> 这些赋值，并且调用方式多次来给他们赋值。如果这个函数的返回值依赖side effects,你的变量可能会有不同的结果！安全起见，请用常量。</p>

<h1><a class="toc-backref" id="constants" href="#constants">Constants(常量)</a></h1>
<p>常量就是一个已设定值的符号。 常量的值是不能改变的。编译器必须在编译期间能够计算出这个常量定义时的值:</p>

<pre><span class="Keyword">const</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 常量 x 设定为 &quot;abc&quot;</span></pre>
<p>和var类似，<tt class="docutils literal"><span class="pre">const</span></tt> 关键字后用缩进的方式申明一堆常量：</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Comment"># 依旧能在此注释</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">2</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="DecNumber">5</span> <span class="Comment"># 编译期间是能够被计算出来的 z=7</span></pre>
<h1><a class="toc-backref" id="the-let-statement" href="#the-let-statement">The let statement(let语句)</a></h1>
<p>The <tt class="docutils literal"><span class="pre">let</span></tt> 语句类似<tt class="docutils literal"><span class="pre">var</span></tt>语句，但是后面必须紧跟一个 <em>单赋值</em>语句。初始化后，这些申明的变量的值是不能改变的：</p>
<pre><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 申明一个新变量 `x`,赋值给它</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># 非法:赋值给`x`</span></pre>
<p><tt class="docutils literal"><span class="pre">let</span></tt> 和 <tt class="docutils literal"><span class="pre">const</span></tt>的区别: <br/><tt class="docutils literal"><span class="pre">let</span></tt>申明的变量只是不能再次赋值而不区分是否编译期或运行期， <tt class="docutils literal"><span class="pre">const</span></tt> 则是 &quot;在编译期间这个变量的值必须确定好&quot;：</p>
<pre><span class="Keyword">const</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span> <span class="Comment"># 错误: 必须在编译期间能确定好</span></pre><pre><span class="Keyword">let</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>   <span class="Comment"># OK</span></pre>
<h1><a class="toc-backref" id="control-flow-statements" href="#control-flow-statements">Control flow statements(流程控制语句)</a></h1>
<p>上面的`greetings`程序只包含了３条顺序执行的语句。但是绝大多数的程序还需要 分支和循环 的</p>
<h2><a class="toc-backref" id="control-flow-statements-if-statement" href="#control-flow-statements-if-statement">If statement(If语句)</a></h2>
<p>if语句是流程控制中的一种：</p>
<pre><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Very funny, your name is name.&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span><span class="Punctuation">)</span></pre>

  <p>这里可以有０个或则多个<tt class="docutils literal"><span class="pre">elif</span></tt>， <tt class="docutils literal"><span class="pre">else</span></tt>也是可选的。<br/>关键字 <tt class="docutils literal"><span class="pre">elif</span></tt> 是 <tt class="docutils literal"><span class="pre">else if</span></tt>的简写,避免过多的缩进。 <br/>(<tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt>是空字符串，不包含任何的字符)</p>

<h2><a class="toc-backref" id="control-flow-statements-case-statement" href="#control-flow-statements-case-statement">Case statement(Case语句)</a></h2>
<p>Case语句提供了另外一种流程控制的方法。case语句是多流程分支:</p>
<pre><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">name</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Very funny, your name is name.&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;Dave&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Frank&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Cool name!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span><span class="Punctuation">)</span></pre>

  <p>如上面显示的，在 <tt class="docutils literal"><span class="pre">of</span></tt> 分支中是支持多值的，值之间用<tt class="docutils literal"><span class="pre">逗号,</span></tt>分隔开来。</p>

<p>case语句能够响应整数、其他的序数类型以及字符串(序数类型我们随后将说明)。而且还能响应整数或则序数类型的区间格式：</p>

<pre><span class="Comment"># this statement will be explained later:</span>
<span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;A number please: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is 3 or 8&quot;</span><span class="Punctuation">)</span></pre>
<p>但是，上面的代码是不能编译通过的：因为case中没有覆盖<tt class="docutils literal"><span class="pre">n</span></tt>可能的全部值。上面的代码只覆盖了<tt class="docutils literal"><span class="pre">0..8</span></tt>。因此在实际开发上列出每一个可能的整数是不现实的(尽管用整数范围可以覆盖),下面的方式将解决这个问题：</p>
<pre><span class="Operator">...</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is 3 or 8&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre>
<p>空的 <a class="reference external" href="#discard-statement">discard语句</a> 是个<em>什么都不做(类似asm中的nop)</em>的语句。 <br/>
case语句中带上else的分支，这样编译器就知道case已经覆盖了全部的范围了，也就不会出现错误了。<br/>
注意: 覆盖全部可能的字符串的值几乎是不可能的，因此字符串的case语句分支几乎都需要<tt class="docutils literal"><span class="pre">else</span></tt>分支。</p>
<p>通常 case语句中用子区间类型或则枚举类型来进行分支，这样能帮助编译器来检查是否你已经覆盖到了全部的可能值。</p>
<h2><a class="toc-backref" id="control-flow-statements-while-statement" href="#control-flow-statements-while-statement">While statement(While语句)</a></h2>
<p>While语句是一个简单的循环结构：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;What's your name? &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Please tell me your name: &quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
  <span class="Comment"># 这里的name前面没用``var``,因为我们没有申明一个新的变量</span></pre>
<p>这个例子是用一个循环不断的询问用户的名字,直到输入空 (简单的敲回车就好)。</p>
<h2><a class="toc-backref" id="control-flow-statements-for-statement" href="#control-flow-statements-for-statement">For statement(For语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">for</span></tt>语句是个在某元素的<em>iterator(迭代子)</em> 上循环的结构。 例子使用built-in(内置)的 <a class="reference external" href="system.html#countup">countup</a> 迭代子：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting to ten: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 依次每行输出 1 2 3 4 5 6 7 8 9 10</span></pre>

<p>内置的 <a class="reference external" href="system.html#$">$</a> 操作符可以将整数 (<tt class="docutils literal"><span class="pre">int</span></tt>) 或则其他任何类型转变为字符串类型。<br/>
变量 <tt class="docutils literal"><span class="pre">i</span></tt> 在　<tt class="docutils literal"><span class="pre">for</span></tt> 循环中隐形被定义且类型是 <tt class="docutils literal"><span class="pre">int</span></tt>, 因为 <a class="reference external" href="system.html#countup">countup</a> 方法返回的就是一个<tt class="docutils literal"><span class="pre">int</span></tt>。 <br/>
<tt class="docutils literal"><span class="pre">i</span></tt> 被依次赋值为 1, 2, .., 10。每一个值都被 <tt class="docutils literal"><span class="pre">echo</span></tt>打印了出来。下面的代码也是一样的效果：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting to 10: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span> <span class="Comment"># increment i by 1</span>
<span class="Comment"># --&gt; 依次每行输出 1 2 3 4 5 6 7 8 9 10</span></pre>
<p>向下依次递减也能轻松实现(虽然实际上用的次数会少的多):</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting down from 10 to 1: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countdown</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 依次每行输出 10 9 8 7 6 5 4 3 2 1</span></pre>
<p>既然向上累加在程序用使用的如此之频繁，Nim 也就有了一个操作符 <a class="reference external" href="system.html#...i,S,T">..</a> 来作这件事情：</p>
<pre><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre>
<h2><a class="toc-backref" id="control-flow-statements-scopes-and-the-block-statement" href="#control-flow-statements-scopes-and-the-block-statement">Scopes and the block statement(作用域和block语句)</a></h2>
<p>流程控制语句有个特性还没有谈到，那就是他们都创建了一个新的作用域。<br/>
如下的例子中， <tt class="docutils literal"><span class="pre">x</span></tt> 在循环外是不可见的/不可触及的(accessible)：</p>
<pre><span class="Keyword">while</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># does not work</span></pre>
<p>while(for)语句都隐含的创建了一个block(区块)。<br/><br/>
标识符只能在他们申明的block中可见。<br/>
<tt class="docutils literal"><span class="pre">block</span></tt> 语句用来显示的创建一个新的区块：</p>
<pre><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># does not work either</span></pre>
<p>区块的 <em>label(标签)</em> (例子中的 <tt class="docutils literal"><span class="pre">myblock</span></tt>) 是可选的</p>

<h2><a class="toc-backref" id="control-flow-statements-break-statement" href="#control-flow-statements-break-statement">Break statement(Break语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">break</span></tt>语句可以跳出区块。break语句能够跳出 <tt class="docutils literal"><span class="pre">while</span></tt>, <tt class="docutils literal"><span class="pre">for</span></tt>, 和 <tt class="docutils literal"><span class="pre">block</span></tt> 语句。<br/>如果未指定区块的标签，则跳出最近的一层：</p>
<pre><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;entering block&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;looping&quot;</span><span class="Punctuation">)</span>
    <span class="Keyword">break</span> <span class="Comment"># 跳出循环，但是还在block中</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;still in block&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">block</span> <span class="Identifier">myblock2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;entering block&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;looping&quot;</span><span class="Punctuation">)</span>
    <span class="Keyword">break</span> <span class="Identifier">myblock2</span> <span class="Comment"># 跳出Block（循环也就自然被跳出了)</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;still in block&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="control-flow-statements-continue-statement" href="#control-flow-statements-continue-statement">Continue statement(Continue语句)</a></h2>
<p>和其他的编程语言一样，<tt class="docutils literal"><span class="pre">continue</span></tt> 语句立即开始下一个循环迭代：</p>
<pre><span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="control-flow-statements-when-statement" href="#control-flow-statements-when-statement">When statement(When语句)</a></h2>
<p>例子:</p>
<pre><span class="Keyword">when</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;windows&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on Windows!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;linux&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on Linux!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;macosx&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on Mac OS X!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;unknown operating system&quot;</span><span class="Punctuation">)</span></pre>
 <p><tt class="docutils literal"><span class="pre">when</span></tt>语句和 <tt class="docutils literal"><span class="pre">if</span></tt> 语句大体上相似，但有下列几点区别：</p>
<ul class="simple">
<li>每个分支上的条件必须是常量表达式，因为When中是在编译期评估的</li>
<li>在每个分支中的语句不会创建新的作用域</li>
<li><em>只有</em>在分支的条件在编译期时是 <tt class="docutils literal"><span class="pre">true</span></tt> 这个分支下的语句才会被编译器检查以及产生相应的代码(也就意味这在false的分支你可以写任意的东西。只要看上去语法是对的)</li>
</ul>
<p><tt class="docutils literal"><span class="pre">when</span></tt> 语句在写平台相关代码时非常有用，和C语言中的 <tt class="docutils literal"><span class="pre">#ifdef</span></tt> 类似。</p>
<p><strong>备注</strong>: 要注释大段的代码时，使用 <tt class="docutils literal"><span class="pre">when false:</span></tt> 语句比用真实的注释来的方便的多了。用这个方法，内嵌注释也是可行的了。</p>

<h1><a class="toc-backref" id="statements-and-indentation" href="#statements-and-indentation">Statements and indentation(语句和缩进
)</a></h1>
<p>到此，我们已经简述了基本的流程控制语句，现在我们看看Nim的缩进规则。</p>
<p>在Nim中<em>简单语句(Simple statements)</em> 和 <em>复杂语句(complex statements)</em>有一个区别。<br/>
<em>简单语句</em> 不能包含其他语句：赋值(Assignment), 方法调用(procedure calls) 以及 <tt class="docutils literal"><span class="pre">return</span></tt> 语句都属于简单语句。<br/>
<em>复杂语句</em> 如 <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt>, <tt class="docutils literal"><span class="pre">for</span></tt>, <tt class="docutils literal"><span class="pre">while</span></tt> 能够包含其他语句。<br/>
为了避免歧义，复杂语句总是要使用缩进，但是单个简单语句是不需要的：</p>
<pre><span class="Comment"># 单个简单语句不需要缩进：</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>

<span class="Comment"># if语句嵌套需要缩进：</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">y</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Comment"># 需要缩进，因为这２个语句是在同一个判断条件下:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre>

  <p><em>表达式(Expressions)</em> 通常是结果为一个值的语句的一部分。if语句中的条件就是一个表达式。<br/>
  表达式能够在某些位置进行缩进，以便更好的阅读：</p>
<pre><span class="Keyword">if</span> <span class="Identifier">thisIsaLongCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
    <span class="Identifier">thisIsAnotherLongCondition</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span>
       <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">true</span></pre>
  <p>根据经验一般来说， 在表达式内的缩进可以在operators(操作符)之后、括号(之后、以及逗号之后。</p>
  <p>用括号和分号 <tt class="docutils literal"><span class="pre">(;)</span></tt>　你可以将语句放在只允许表达式出现的地方：</p>
<pre><span class="Comment"># 在编译期间计算出 fac(4) 的值：</span>
<span class="Keyword">const</span> <span class="Identifier">fac4</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span><span class="Punctuation">;</span> <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">*=</span> <span class="Identifier">i</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre>

<h1><a class="toc-backref" id="procedures" href="#procedures">Procedures(方法)</a></h1>
<p>为了定义类似例子中的 <a class="reference external" href="system.html#echo">echo</a> 和 <a class="reference external" href="system.html#readLine,File">readLine</a> 用法, <cite>Procedures</cite>必须引入了 (一些语言称为<em>methods</em> 或 <em>functions</em>)<br/>在Nim中新的procedures用关键字<tt class="docutils literal"><span class="pre">proc</span></tt> 定义：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">,</span> <span class="StringLit">&quot; (y/n)&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;yes&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Yes&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;n&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;N&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;no&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;No&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Please be clear: yes or no&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;Should I delete all your important files?&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;I'm sorry Dave, I'm afraid I can't do that.&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;I think you know what the problem is just as well as I do.&quot;</span><span class="Punctuation">)</span></pre>

  <p>例子中定义了一个名为 <tt class="docutils literal"><span class="pre">yes</span></tt>的Proc。这个proc询问用户一个 <tt class="docutils literal"><span class="pre">问题</span></tt> 。<br/>如果用户回答&quot;yes或一些类似结果&quot; 则返回true；如果用户回答&quot;no或一些类似结果&quot;则返回false。<br/>
  <tt class="docutils literal"><span class="pre">return</span></tt> 语句立即跳出这个procedure (同样while循环也被跳出了) 。<br/>
  <tt class="docutils literal"><span class="pre">(question: string): bool</span></tt> 说明这个procedure定义了一个名为 <tt class="docutils literal"><span class="pre">question</span></tt>的参数，类型为 <tt class="docutils literal"><span class="pre">string</span></tt>，返回值类型为 <tt class="docutils literal"><span class="pre">bool</span></tt>。<br/>
  <tt class="docutils literal"><span class="pre">Bool</span></tt> 是一个内置的类型，<tt class="docutils literal"><span class="pre">bool</span></tt>类型合法的值有  <tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt>。<br/>在if和while语句中的条件的值应该是<tt class="docutils literal"><span class="pre">bool</span></tt>类型。</p>
<p>一些术语：例中的 <tt class="docutils literal"><span class="pre">question</span></tt> 称为 <em>parameter(形参)</em>, <tt class="docutils literal"><span class="pre">&quot;Should I...&quot;</span></tt> 称为 <em>argument(实参)</em>。</p>
<h2><a class="toc-backref" id="procedures-result-variable" href="#procedures-result-variable">Result variable(Result变量)</a></h2>
<p>带有返回值的proc都有一个隐藏的预定义变量 <tt class="docutils literal"><span class="pre">result</span></tt> 表示这个proc的返回值。<br/>不带表达式的<tt class="docutils literal"><span class="pre">return</span></tt>语句 其实只是 <tt class="docutils literal"><span class="pre">return result</span></tt>的简写罢了。<br/>
如果没有明确的用 <tt class="docutils literal"><span class="pre">return</span></tt>语句返回值，<tt class="docutils literal"><span class="pre">result</span></tt>的值总会在procedure的结尾处被自动作为proc的返回值。</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Keyword">return</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">+</span> <span class="Identifier">i</span>

<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># echos 0</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># echos 12</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span> <span class="Punctuation">,</span> <span class="Operator">-</span><span class="DecNumber">1</span> <span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># echos 7</span></pre>
<p><tt class="docutils literal"><span class="pre">result</span></tt>变量总是在proc的开始处被隐含的申明的。因此如果显式的用'var result'申明一次，那么result将变成一个普通的变量了（即覆盖了隐藏的申明）。 <br/>
result变量将初始化为proc的返回值类型的默认值。 <br/>
注意： (referential data)引用类型的数据将被初始化为 <tt class="docutils literal"><span class="pre">nil</span></tt> ，因此可能需要手动的初始化。</p>

<h2><a class="toc-backref" id="procedures-parameters" href="#procedures-parameters">Parameters(形参)</a></h2>
<p>形参在proce中是常量。默认情况下，他们的值是不能修改的，这样有利于编译器以更有效的方式来实现参数传递。<br/>
如果需要这个参数在proc中是可修改的，那么在申明的时候必须加上 <tt class="docutils literal"><span class="pre">var</span></tt>(类似引用传参)。<br/>
 覆盖参数名字也是可行的，通常都这么干了：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printSeq</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">nprinted</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nprinted</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">nprinted</span> <span class="Operator">==</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">min</span><span class="Punctuation">(</span><span class="Identifier">nprinted</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">&lt;</span><span class="Identifier">nprinted</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre>
    <p>如果proc需要修改这个实参以便返回给调用者，<tt class="docutils literal"><span class="pre">var</span></tt>就能派上用场了：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>        <span class="Comment"># integer division</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>  <span class="Comment"># integer modulo operation</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span></pre>
<p>例子中 <tt class="docutils literal"><span class="pre">res</span></tt> 和 <tt class="docutils literal"><span class="pre">remainder</span></tt> 是 <cite>var 形参</cite>。Var形参能够被proc所修改，这个修改后的结果对调用者来说是可见的。<br/>注意，上面的例子用可以返回tuple的方式来取代使用var形参，返回tuple的方式更好。</p>

<h2><a class="toc-backref" id="procedures-discard-statement" href="#procedures-discard-statement">Discard statement(Discard语句)</a></h2>
<p>调用一个带有返回值的procedure，如果想忽略其返回值那么<strong>必须使用</strong><tt class="docutils literal"><span class="pre">discard</span></tt> 语句。<br/>Nim中返回值不允许隐性丢弃：</p>
<pre><span class="Keyword">discard</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;May I ask a pointless question?&quot;</span><span class="Punctuation">)</span></pre>
<p>如果这个proc/iterator在申明的时候增加了<tt class="docutils literal"><span class="pre">discardable</span></tt> 语法，那么他的返回值是可以隐性丢弃:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 现在合法了</span></pre>
<p><tt class="docutils literal"><span class="pre">discard</span></tt> 语句也能用来创建大块的注释，我们在<a class="reference external" href="#comments">Comments(注释)</a>这一节中已经提到了。</p>

<h2><a class="toc-backref" id="procedures-named-arguments" href="#procedures-named-arguments">Named arguments(命名实参)</a></h2>
<p>一旦proc中有很多形参，那么就很难记得清楚这些形参的先后位置了。在创建复杂数据类型的时，这种情况最为常见。 <br/>因此，实参能够被命名就能很清楚的知道他们是属于哪个形参的了：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">width</span><span class="Punctuation">,</span> <span class="Identifier">height</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">title</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span>
                  <span class="Identifier">show</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre>
<p>如上所示我们使用了命名实参来调用 <tt class="docutils literal"><span class="pre">createWindow</span></tt> 函数，这样实参的顺序就不在重要了。混合命名实参和顺序参数也是可以的，但是这样会增加不可读性：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span></pre>
<p>编译器来检查每个形参都有一个实参来对应。</p>

<h2><a class="toc-backref" id="procedures-default-values" href="#procedures-default-values">Default values(默认值)</a></h2>
<p>为了使得<tt class="docutils literal"><span class="pre">createWindow</span></tt> proc更易于使用，提供<cite>default values(默认值)</cite>就很有必要了。<br/>如果调用者没有特别指定这些对应的实参值，那么这些默认值将被使用：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">500</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">700</span><span class="Punctuation">,</span>
                  <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;unknown&quot;</span><span class="Punctuation">,</span>
                  <span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre>
<p>现在调用 <tt class="docutils literal"><span class="pre">createWindow</span></tt> 时只设置了一些与形参默认值不同的参数值</p>
<p>注意: 在默认值设定的时候，参数的类型推导是起作用的。<br/>
因此例子中其实是不需要写 <tt class="docutils literal"><span class="pre">title: string = &quot;unknown&quot;</span></tt>的</p>

<h2><a class="toc-backref" id="procedures-overloaded-procedures" href="#procedures-overloaded-procedures">Overloaded procedures</a></h2><p>Nim provides the ability to overload procedures similar to C++:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;true&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;false&quot;</span>

<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">toString</span><span class="Punctuation">(</span><span class="DecNumber">13</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># calls the toString(x: int) proc</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># calls the toString(x: bool) proc</span></pre><p>(Note that <tt class="docutils literal"><span class="pre">toString</span></tt> is usually the <a class="reference external" href="system.html#$">$</a> operator in Nim.) The compiler chooses the most appropriate proc for the <tt class="docutils literal"><span class="pre">toString</span></tt> calls. How this overloading resolution algorithm works exactly is not discussed here (it will be specified in the manual soon).  However, it does not lead to nasty surprises and is based on a quite simple unification algorithm. Ambiguous calls are reported as errors.</p>

<h2><a class="toc-backref" id="procedures-operators" href="#procedures-operators">Operators</a></h2><p>The Nim library makes heavy use of overloading - one reason for this is that each operator like <tt class="docutils literal"><span class="pre">+</span></tt> is a just an overloaded proc. The parser lets you use operators in <cite>infix notation</cite> (<tt class="docutils literal"><span class="pre">a + b</span></tt>) or <cite>prefix notation</cite> (<tt class="docutils literal"><span class="pre">+ a</span></tt>). An infix operator always receives two arguments, a prefix operator always one. Postfix operators are not possible, because this would be ambiguous: does <tt class="docutils literal"><span class="pre">a @ @ b</span></tt> mean <tt class="docutils literal"><span class="pre">(a) @ (@b)</span></tt> or <tt class="docutils literal"><span class="pre">(a@) @ (b)</span></tt>? It always means <tt class="docutils literal"><span class="pre">(a) @ (@b)</span></tt>, because there are no postfix operators in Nim.</p>
<p>Apart from a few built-in keyword operators such as <tt class="docutils literal"><span class="pre">and</span></tt>, <tt class="docutils literal"><span class="pre">or</span></tt>, <tt class="docutils literal"><span class="pre">not</span></tt>, operators always consist of these characters: <tt class="docutils literal"><span class="pre">+ - * \ / &lt; &gt; = @ $ ~ &amp; % ! ? ^ . |</span></tt></p>
<p>User defined operators are allowed. Nothing stops you from defining your own <tt class="docutils literal"><span class="pre">@!?+~</span></tt> operator, but readability can suffer.</p>
<p>The operator's precedence is determined by its first character. The details can be found in the manual.</p>
<p>To define a new operator enclose the operator in backticks &quot;``&quot;:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myDataType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Comment"># now the $ operator also works with myDataType, overloading resolution</span>
<span class="Comment"># ensures that $ works for built-in types just like before</span></pre><p>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</p>
<pre><span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;True&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="procedures-forward-declarations" href="#procedures-forward-declarations">Forward declarations</a></h2><p>Every variable, procedure, etc. needs to be declared before it can be used. (The reason for this is that it is non-trivial to do better than that in a language that supports meta programming as extensively as Nim does.) However, this cannot be done for mutually recursive procedures:</p>
<pre><span class="Comment"># forward declaration:</span>
<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>

<span class="Keyword">proc</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span> <span class="Keyword">or</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span> <span class="Keyword">or</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre><p>Here <tt class="docutils literal"><span class="pre">odd</span></tt> depends on <tt class="docutils literal"><span class="pre">even</span></tt> and vice versa. Thus <tt class="docutils literal"><span class="pre">even</span></tt> needs to be introduced to the compiler before it is completely defined. The syntax for such a forward declaration is simple: just omit the <tt class="docutils literal"><span class="pre">=</span></tt> and the procedure's body.</p>
<p>Later versions of the language will weaken the requirements for forward declarations.</p>
<p>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</p>

<h1><a class="toc-backref" id="iterators" href="#iterators">Iterators</a></h1><p>Let's return to the boring counting example:</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting to ten: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span></pre><p>Can a <a class="reference external" href="system.html#countup">countup</a> proc be written that supports this loop? Lets try:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre><p>However, this does not work. The problem is that the procedure should not only <tt class="docutils literal"><span class="pre">return</span></tt>, but return and <strong>continue</strong> after an iteration has finished. This <em>return and continue</em> is called a <cite>yield</cite> statement. Now the only thing left to do is to replace the <tt class="docutils literal"><span class="pre">proc</span></tt> keyword by <tt class="docutils literal"><span class="pre">iterator</span></tt> and there it is - our first iterator:</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre><p>Iterators look very similar to procedures, but there are several important differences:</p>
<ul class="simple"><li>Iterators can only be called from for loops.</li>
<li>Iterators cannot contain a <tt class="docutils literal"><span class="pre">return</span></tt> statement and procs cannot contain a <tt class="docutils literal"><span class="pre">yield</span></tt> statement.</li>
<li>Iterators have no implicit <tt class="docutils literal"><span class="pre">result</span></tt> variable.</li>
<li>Iterators do not support recursion.</li>
<li>Iterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)</li>
</ul>
<p>However, you can also use a <tt class="docutils literal"><span class="pre">closure</span></tt> iterator to get a different set of restrictions. See <a class="reference external" href="manual.html#first-class-iterators">first class iterators</a> for details. Iterators can have the same name and parameters as a proc, essentially they have their own namespace. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like <tt class="docutils literal"><span class="pre">split</span></tt> from the <a class="reference external" href="strutils.html">strutils module</a>.</p>

<h1><a class="toc-backref" id="basic-types" href="#basic-types">Basic types</a></h1><p>This section deals with the basic built-in types and the operations that are available for them in detail.</p>

<h2><a class="toc-backref" id="basic-types-booleans" href="#basic-types-booleans">Booleans</a></h2><p>The boolean type is named <tt class="docutils literal"><span class="pre">bool</span></tt> in Nim and consists of the two pre-defined values <tt class="docutils literal"><span class="pre">true</span></tt> and <tt class="docutils literal"><span class="pre">false</span></tt>. Conditions in while, if, elif, when statements need to be of type bool.</p>
<p>The operators <tt class="docutils literal"><span class="pre">not, and, or, xor, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></tt> are defined for the bool type. The <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt> operators perform short-cut evaluation. Example:</p>
<pre><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># p.name is not evaluated if p == nil</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre>
<h2><a class="toc-backref" id="basic-types-characters" href="#basic-types-characters">Characters</a></h2><p>The <cite>character type</cite> is named <tt class="docutils literal"><span class="pre">char</span></tt> in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</p>
<p>Chars can be compared with the <tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt> operators. The <tt class="docutils literal"><span class="pre">$</span></tt> operator converts a <tt class="docutils literal"><span class="pre">char</span></tt> to a <tt class="docutils literal"><span class="pre">string</span></tt>. Chars cannot be mixed with integers; to get the ordinal value of a <tt class="docutils literal"><span class="pre">char</span></tt> use the <tt class="docutils literal"><span class="pre">ord</span></tt> proc. Converting from an integer to a <tt class="docutils literal"><span class="pre">char</span></tt> is done with the <tt class="docutils literal"><span class="pre">chr</span></tt> proc.</p>

<h2><a class="toc-backref" id="basic-types-strings" href="#basic-types-strings">Strings</a></h2><p>String variables in Nim are <strong>mutable</strong>, so appending to a string is quite efficient. Strings in Nim are both zero-terminated and have a length field. One can retrieve a string's length with the builtin <tt class="docutils literal"><span class="pre">len</span></tt> procedure; the length never counts the terminating zero. Accessing the terminating zero is no error and often leads to simpler code:</p>
<pre><span class="Keyword">if</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="CharLit">'a'</span> <span class="Keyword">and</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Operator">+</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="CharLit">'b'</span><span class="Punctuation">:</span>
  <span class="Comment"># no need to check whether ``i &lt; len(s)``!</span>
  <span class="Operator">...</span></pre><p>The assignment operator for strings copies the string. You can use the <tt class="docutils literal"><span class="pre">&amp;</span></tt> operator to concatenate strings and <tt class="docutils literal"><span class="pre">add</span></tt> to append to a string.</p>
<p>Strings are compared by their lexicographical order. All comparison operators are available. Per convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation <tt class="docutils literal"><span class="pre">s[i]</span></tt> means the i-th <em>char</em> of <tt class="docutils literal"><span class="pre">s</span></tt>, not the i-th <em>unichar</em>.</p>
<p>String variables are initialized with a special value, called <tt class="docutils literal"><span class="pre">nil</span></tt>. However, most string operations cannot deal with <tt class="docutils literal"><span class="pre">nil</span></tt> (leading to an exception being raised) for performance reasons. One should use empty strings <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> rather than <tt class="docutils literal"><span class="pre">nil</span></tt> as the <em>empty</em> value. But <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> often creates a string object on the heap, so there is a trade-off to be made here.</p>

<h2><a class="toc-backref" id="basic-types-integers" href="#basic-types-integers">Integers</a></h2><p>Nim has these integer types built-in: <tt class="docutils literal"><span class="pre">int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64</span></tt>.</p>
<p>The default integer type is <tt class="docutils literal"><span class="pre">int</span></tt>. Integer literals can have a <em>type suffix</em> to mark them to be of another integer type:</p>
<pre><span class="Keyword">let</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># x is of type ``int``</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0'i8</span>  <span class="Comment"># y is of type ``int8``</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="DecNumber">0'i64</span> <span class="Comment"># z is of type ``int64``</span>
  <span class="Identifier">u</span> <span class="Operator">=</span> <span class="DecNumber">0'</span><span class="Identifier">u</span>   <span class="Comment"># u is of type ``uint``</span></pre><p>Most often integers are used for counting objects that reside in memory, so <tt class="docutils literal"><span class="pre">int</span></tt> has the same size as a pointer.</p>
<p>The common operators <tt class="docutils literal"><span class="pre">+ - * div mod &lt; &lt;= == != &gt; &gt;=</span></tt> are defined for integers. The <tt class="docutils literal"><span class="pre">and or xor not</span></tt> operators are defined for integers too and provide <em>bitwise</em> operations. Left bit shifting is done with the <tt class="docutils literal"><span class="pre">shl</span></tt>, right shifting with the <tt class="docutils literal"><span class="pre">shr</span></tt> operator. Bit shifting operators always treat their arguments as <em>unsigned</em>. For <span id="arithmetic-bit-shifts_1">arithmetic bit shifts</span> ordinary multiplication or division can be used.</p>
<p>Unsigned operations all wrap around; they cannot lead to over- or underflow errors.</p>
<p><span id="automatic-type-conversion_1">Automatic type conversion</span> is performed in expressions where different kinds of integer types are used. However, if the type conversion loses information, the <span id="eoutofrange_1">EOutOfRange</span> exception is raised (if the error cannot be detected at compile time).</p>

<h2><a class="toc-backref" id="basic-types-floats" href="#basic-types-floats">Floats</a></h2><p>Nim has these floating point types built-in: <tt class="docutils literal"><span class="pre">float float32 float64</span></tt>.</p>
<p>The default float type is <tt class="docutils literal"><span class="pre">float</span></tt>. In the current implementation, <tt class="docutils literal"><span class="pre">float</span></tt> is always 64 bit wide.</p>
<p>Float literals can have a <em>type suffix</em> to mark them to be of another float type:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>      <span class="Comment"># x is of type ``float``</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f32</span>  <span class="Comment"># y is of type ``float32``</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f64</span>  <span class="Comment"># z is of type ``float64``</span></pre><p>The common operators <tt class="docutils literal"><span class="pre">+ - * / &lt; &lt;= == != &gt; &gt;=</span></tt> are defined for floats and follow the IEEE standard.</p>
<p>Automatic type conversion in expressions with different kinds of floating point types is performed: the smaller type is converted to the larger. Integer types are <strong>not</strong> converted to floating point types automatically and vice versa. The <a class="reference external" href="system.html#toInt">toInt</a> and <a class="reference external" href="system.html#toFloat">toFloat</a> procs can be used for these conversions.</p>

<h2><a class="toc-backref" id="basic-types-type-conversion" href="#basic-types-type-conversion">Type Conversion</a></h2><p>Conversion between basic types in nim is performed by using the type as a function:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">int32</span>   <span class="Comment"># same as calling int32(1)</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int8</span>  <span class="Operator">=</span> <span class="Identifier">int8</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Comment"># 'a' == 97'i8</span>
  <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="FloatNumber">2.5</span>       <span class="Comment"># int(2.5) rounds down to 2</span>
  <span class="Identifier">sum</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># sum == 100</span></pre>
<h1><a class="toc-backref" id="internal-type-representation" href="#internal-type-representation">Internal type representation</a></h1><p>As mentioned earlier, the built-in <a class="reference external" href="system.html#$">$</a> (stringify) operator turns any basic type into a string, which you can then print to the screen with the <tt class="docutils literal"><span class="pre">echo</span></tt> proc. However, advanced types, or types you may define yourself won't work with the <tt class="docutils literal"><span class="pre">$</span></tt> operator until you define one for them. Sometimes you just want to debug the current value of a complex type without having to write its <tt class="docutils literal"><span class="pre">$</span></tt> operator.  You can use then the <a class="reference external" href="system.html#repr">repr</a> proc which works with any type and even complex data graphs with cycles. The following example shows that even for basic types there is a difference between the <tt class="docutils literal"><span class="pre">$</span></tt> and <tt class="docutils literal"><span class="pre">repr</span></tt> outputs:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">myBool</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">myCharacter</span> <span class="Operator">=</span> <span class="CharLit">'n'</span>
  <span class="Identifier">myString</span> <span class="Operator">=</span> <span class="StringLit">&quot;nim&quot;</span>
  <span class="Identifier">myInteger</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
  <span class="Identifier">myFloat</span> <span class="Operator">=</span> <span class="FloatNumber">3.14</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myBool</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myBool</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; true:true</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myCharacter</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myCharacter</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; n:'n'</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myString</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myString</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; nim:0x10fa8c050&quot;nim&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myInteger</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myInteger</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 42:42</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myFloat</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myFloat</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 3.1400000000000001e+00:3.1400000000000001e+00</span></pre>
<h1><a class="toc-backref" id="advanced-types" href="#advanced-types">Advanced types</a></h1><p>In Nim new types can be defined within a <tt class="docutils literal"><span class="pre">type</span></tt> statement:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">biggestInt</span> <span class="Operator">=</span> <span class="Identifier">int64</span>      <span class="Comment"># biggest integer type that is available</span>
  <span class="Identifier">biggestFloat</span> <span class="Operator">=</span> <span class="Identifier">float64</span>  <span class="Comment"># biggest float type that is available</span></pre><p>Enumeration and object types cannot be defined on the fly, but only within a <tt class="docutils literal"><span class="pre">type</span></tt> statement.</p>

<h2><a class="toc-backref" id="advanced-types-enumerations" href="#advanced-types-enumerations">Enumerations</a></h2><p>A variable of an enumeration type can only be assigned a value of a limited set. This set consists of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1 and so on. Example:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">south</span>      <span class="Comment"># `x` is of type `Direction`; its value is `south`</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span>           <span class="Comment"># writes &quot;south&quot; to `stdout`</span></pre><p>All comparison operators can be used with enumeration types.</p>
<p>An enumeration's symbol can be qualified to avoid ambiguities: <tt class="docutils literal"><span class="pre">Direction.south</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">$</span></tt> operator can convert any enumeration value to its name, the <tt class="docutils literal"><span class="pre">ord</span></tt> proc to its underlying integer value.</p>
<p>For better interfacing to other programming languages, the symbols of enum types can be assigned an explicit ordinal value. However, the ordinal values have to be in ascending order. A symbol whose ordinal value is not explicitly given is assigned the value of the previous symbol + 1.</p>
<p>An explicit ordered enum can have <em>holes</em>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="DecNumber">89</span></pre>
<h2><a class="toc-backref" id="advanced-types-ordinal-types" href="#advanced-types-ordinal-types">Ordinal types</a></h2><p>Enumerations without holes, integer types, <tt class="docutils literal"><span class="pre">char</span></tt> and <tt class="docutils literal"><span class="pre">bool</span></tt> (and subranges) are called ordinal types. Ordinal types have quite a few special operations:</p>
<table border="1" class="docutils"><tr><th>Operation</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">ord(x)</span></tt></td><td>returns the integer value that is used to represent <cite>x</cite>'s value</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">inc(x)</span></tt></td><td>increments <cite>x</cite> by one</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">inc(x, n)</span></tt></td><td>increments <cite>x</cite> by <cite>n</cite>; <cite>n</cite> is an integer</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">dec(x)</span></tt></td><td>decrements <cite>x</cite> by one</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">dec(x, n)</span></tt></td><td>decrements <cite>x</cite> by <cite>n</cite>; <cite>n</cite> is an integer</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">succ(x)</span></tt></td><td>returns the successor of <cite>x</cite></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">succ(x, n)</span></tt></td><td>returns the <cite>n</cite>'th successor of <cite>x</cite></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">pred(x)</span></tt></td><td>returns the predecessor of <cite>x</cite></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">pred(x, n)</span></tt></td><td>returns the <cite>n</cite>'th predecessor of <cite>x</cite></td></tr>
</table><p>The <a class="reference external" href="system.html#inc">inc</a>, <a class="reference external" href="system.html#dec">dec</a>, <a class="reference external" href="system.html#succ">succ</a> and <a class="reference external" href="system.html#pred">pred</a> operations can fail by raising an <cite>EOutOfRange</cite> or <cite>EOverflow</cite> exception. (If the code has been compiled with the proper runtime checks turned on.)</p>

<h2><a class="toc-backref" id="advanced-types-subranges" href="#advanced-types-subranges">Subranges</a></h2><p>A subrange type is a range of values from an integer or enumeration type (the base type). Example:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Subrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span></pre><p><tt class="docutils literal"><span class="pre">Subrange</span></tt> is a subrange of <tt class="docutils literal"><span class="pre">int</span></tt> which can only hold the values 0 to 5. Assigning any other value to a variable of type <tt class="docutils literal"><span class="pre">Subrange</span></tt> is a compile-time or runtime error. Assignments from the base type to one of its subrange types (and vice versa) are allowed.</p>
<p>The <tt class="docutils literal"><span class="pre">system</span></tt> module defines the important <a class="reference external" href="system.html#Natural">Natural</a> type as <tt class="docutils literal"><span class="pre">range[0..high(int)]</span></tt> (<a class="reference external" href="system.html#high">high</a> returns the maximal value). Other programming languages mandate the usage of unsigned integers for natural numbers. This is often <strong>wrong</strong>: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's <tt class="docutils literal"><span class="pre">Natural</span></tt> type helps to avoid this common programming error.</p>

<h2><a class="toc-backref" id="advanced-types-sets" href="#advanced-types-sets">Sets</a></h2><p>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type. The reason is that sets are implemented as high performance bit vectors.</p>
<p>Sets can be constructed via the set constructor: <tt class="docutils literal"><span class="pre">{}</span></tt> is the empty set. The empty set is type compatible with any concrete set type. The constructor can also be used to include elements (and ranges of elements):</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># This constructs a set that contains the</span>
                         <span class="Comment"># letters from 'a' to 'z' and the digits</span>
                         <span class="Comment"># from '0' to '9'</span></pre><p>These operations are supported by sets:</p>
<table border="1" class="docutils"><tr><th>operation</th><th>meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">A + B</span></tt></td><td>union of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A * B</span></tt></td><td>intersection of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A - B</span></tt></td><td>difference of two sets (A without B's elements)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A == B</span></tt></td><td>set equality</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt;= B</span></tt></td><td>subset relation (A is subset of B or equal to B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt; B</span></tt></td><td>strong subset relation (A is a real subset of B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e in A</span></tt></td><td>set membership (A contains element e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e notin A</span></tt></td><td>A does not contain element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">contains(A, e)</span></tt></td><td>A contains element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">card(A)</span></tt></td><td>the cardinality of A (number of elements in A)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">incl(A, elem)</span></tt></td><td>same as <tt class="docutils literal"><span class="pre">A = A + {elem}</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">excl(A, elem)</span></tt></td><td>same as <tt class="docutils literal"><span class="pre">A = A - {elem}</span></tt></td></tr>
</table><p>Sets are often used to define a type for the <em>flags</em> of a procedure. This is a much cleaner (and type safe) solution than just defining integer constants that should be <tt class="docutils literal"><span class="pre">or</span></tt>'ed together. </p>

<h2><a class="toc-backref" id="advanced-types-arrays" href="#advanced-types-arrays">Arrays</a></h2><p>An array is a simple fixed length container. Each element in the array has the same type. The array's index type can be any ordinal type.</p>
<p>Arrays can be constructed via <tt class="docutils literal"><span class="pre">[]</span></tt>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>The notation <tt class="docutils literal"><span class="pre">x[i]</span></tt> is used to access the i-th element of <tt class="docutils literal"><span class="pre">x</span></tt>. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the <tt class="docutils literal"><span class="pre">--bound_checks:off</span></tt> command line switch.</p>
<p>Arrays are value types, like any other Nim type. The assignment operator copies the whole array contents.</p>
<p>The built-in <a class="reference external" href="system.html#len,TOpenArray">len</a> proc returns the array's length. <a class="reference external" href="system.html#low">low(a)</a> returns the lowest valid index for the array <cite>a</cite> and <a class="reference external" href="system.html#high">high(a)</a> the highest valid index.</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>
  <span class="Identifier">BlinkLights</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">slowBlink</span><span class="Punctuation">,</span> <span class="Identifier">mediumBlink</span><span class="Punctuation">,</span> <span class="Identifier">fastBlink</span>
  <span class="Identifier">LevelSetting</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">level</span><span class="Punctuation">:</span> <span class="Identifier">LevelSetting</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">on</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">south</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">fastBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; [on, fastBlink, slowBlink, off]</span>
<span class="Identifier">echo</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; north</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; west</span></pre><p>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">LevelSetting</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">tower</span><span class="Punctuation">:</span> <span class="Identifier">LightTower</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">mediumBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>     <span class="Comment"># --&gt; 10</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>    <span class="Comment"># --&gt; [[slowBlink, mediumBlink, ...more output..</span>
<span class="Comment"># The following lines don't compile due to type mismatch errors</span>
<span class="Comment">#tower[north][east] = on</span>
<span class="Comment">#tower[0][1] = on</span></pre><p>Note how the built-in <tt class="docutils literal"><span class="pre">len</span></tt> proc returns only the array's first dimension length.  Another way of defining the <tt class="docutils literal"><span class="pre">LightTower</span></tt> to show better its nested nature would be to omit the previous definition of the <tt class="docutils literal"><span class="pre">LevelSetting</span></tt> type and instead write it embedded directly as the type of the first dimension:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span><span class="Punctuation">]</span></pre><p>It is quite frequent to have arrays start at zero, so there's a shortcut syntax to specify a range from zero to the specified index minus one:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
  <span class="Identifier">QuickArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>  <span class="Comment"># an array that is indexed with 0..5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">QuickArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">x</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="advanced-types-sequences" href="#advanced-types-sequences">Sequences</a></h2><p>Sequences are similar to arrays but of dynamic length which may change during runtime (like strings). Since sequences are resizable they are always allocated on the heap and garbage collected.</p>
<p>Sequences are always indexed with an <tt class="docutils literal"><span class="pre">int</span></tt> starting at position 0.  The <a class="reference external" href="system.html#len,seq[T]">len</a>, <a class="reference external" href="system.html#low">low</a> and <a class="reference external" href="system.html#high">high</a> operations are available for sequences too.  The notation <tt class="docutils literal"><span class="pre">x[i]</span></tt> can be used to access the i-th element of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>Sequences can be constructed by the array constructor <tt class="docutils literal"><span class="pre">[]</span></tt> in conjunction with the array to sequence operator <tt class="docutils literal"><span class="pre">@</span></tt>. Another way to allocate space for a sequence is to call the built-in <a class="reference external" href="system.html#newSeq">newSeq</a> procedure.</p>
<p>A sequence may be passed to an openarray parameter.</p>
<p>Example:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># a sequence of integers</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># the @ turns the array into a sequence</span></pre><p>Sequence variables are initialized with <tt class="docutils literal"><span class="pre">nil</span></tt>. However, most sequence operations cannot deal with <tt class="docutils literal"><span class="pre">nil</span></tt> (leading to an exception being raised) for performance reasons. Thus one should use empty sequences <tt class="docutils literal"><span class="pre">@[]</span></tt> rather than <tt class="docutils literal"><span class="pre">nil</span></tt> as the <em>empty</em> value. But <tt class="docutils literal"><span class="pre">@[]</span></tt> creates a sequence object on the heap, so there is a trade-off to be made here.</p>
<p>The <tt class="docutils literal"><span class="pre">for</span></tt> statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The <tt class="docutils literal"><span class="pre">for</span></tt> statement is looping over the results from the <a class="reference external" href="system.html#items.i,seq[T]">items()</a> iterator from the <a class="reference external" href="system.html">system</a> module.  But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the <tt class="docutils literal"><span class="pre">for</span></tt> statement is looping over the results from the <a class="reference external" href="system.html#pairs.i,seq[T]">pairs()</a> iterator from the <a class="reference external" href="system.html">system</a> module.  Examples:</p>
<pre><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 3</span>
<span class="Comment"># --&gt; 4</span>
<span class="Comment"># --&gt; 5</span>

<span class="Keyword">for</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;index: &quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="StringLit">&quot;, value:&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">value</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; index: 0, value:3</span>
<span class="Comment"># --&gt; index: 1, value:4</span>
<span class="Comment"># --&gt; index: 2, value:5</span></pre>
<h2><a class="toc-backref" id="advanced-types-open-arrays" href="#advanced-types-open-arrays">Open arrays</a></h2><p><strong>Note</strong>: Openarrays can only be used for parameters.</p>
<p>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The <span id="openarray_1">openarray</span> type allows this. Openarrays are always indexed with an <tt class="docutils literal"><span class="pre">int</span></tt> starting at position 0. The <a class="reference external" href="system.html#len,TOpenArray">len</a>, <a class="reference external" href="system.html#low">low</a> and <a class="reference external" href="system.html#high">high</a> operations are available for open arrays too.  Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter.</p>
<p>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</p>

<h2><a class="toc-backref" id="advanced-types-varargs" href="#advanced-types-varargs">Varargs</a></h2><p>A <tt class="docutils literal"><span class="pre">varargs</span></tt> parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed by the compiler to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed by the compiler to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>In this example <a class="reference external" href="system.html#$">$</a> is applied to any argument that is passed to the parameter <tt class="docutils literal"><span class="pre">a</span></tt>. Note that <a class="reference external" href="system.html#$">$</a> applied to strings is a nop.</p>

<h2><a class="toc-backref" id="advanced-types-slices" href="#advanced-types-slices">Slices</a></h2><p>Slices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, <cite>a</cite> and <cite>b</cite>. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;Nim is a progamming language&quot;</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;Slices are useless.&quot;</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="FloatNumber">7.</span><span class="Operator">.</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Comment"># --&gt; 'a prog'</span>
<span class="Identifier">b</span><span class="Punctuation">[</span><span class="FloatNumber">11.</span><span class="Operator">.</span> <span class="Operator">-</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Comment"># --&gt; 'Slices are useful.'</span></pre><p>In the previous example slices are used to modify a part of a string, and even a negative index is used. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.</p>

<h2><a class="toc-backref" id="advanced-types-tuples" href="#advanced-types-tuples">Tuples</a></h2><p>A tuple type defines various named <em>fields</em> and an <em>order</em> of the fields. The constructor <tt class="docutils literal"><span class="pre">()</span></tt> can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. Different tuple-types are <em>equivalent</em> if they specify fields of the same type and of the same name in the same order.</p>
<p>The assignment operator for tuples copies each component. The notation <tt class="docutils literal"><span class="pre">t.field</span></tt> is used to access a tuple's field. Another notation is <tt class="docutils literal"><span class="pre">t[i]</span></tt> to access the <tt class="docutils literal"><span class="pre">i</span></tt>'th field. Here <tt class="docutils literal"><span class="pre">i</span></tt> needs to be a constant integer.</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># type representing a person:</span>
                                         <span class="Comment"># a person consists of a name</span>
                                         <span class="Comment"># and an age</span>
<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># the same, but less readable:</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">name</span><span class="Punctuation">)</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">age</span><span class="Punctuation">)</span>  <span class="Comment"># 30</span>

<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># 30</span>

<span class="Comment"># You don't need to declare tuples in a separate type section.</span>
<span class="Keyword">var</span> <span class="Identifier">building</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">street</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">number</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
<span class="Identifier">building</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Rue del Percebe&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">13</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">building</span><span class="Operator">.</span><span class="Identifier">street</span><span class="Punctuation">)</span>

<span class="Comment"># The following line does not compile, they are different tuples!</span>
<span class="Comment">#person = building</span>
<span class="Comment"># --&gt; Error: type mismatch: got (tuple[street: string, number: int])</span>
<span class="Comment">#     but expected 'Person'</span>

<span class="Comment"># The following works because the field names and types are the same.</span>
<span class="Keyword">var</span> <span class="Identifier">teacher</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Mark&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">42</span><span class="Punctuation">)</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Identifier">teacher</span></pre><p>Even though you don't need to declare a type for a tuple to use it, tuples created with different field names will be considered different objects despite having the same field types.</p>
<p>Tuples can be <em>unpacked</em> during variable assignment (and only then!). This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the <a class="reference external" href="os.html#splitFile">splitFile</a> proc from the <a class="reference external" href="os.html">os module</a> which returns the directory, name and extension of a path at the same time. For tuple unpacking to work you have to use parenthesis around the values you want to assign the unpacking to, otherwise you will be assigning the same value to all the individual variables! Example:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">let</span>
  <span class="Identifier">path</span> <span class="Operator">=</span> <span class="StringLit">&quot;usr/local/nimc.html&quot;</span>
  <span class="Punctuation">(</span><span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
  <span class="Identifier">baddir</span><span class="Punctuation">,</span> <span class="Identifier">badname</span><span class="Punctuation">,</span> <span class="Identifier">badext</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">dir</span>      <span class="Comment"># outputs `usr/local`</span>
<span class="Identifier">echo</span> <span class="Identifier">name</span>     <span class="Comment"># outputs `nimc`</span>
<span class="Identifier">echo</span> <span class="Identifier">ext</span>      <span class="Comment"># outputs `.html`</span>
<span class="Comment"># All the following output the same line:</span>
<span class="Comment"># `(dir: usr/local, name: nimc, ext: .html)`</span>
<span class="Identifier">echo</span> <span class="Identifier">baddir</span>
<span class="Identifier">echo</span> <span class="Identifier">badname</span>
<span class="Identifier">echo</span> <span class="Identifier">badext</span></pre><p>Tuple unpacking <strong>only</strong> works in <tt class="docutils literal"><span class="pre">var</span></tt> or <tt class="docutils literal"><span class="pre">let</span></tt> blocks. The following code won't compile:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">var</span>
  <span class="Identifier">path</span> <span class="Operator">=</span> <span class="StringLit">&quot;usr/local/nimc.html&quot;</span>
  <span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Punctuation">(</span><span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; Error: '(dir, name, ext)' cannot be assigned to</span></pre>
<h2><a class="toc-backref" id="advanced-types-reference-and-pointer-types" href="#advanced-types-reference-and-pointer-types">Reference and pointer types</a></h2><p>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory.</p>
<p>Nim distinguishes between <span id="traced_1">traced</span> and <span id="untraced_1">untraced</span> references. Untraced references are also called <em>pointers</em>. Traced references point to objects of a garbage collected heap, untraced references point to manually allocated objects or to objects somewhere else in memory. Thus untraced references are <em>unsafe</em>. However for certain low-level operations (accessing the hardware) untraced references are unavoidable.</p>
<p>Traced references are declared with the <strong>ref</strong> keyword, untraced references are declared with the <strong>ptr</strong> keyword.</p>
<p>The empty <tt class="docutils literal"><span class="pre">[]</span></tt> subscript notation can be used to <em>derefer</em> a reference, meaning to retrieve the item the reference points to. The <tt class="docutils literal"><span class="pre">.</span></tt> (access a tuple/object field operator) and <tt class="docutils literal"><span class="pre">[]</span></tt> (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># no need to write n[].data; in fact n[].data is highly discouraged!</span></pre><p>To allocate a new traced object, the built-in procedure <tt class="docutils literal"><span class="pre">new</span></tt> has to be used. To deal with untraced memory, the procedures <tt class="docutils literal"><span class="pre">alloc</span></tt>, <tt class="docutils literal"><span class="pre">dealloc</span></tt> and <tt class="docutils literal"><span class="pre">realloc</span></tt> can be used. The documentation of the <a class="reference external" href="system.html">system</a> module contains further information.</p>
<p>If a reference points to <em>nothing</em>, it has the value <tt class="docutils literal"><span class="pre">nil</span></tt>.</p>

<h2><a class="toc-backref" id="advanced-types-procedural-type" href="#advanced-types-procedural-type">Procedural type</a></h2><p>A procedural type is a (somewhat abstract) pointer to a procedure. <tt class="docutils literal"><span class="pre">nil</span></tt> is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve <span id="functional_1">functional</span> programming techniques.</p>
<p>Example:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">echoItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">action</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">const</span>
    <span class="Identifier">data</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">,</span> <span class="DecNumber">11</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">d</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">action</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">echoItem</span><span class="Punctuation">)</span></pre><p>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the <a class="reference external" href="manual.html">manual</a>.</p>

<h1><a class="toc-backref" id="modules" href="#modules">Modules</a></h1><p>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable <span id="information-hiding_1">information hiding</span> and <span id="separate-compilation_1">separate compilation</span>. A module may gain access to symbols of another module by the <span id="import_1">import</span> statement. Only top-level symbols that are marked with an asterisk (<tt class="docutils literal"><span class="pre">*</span></tt>) are exported:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># allocate a new sequence:</span>
  <span class="Identifier">newSeq</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># multiply two int sequences:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Comment"># test the new ``*`` operator for sequences:</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">9</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>The above module exports <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">*</span></tt>, but not <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<p>The top-level statements of a module are executed at the start of the program. This can be used to initialize complex data structures for example.</p>
<p>Each module has a special magic constant <tt class="docutils literal"><span class="pre">isMainModule</span></tt> that is true if the module is compiled as the main file. This is very useful to embed tests within the module as shown by the above example.</p>
<p>Modules that depend on each other are possible, but strongly discouraged, because then one module cannot be reused without the other.</p>
<p>The algorithm for compiling modules is:</p>
<ul class="simple"><li>Compile the whole module as usual, following import statements recursively.</li>
<li>If there is a cycle only import the already parsed symbols (that are exported); if an unknown identifier occurs then abort.</li>
</ul>
<p>This is best illustrated by an example:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">type</span>
  <span class="Identifier">T1</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">int</span>  <span class="Comment"># Module A exports the type ``T1``</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>     <span class="Comment"># the compiler starts parsing B</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># works because B has been parsed completely here</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>  <span class="Comment"># A is not parsed here! Only the already known symbols</span>
          <span class="Comment"># of A are imported.</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span> <span class="Operator">=</span>
  <span class="Comment"># this works because the compiler has already</span>
  <span class="Comment"># added T1 to A's interface symbol table</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">1</span></pre><p>A symbol of a module <em>can</em> be <em>qualified</em> with the <tt class="docutils literal"><span class="pre">module.symbol</span></tt> syntax. If the symbol is ambiguous, it even <em>has</em> to be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre><pre><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: x is ambiguous</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># no error: qualifier used</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># not ambiguous: uses the module C's x</span></pre><p>But this rule does not apply to procedures or iterators. Here the overloading rules apply:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre><pre><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># no error: A.x is called</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>  <span class="Comment"># no error: B.x is called</span>

<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">nil</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># ambiguous: which `x` is to call?</span></pre>
<h2><a class="toc-backref" id="modules-excluding-symbols" href="#modules-excluding-symbols">Excluding symbols</a></h2><p>The normal <tt class="docutils literal"><span class="pre">import</span></tt> statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the <tt class="docutils literal"><span class="pre">except</span></tt> qualifier.</p>
<pre><span class="Keyword">import</span> <span class="Identifier">mymodule</span> <span class="Keyword">except</span> <span class="Identifier">y</span></pre>
<h2><a class="toc-backref" id="modules-from-statement" href="#modules-from-statement">From statement</a></h2><p>We have already seen the simple <tt class="docutils literal"><span class="pre">import</span></tt> statement that just imports all exported symbols. An alternative that only imports listed symbols is the <tt class="docutils literal"><span class="pre">from import</span></tt> statement:</p>
<pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span></pre><p>The <tt class="docutils literal"><span class="pre">from</span></tt> statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</p>
<pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># use x without any qualification</span></pre><pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">mymodule</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>  <span class="Comment"># must qualify x with the module name as prefix</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># using x here without qualification is a compile error</span></pre><p>Since module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.</p>
<pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">as</span> <span class="Identifier">m</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>         <span class="Comment"># m is aliasing mymodule</span></pre>
<h2><a class="toc-backref" id="modules-include-statement" href="#modules-include-statement">Include statement</a></h2><p>The <tt class="docutils literal"><span class="pre">include</span></tt> statement does something fundamentally different than importing a module: it merely includes the contents of a file. The <tt class="docutils literal"><span class="pre">include</span></tt> statement is useful to split up a large module into several files:</p>
<pre><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre>

<h1><a class="toc-backref" id="part-2" href="#part-2">Part 2(第二部分)</a></h1><p>好了，基础的到此结束了。let's see what Nim offers apart from a nice syntax for procedural programming: <a class="reference external" href="tut2.html">Part II</a></p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-05-04 19:40:46 UTC</small>
      </div>
    </div>
  </div>
</div>    
</body>
</html>