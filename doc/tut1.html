<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- Favicon -->
<link rel="shortcut icon" href="./nim.ico"/>
<link href="./tut.css" rel="stylesheet">
<!-- Google fonts -->
<!-- 先屏蔽google 字体
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'>
-->
<!-- CSS -->
<title>Nim Tutorial (第一部分)</title>
</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim Tutorial (第一部分)</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="introduction_toc" href="#introduction">Introduction(介绍)</a></li>
<li><a class="reference" id="the-first-program_toc" href="#the-first-program">The first program(第一个程序)</a></li>
<li><a class="reference" id="lexical-elements_toc" href="#lexical-elements">Lexical elements(基础变量)</a></li>
<ul class="simple"><li><a class="reference" id="lexical-elements-string-and-character-literals_toc" href="#lexical-elements-string-and-character-literals">String and character literals(字符串和字符)</a></li>
<li><a class="reference" id="lexical-elements-comments_toc" href="#lexical-elements-comments">Comments(注释)</a></li>
<li><a class="reference" id="lexical-elements-numbers_toc" href="#lexical-elements-numbers">Numbers(数值)</a></li>
</ul><li><a class="reference" id="the-var-statement_toc" href="#the-var-statement">The var statement(var语句)</a></li>
<li><a class="reference" id="the-assignment-statement_toc" href="#the-assignment-statement">The assignment statement(赋值语句)</a></li>
<li><a class="reference" id="constants_toc" href="#constants">Constants(常量)</a></li>
<li><a class="reference" id="the-let-statement_toc" href="#the-let-statement">The let statement(let语句)</a></li>
<li><a class="reference" id="control-flow-statements_toc" href="#control-flow-statements">Control flow statements(流程控制语句)</a></li><ul class="simple"><li><a class="reference" id="control-flow-statements-if-statement_toc" href="#control-flow-statements-if-statement">If statement(If语句)</a></li>
<li><a class="reference" id="control-flow-statements-case-statement_toc" href="#control-flow-statements-case-statement">Case statement(Case语句)</a></li>
<li><a class="reference" id="control-flow-statements-while-statement_toc" href="#control-flow-statements-while-statement">While statement(While语句)</a></li>
<li><a class="reference" id="control-flow-statements-for-statement_toc" href="#control-flow-statements-for-statement">For statement(For语句)</a></li>
<li><a class="reference" id="control-flow-statements-scopes-and-the-block-statement_toc" href="#control-flow-statements-scopes-and-the-block-statement">Scopes and the block statement(作用域和block语句)</a></li>
<li><a class="reference" id="control-flow-statements-break-statement_toc" href="#control-flow-statements-break-statement">Break statement(Break语句)</a></li>
<li><a class="reference" id="control-flow-statements-continue-statement_toc" href="#control-flow-statements-continue-statement">Continue statement(Continue语句)</a></li>
<li><a class="reference" id="control-flow-statements-when-statement_toc" href="#control-flow-statements-when-statement">When statement(When语句)</a></li>
</ul><li><a class="reference" id="statements-and-indentation_toc" href="#statements-and-indentation">Statements and indentation(语句和缩进)</a></li>
<li><a class="reference" id="procedures_toc" href="#procedures">Procedures(过程)</a></li>
<ul class="simple"><li><a class="reference" id="procedures-result-variable_toc" href="#procedures-result-variable">Result variable(Result变量)</a></li>
<li><a class="reference" id="procedures-parameters_toc" href="#procedures-parameters">Parameters(形参)</a></li>
<li><a class="reference" id="procedures-discard-statement_toc" href="#procedures-discard-statement">Discard statement(Discard语句)</a></li>
<li><a class="reference" id="procedures-named-arguments_toc" href="#procedures-named-arguments">Named arguments(命名实参)</a></li>
<li><a class="reference" id="procedures-default-values_toc" href="#procedures-default-values">Default values(默认值)</a></li>
<li><a class="reference" id="procedures-overloaded-procedures_toc" href="#procedures-overloaded-procedures">Overloaded procedures(过程重载)</a></li>
<li><a class="reference" id="procedures-operators_toc" href="#procedures-operators">Operators(操作符)</a></li>
<li><a class="reference" id="procedures-forward-declarations_toc" href="#procedures-forward-declarations">Forward declarations(提前申明)</a></li>
</ul><li><a class="reference" id="iterators_toc" href="#iterators">Iterators(迭代器)</a></li>
<li><a class="reference" id="basic-types_toc" href="#basic-types">Basic types(基础类型)</a></li>
<ul class="simple"><li><a class="reference" id="basic-types-booleans_toc" href="#basic-types-booleans">Booleans(布尔)</a></li>
<li><a class="reference" id="basic-types-characters_toc" href="#basic-types-characters">Characters(字符)</a></li>
<li><a class="reference" id="basic-types-strings_toc" href="#basic-types-strings">Strings(字符串)</a></li>
<li><a class="reference" id="basic-types-integers_toc" href="#basic-types-integers">Integers(整数)</a></li>
<li><a class="reference" id="basic-types-floats_toc" href="#basic-types-floats">Floats(浮点数)</a></li>
<li><a class="reference" id="basic-types-type-conversion_toc" href="#basic-types-type-conversion">Type Conversion(类型转换)</a></li>
</ul><li><a class="reference" id="internal-type-representation_toc" href="#internal-type-representation">Internal type representation(内部类型表达)</a></li>
<li><a class="reference" id="advanced-types_toc" href="#advanced-types">Advanced types(高级类型)</a></li>
<ul class="simple"><li><a class="reference" id="advanced-types-enumerations_toc" href="#advanced-types-enumerations">Enumerations(枚举)</a></li>
<li><a class="reference" id="advanced-types-ordinal-types_toc" href="#advanced-types-ordinal-types">Ordinal types(序数类型)</a></li>
<li><a class="reference" id="advanced-types-subranges_toc" href="#advanced-types-subranges">Subranges(子区间)</a></li>
<li><a class="reference" id="advanced-types-sets_toc" href="#advanced-types-sets">Sets(集合)</a></li>
<li><a class="reference" id="advanced-types-arrays_toc" href="#advanced-types-arrays">Arrays(数组)</a></li>
<li><a class="reference" id="advanced-types-sequences_toc" href="#advanced-types-sequences">Sequences(序列)</a></li>
<li><a class="reference" id="advanced-types-open-arrays_toc" href="#advanced-types-open-arrays">Open arrays(开放数组)</a></li>
<li><a class="reference" id="advanced-types-varargs_toc" href="#advanced-types-varargs">Varargs(可变参数)</a></li>
<li><a class="reference" id="advanced-types-slices_toc" href="#advanced-types-slices">Slices(切片)</a></li>
<li><a class="reference" id="advanced-types-tuples_toc" href="#advanced-types-tuples">Tuples(元组)</a></li>
<li><a class="reference" id="advanced-types-reference-and-pointer-types_toc" href="#advanced-types-reference-and-pointer-types">Reference and pointer types(引用和指针类型)</a></li>
<li><a class="reference" id="advanced-types-procedural-type_toc" href="#advanced-types-procedural-type">Procedural type(过程类型)</a></li>
</ul><li><a class="reference" id="modules_toc" href="#modules">Modules(模块)</a></li>
<ul class="simple"><li><a class="reference" id="modules-excluding-symbols_toc" href="#modules-excluding-symbols">Excluding symbols(排除符号)</a></li>
<li><a class="reference" id="modules-from-statement_toc" href="#modules-from-statement">From statement(From语句)</a></li>
<li><a class="reference" id="modules-include-statement_toc" href="#modules-include-statement">Include statement(Include语句)</a></li>
</ul><li><a class="reference" id="part-2_toc" href="#part-2">Part 2(第二部分)</a></li>
</ul>
  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">作者:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">适用版本:</th><td> 0.11.2</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="introduction" href="#introduction">Introduction(介绍)</a></h1><blockquote><p>
"Der Mensch ist doch ein Augentier -- sch&ouml;ne Dinge w&uuml;nsch ich mir."
</p></blockquote>
<p>本文档是<em>Nim</em>编程语言的一个教程。你需要对基本的编程概念有个简单了解；比如变量，类型，语句。 高级语言特性的例子可以在<a class="reference external" href="manual.html">手册</a>中找到。</p>

<h1><a class="toc-backref" id="the-first-program" href="#the-first-program">The first program(第一个程序)</a></h1>
<p>我们从 &quot;hello world&quot; 开始：</p>
<pre><span class="Comment"># This is a comment 这是一个注释</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;What's your name? &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span><span class="Punctuation">)</span></pre>
将上面的代码复制到&quot;greetings.nim&quot;文件中。执行如下命令编译运行：
<pre>
nim compile --run greetings.nim</pre>
</p>
<p><tt class="docutils literal"><span class="pre">--run</span></tt> <a class="reference external" href="nimc.html#command-line-switches">编译选项</a>表示Nim将在编译完成后，自动执行相应的程序。你还可以在文件名后加上相应的命令行参数，如：
<pre>
nim compile --run greetings.nim arg1 arg2</pre>
</p>
<p>为了方便，通常都用编译命令和选项的缩写，因此你也可以这样：
<pre>
nim c -r greetings.nim #等于nim compile --run greetings.nim</pre>
</p>
<p>编译一个release版本可以这样：
<pre>
nim c -d:release greetings.nim #选项-d:release明确了release方式</pre>
</p>
<p>默认情况是采用debug方式。此时Num编译器会自动生成非常多运行期检查代码。<tt class="docutils literal"><span class="pre">-d:release</span></tt> 选项将<a class="reference external" href="nimc.html#compile-time-symbols">关闭这些检查并且进行优化</a>。</p>
<p>尽管上面的程序非常简单，我还是要解释一下：<br/>
1. 在程序运行的时候，没被缩进的语句将执行。<br/>
2. 缩进是Nim组织语句的方式。而且缩进只能用空格，Tab之类的是不行的。<br/>
3. string(字符串)用两个双引号"包裹。<br/>
4. <tt class="docutils literal"><span class="pre">var</span></tt>语句申明一个变量名为<tt class="docutils literal"><span class="pre">name</span></tt>的变量，其类型为<tt class="docutils literal"><span class="pre">string</span></tt>，值由<a class="reference external" href="system.html#readLine,File">readLine</a>函数返回。 <br/>

编译器可以知道<a class="reference external" href="system.html#readLine,File">readLine</a> 函数返回的是一个string，因此可在申明变量时省去类型的定义 (这个被称为<span id="local-type-inference_1">local type inference(局部类型推导)</span>)。所以下面这样也是可以的：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre>
<p>注意: Nim中的类型推导基本上就这一种形式，简洁和可读性的折中。</p>
<p>&quot;hello world&quot; 程序中包含了几个编译器已知的标识：<tt class="docutils literal"><span class="pre">echo</span></tt>, <a class="reference external" href="system.html#readLine,File">readLine</a>，等。这些内嵌的函数(built-ins)都在<a class="reference external" href="system.html">system</a>模块(module)中申明，并自动的导入到其他任何模块中。</p>
<h1><a class="toc-backref" id="lexical-elements" href="#lexical-elements">Lexical elements(基础变量)</a></h1>
和其他的编程语言类似,Nim也包含了string(字符串)，标识符，关键字，注释，操作符，以及其他的一些标点符号。</p>

<h2><a class="toc-backref" id="lexical-elements-string-and-character-literals" href="#lexical-elements-string-and-character-literals">String and character literals(字符串和字符)</a></h2>
<p>1. String(字符串)用"(双引号)包裹；字符用'(单引号)包裹。 特殊字符用<tt class="docutils literal"><span class="pre">\</span></tt>转义：<tt class="docutils literal"><span class="pre">\n</span></tt>表示新行，<tt class="docutils literal"><span class="pre">\t</span></tt> 表示Tab，等。<br/>
2. <em>raw</em>模式字符串</p>
<pre><span class="RawData">r&quot;C:\program files\nim&quot;</span></pre>
<p>在raw模式时，反斜杠将不在是转义符号。</p>

<p>3. <em>长字符串模式</em><br/>
用三个双引号包裹：<tt class="docutils literal"><span class="pre">&quot;&quot;&quot; ... &quot;&quot;&quot;</span></tt>；能够包含多行内容，同时 <tt class="docutils literal"><span class="pre">\</span></tt> 也不是转义符号。</p>

<h2><a class="toc-backref" id="lexical-elements-comments" href="#lexical-elements-comments">Comments(注释)</a></h2>
<p>在字符串和字符定义范围之外，以<tt class="docutils literal"><span class="pre">#</span></tt>开始的就是注释。
Documentation comments(文档注释)以 <tt class="docutils literal"><span class="pre">##</span></tt>开始</p>
<pre><span class="Comment"># 这是一个注释</span>
<span class="Keyword">var</span> <span class="Identifier">myVariable</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment">## 一个文档注释</span></pre>
<p>文档注释也是Token;也会在语法树上。可用来自动产生相应的文档类似(JavaDoc)。they are only allowed at certain places in the input file as they belong to the syntax tree! This feature enables simpler documentation generators.</p>
<p>可以用 <a class="reference external" href="#discard-statement">discard</a>语句跟着一个长字符串来创建一个注释块：</p>
<pre><span class="Keyword">discard</span> <span class="LongStringLit">&quot;&quot;&quot; You can have any Nim code text commented
out inside this with no indentation restrictions.
      yes(&quot;May I ask a pointless question?&quot;) &quot;&quot;&quot;</span></pre>

<h2><a class="toc-backref" id="lexical-elements-numbers" href="#lexical-elements-numbers">Numbers(数值)</a></h2>
<p>数值的写法和绝大多数其他的语言一样。<br/>
1. 特别的，下划线是被允许在数值中使用的，这样数值可以更直观：<tt class="docutils literal"><span class="pre">1_000_000</span></tt> (1百万)<br/>
2. 包含.或'e'或'E' 的是浮点数： <tt class="docutils literal"><span class="pre">1.0e9</span></tt> (10亿)<br/>
3. 以<tt class="docutils literal"><span class="pre">0x</span></tt>开始的是16进制数值<br/>
4. 以<tt class="docutils literal"><span class="pre">0b</span></tt>开始的是2进制数值<br/>
5. 以<tt class="docutils literal"><span class="pre">0o</span></tt>开始的是8进制数值，单纯前导0不是一个8进制数值</p>

<h1><a class="toc-backref" id="the-var-statement" href="#the-var-statement">The var statement(var语句)</a></h1>
<p>var用来申明一个新的局部或全局变量：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 申明变量 x 和 y 的类型为``int``</span></pre>
<p>可以在<tt class="docutils literal"><span class="pre">var</span></tt>后缩进的方式申明一堆变量：</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment">#申明变量的中间也可以写注释</span>
  <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre>

<h1><a class="toc-backref" id="the-assignment-statement" href="#the-assignment-statement">The assignment statement(赋值)</a></h1>
<p>赋值语句将一个新值赋给一个变量。更准确的说是赋给一个存储地址：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 申明一个新变量`x` 并且赋值</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># 赋新值给`x`</span></pre>
<p><tt class="docutils literal"><span class="pre">=</span></tt>是<em>赋值操作符</em>。<br/>
赋值操作符现在不能够 overloaded, overwritten和forbidden, 但将来有可能会改变。<br/>
你可以在一条语句中同时申明多个变量并给他们赋值，他们都将是同一个类型：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">3</span>  <span class="Comment"># 赋值 3 给变量`x` 和 `y`</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># 输出 &quot;x 3&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># 输出 &quot;y 3&quot;</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">42</span>        <span class="Comment"># 将 `x`修改为 42,`y`不变</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># 输出 &quot;x 42&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># 输出 &quot;y 3&quot;</span></pre>
<p>注意：在一条语句中申明多个变量，并通过函数来给他们赋值将可能是不期望的结果：编译器将<em>展开</em> 这些赋值，并且调用方式多次来给他们赋值。如果这个函数的返回值依赖side effects,你的变量可能会有不同的结果！安全起见，请用常量。</p>

<h1><a class="toc-backref" id="constants" href="#constants">Constants(常量)</a></h1>
<p>常量就是一个已设定值的符号。 常量的值是不能改变的。编译器必须在编译期间能够计算出这个常量定义时的值:</p>

<pre><span class="Keyword">const</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 常量 x 设定为 &quot;abc&quot;</span></pre>
<p>和var类似，<tt class="docutils literal"><span class="pre">const</span></tt> 关键字后用缩进的方式申明一堆常量：</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Comment"># 依旧能在此注释</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">2</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="DecNumber">5</span> <span class="Comment"># 编译期间是能够被计算出来的 z=7</span></pre>
<h1><a class="toc-backref" id="the-let-statement" href="#the-let-statement">The let statement(let语句)</a></h1>
<p>The <tt class="docutils literal"><span class="pre">let</span></tt> 语句类似<tt class="docutils literal"><span class="pre">var</span></tt>语句，但是后面必须紧跟一个 <em>单赋值</em>语句。初始化后，这些申明的变量的值是不能改变的：</p>
<pre><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 申明一个新变量 `x`,赋值给它</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># 非法:赋值给`x`</span></pre>
<p><tt class="docutils literal"><span class="pre">let</span></tt> 和 <tt class="docutils literal"><span class="pre">const</span></tt>的区别: <br/><tt class="docutils literal"><span class="pre">let</span></tt>申明的变量只是不能再次赋值而不区分是否编译期或运行期， <tt class="docutils literal"><span class="pre">const</span></tt> 则是 &quot;在编译期间这个变量的值必须确定好&quot;：</p>
<pre><span class="Keyword">const</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span> <span class="Comment"># 错误: 必须在编译期间能确定好</span></pre><pre><span class="Keyword">let</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>   <span class="Comment"># OK</span></pre>
<h1><a class="toc-backref" id="control-flow-statements" href="#control-flow-statements">Control flow statements(流程控制语句)</a></h1>
<p>上面的`greetings`程序只包含了３条顺序执行的语句。但是绝大多数的程序还需要 分支和循环 的</p>
<h2><a class="toc-backref" id="control-flow-statements-if-statement" href="#control-flow-statements-if-statement">If statement(If语句)</a></h2>
<p>if语句是流程控制中的一种：</p>
<pre><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Very funny, your name is name.&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span><span class="Punctuation">)</span></pre>

  <p>这里可以有０个或则多个<tt class="docutils literal"><span class="pre">elif</span></tt>， <tt class="docutils literal"><span class="pre">else</span></tt>也是可选的。<br/>关键字 <tt class="docutils literal"><span class="pre">elif</span></tt> 是 <tt class="docutils literal"><span class="pre">else if</span></tt>的简写,避免过多的缩进。 <br/>(<tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt>是空字符串，不包含任何的字符)</p>

<h2><a class="toc-backref" id="control-flow-statements-case-statement" href="#control-flow-statements-case-statement">Case statement(Case语句)</a></h2>
<p>Case语句提供了另外一种流程控制的方法。case语句是多流程分支:</p>
<pre><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">name</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Very funny, your name is name.&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;Dave&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Frank&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Cool name!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span><span class="Punctuation">)</span></pre>

  <p>如上面显示的，在 <tt class="docutils literal"><span class="pre">of</span></tt> 分支中是支持多值的，值之间用<tt class="docutils literal"><span class="pre">逗号,</span></tt>分隔开来。</p>

<p>case语句能够响应整数、其他的序数类型以及字符串(序数类型我们随后将说明)。而且还能响应整数或则序数类型的区间格式：</p>

<pre><span class="Comment"># this statement will be explained later:</span>
<span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;A number please: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is 3 or 8&quot;</span><span class="Punctuation">)</span></pre>
<p>但是，上面的代码是不能编译通过的：因为case中没有覆盖<tt class="docutils literal"><span class="pre">n</span></tt>可能的全部值。上面的代码只覆盖了<tt class="docutils literal"><span class="pre">0..8</span></tt>。因此在实际开发上列出每一个可能的整数是不现实的(尽管用整数范围可以覆盖),下面的方式将解决这个问题：</p>
<pre><span class="Operator">...</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;The number is 3 or 8&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre>
<p>空的 <a class="reference external" href="#discard-statement">discard语句</a> 是个<em>什么都不做(类似asm中的nop)</em>的语句。 <br/>
case语句中带上else的分支，这样编译器就知道case已经覆盖了全部的范围了，也就不会出现错误了。<br/>
注意: 覆盖全部可能的字符串的值几乎是不可能的，因此字符串的case语句分支几乎都需要<tt class="docutils literal"><span class="pre">else</span></tt>分支。</p>
<p>通常 case语句中用子区间类型或则枚举类型来进行分支，这样能帮助编译器来检查是否你已经覆盖到了全部的可能值。</p>
<h2><a class="toc-backref" id="control-flow-statements-while-statement" href="#control-flow-statements-while-statement">While statement(While语句)</a></h2>
<p>While语句是一个简单的循环结构：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;What's your name? &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Please tell me your name: &quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
  <span class="Comment"># 这里的name前面没用``var``,因为我们没有申明一个新的变量</span></pre>
<p>这个例子是用一个循环不断的询问用户的名字,直到输入空 (简单的敲回车就好)。</p>
<h2><a class="toc-backref" id="control-flow-statements-for-statement" href="#control-flow-statements-for-statement">For statement(For语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">for</span></tt>语句是个在某元素的<em>iterator(迭代子)</em> 上循环的结构。 例子使用built-in(内置)的 <a class="reference external" href="system.html#countup">countup</a> 迭代子：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting to ten: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 依次每行输出 1 2 3 4 5 6 7 8 9 10</span></pre>

<p>内置的 <a class="reference external" href="system.html#$">$</a> 操作符可以将整数 (<tt class="docutils literal"><span class="pre">int</span></tt>) 或则其他任何类型转变为字符串类型。<br/>
变量 <tt class="docutils literal"><span class="pre">i</span></tt> 在　<tt class="docutils literal"><span class="pre">for</span></tt> 循环中隐形被定义且类型是 <tt class="docutils literal"><span class="pre">int</span></tt>, 因为 <a class="reference external" href="system.html#countup">countup</a> 方法返回的就是一个<tt class="docutils literal"><span class="pre">int</span></tt>。 <br/>
<tt class="docutils literal"><span class="pre">i</span></tt> 被依次赋值为 1, 2, .., 10。每一个值都被 <tt class="docutils literal"><span class="pre">echo</span></tt>打印了出来。下面的代码也是一样的效果：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting to 10: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span> <span class="Comment"># increment i by 1</span>
<span class="Comment"># --&gt; 依次每行输出 1 2 3 4 5 6 7 8 9 10</span></pre>
<p>向下依次递减也能轻松实现(虽然实际上用的次数会少的多):</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting down from 10 to 1: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countdown</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 依次每行输出 10 9 8 7 6 5 4 3 2 1</span></pre>
<p>既然向上累加在程序用使用的如此之频繁，Nim 也就有了一个操作符 <a class="reference external" href="system.html#...i,S,T">..</a> 来作这件事情：</p>
<pre><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre>
<h2><a class="toc-backref" id="control-flow-statements-scopes-and-the-block-statement" href="#control-flow-statements-scopes-and-the-block-statement">Scopes and the block statement(作用域和block语句)</a></h2>
<p>流程控制语句有个特性还没有谈到，那就是他们都创建了一个新的作用域。<br/>
如下的例子中， <tt class="docutils literal"><span class="pre">x</span></tt> 在循环外是不可见的/不可触及的(accessible)：</p>
<pre><span class="Keyword">while</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># does not work</span></pre>
<p>while(for)语句都隐含的创建了一个block(区块)。<br/><br/>
标识符只能在他们申明的block中可见。<br/>
<tt class="docutils literal"><span class="pre">block</span></tt> 语句用来显示的创建一个新的区块：</p>
<pre><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># does not work either</span></pre>
<p>区块的 <em>label(标签)</em> (例子中的 <tt class="docutils literal"><span class="pre">myblock</span></tt>) 是可选的</p>

<h2><a class="toc-backref" id="control-flow-statements-break-statement" href="#control-flow-statements-break-statement">Break statement(Break语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">break</span></tt>语句可以跳出区块。break语句能够跳出 <tt class="docutils literal"><span class="pre">while</span></tt>, <tt class="docutils literal"><span class="pre">for</span></tt>, 和 <tt class="docutils literal"><span class="pre">block</span></tt> 语句。<br/>如果未指定区块的标签，则跳出最近的一层：</p>
<pre><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;entering block&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;looping&quot;</span><span class="Punctuation">)</span>
    <span class="Keyword">break</span> <span class="Comment"># 跳出循环，但是还在block中</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;still in block&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">block</span> <span class="Identifier">myblock2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;entering block&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;looping&quot;</span><span class="Punctuation">)</span>
    <span class="Keyword">break</span> <span class="Identifier">myblock2</span> <span class="Comment"># 跳出Block（循环也就自然被跳出了)</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;still in block&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="control-flow-statements-continue-statement" href="#control-flow-statements-continue-statement">Continue statement(Continue语句)</a></h2>
<p>和其他的编程语言一样，<tt class="docutils literal"><span class="pre">continue</span></tt> 语句立即开始下一个循环迭代：</p>
<pre><span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="control-flow-statements-when-statement" href="#control-flow-statements-when-statement">When statement(When语句)</a></h2>
<p>例子:</p>
<pre><span class="Keyword">when</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;windows&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on Windows!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;linux&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on Linux!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;macosx&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on Mac OS X!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;unknown operating system&quot;</span><span class="Punctuation">)</span></pre>
 <p><tt class="docutils literal"><span class="pre">when</span></tt>语句和 <tt class="docutils literal"><span class="pre">if</span></tt> 语句大体上相似，但有下列几点区别：</p>
<ul class="simple">
<li>每个分支上的条件必须是常量表达式，因为When中是在编译期评估的</li>
<li>在每个分支中的语句不会创建新的作用域</li>
<li><em>只有</em>在分支的条件在编译期时是 <tt class="docutils literal"><span class="pre">true</span></tt> 这个分支下的语句才会被编译器检查以及产生相应的代码(也就意味这在false的分支你可以写任意的东西。只要看上去语法是对的)</li>
</ul>
<p><tt class="docutils literal"><span class="pre">when</span></tt> 语句在写平台相关代码时非常有用，和C语言中的 <tt class="docutils literal"><span class="pre">#ifdef</span></tt> 类似。</p>
<p><strong>备注</strong>: 要注释大段的代码时，使用 <tt class="docutils literal"><span class="pre">when false:</span></tt> 语句比用真实的注释来的方便的多了。用这个方法，内嵌注释也是可行的了。</p>

<h1><a class="toc-backref" id="statements-and-indentation" href="#statements-and-indentation">Statements and indentation(语句和缩进
)</a></h1>
<p>到此，我们已经简述了基本的流程控制语句，现在我们看看Nim的缩进规则。</p>
<p>在Nim中<em>简单语句(Simple statements)</em> 和 <em>复杂语句(complex statements)</em>有一个区别。<br/>
<em>简单语句</em> 不能包含其他语句：赋值(Assignment), 方法调用(procedure calls) 以及 <tt class="docutils literal"><span class="pre">return</span></tt> 语句都属于简单语句。<br/>
<em>复杂语句</em> 如 <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt>, <tt class="docutils literal"><span class="pre">for</span></tt>, <tt class="docutils literal"><span class="pre">while</span></tt> 能够包含其他语句。<br/>
为了避免歧义，复杂语句总是要使用缩进，但是单个简单语句是不需要的：</p>
<pre><span class="Comment"># 单个简单语句不需要缩进：</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>

<span class="Comment"># if语句嵌套需要缩进：</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">y</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Comment"># 需要缩进，因为这２个语句是在同一个判断条件下:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre>

  <p><em>表达式(Expressions)</em> 通常是结果为一个值的语句的一部分。if语句中的条件就是一个表达式。<br/>
  表达式能够在某些位置进行缩进，以便更好的阅读：</p>
<pre><span class="Keyword">if</span> <span class="Identifier">thisIsaLongCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
    <span class="Identifier">thisIsAnotherLongCondition</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span>
       <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">true</span></pre>
  <p>根据经验一般来说， 在表达式内的缩进可以在operators(操作符)之后、括号(之后、以及逗号之后。</p>
  <p>用括号和分号 <tt class="docutils literal"><span class="pre">(;)</span></tt>　你可以将语句放在只允许表达式出现的地方：</p>
<pre><span class="Comment"># 在编译期间计算出 fac(4) 的值：</span>
<span class="Keyword">const</span> <span class="Identifier">fac4</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span><span class="Punctuation">;</span> <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">*=</span> <span class="Identifier">i</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre>

<h1><a class="toc-backref" id="procedures" href="#procedures">Procedures(过程)</a></h1>
<p>为了定义类似例子中的 <a class="reference external" href="system.html#echo">echo</a> 和 <a class="reference external" href="system.html#readLine,File">readLine</a> 用法, <cite>Procedures</cite>必须引入了 (一些语言称为<em>methods</em> 或 <em>functions</em>)<br/>在Nim中新的procedures用关键字<tt class="docutils literal"><span class="pre">proc</span></tt> 定义：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">,</span> <span class="StringLit">&quot; (y/n)&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;yes&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Yes&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;n&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;N&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;no&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;No&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Please be clear: yes or no&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;Should I delete all your important files?&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;I'm sorry Dave, I'm afraid I can't do that.&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;I think you know what the problem is just as well as I do.&quot;</span><span class="Punctuation">)</span></pre>

  <p>例子中定义了一个名为 <tt class="docutils literal"><span class="pre">yes</span></tt>的Proc。这个proc询问用户一个 <tt class="docutils literal"><span class="pre">问题</span></tt> 。<br/>如果用户回答&quot;yes或一些类似结果&quot; 则返回true；如果用户回答&quot;no或一些类似结果&quot;则返回false。<br/>
  <tt class="docutils literal"><span class="pre">return</span></tt> 语句立即跳出这个procedure (同样while循环也被跳出了) 。<br/>
  <tt class="docutils literal"><span class="pre">(question: string): bool</span></tt> 说明这个procedure定义了一个名为 <tt class="docutils literal"><span class="pre">question</span></tt>的参数，类型为 <tt class="docutils literal"><span class="pre">string</span></tt>，返回值类型为 <tt class="docutils literal"><span class="pre">bool</span></tt>。<br/>
  <tt class="docutils literal"><span class="pre">Bool</span></tt> 是一个内置的类型，<tt class="docutils literal"><span class="pre">bool</span></tt>类型合法的值有  <tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt>。<br/>在if和while语句中的条件的值应该是<tt class="docutils literal"><span class="pre">bool</span></tt>类型。</p>
<p>一些术语：例中的 <tt class="docutils literal"><span class="pre">question</span></tt> 称为 <em>parameter(形参)</em>, <tt class="docutils literal"><span class="pre">&quot;Should I...&quot;</span></tt> 称为 <em>argument(实参)</em>。</p>
<h2><a class="toc-backref" id="procedures-result-variable" href="#procedures-result-variable">Result variable(Result变量)</a></h2>
<p>带有返回值的proc都有一个隐藏的预定义变量 <tt class="docutils literal"><span class="pre">result</span></tt> 表示这个proc的返回值。<br/>不带表达式的<tt class="docutils literal"><span class="pre">return</span></tt>语句 其实只是 <tt class="docutils literal"><span class="pre">return result</span></tt>的简写罢了。<br/>
如果没有明确的用 <tt class="docutils literal"><span class="pre">return</span></tt>语句返回值，<tt class="docutils literal"><span class="pre">result</span></tt>的值总会在procedure的结尾处被自动作为proc的返回值。</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Keyword">return</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">+</span> <span class="Identifier">i</span>

<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># echos 0</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># echos 12</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span> <span class="Punctuation">,</span> <span class="Operator">-</span><span class="DecNumber">1</span> <span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># echos 7</span></pre>
<p><tt class="docutils literal"><span class="pre">result</span></tt>变量总是在proc的开始处被隐含的申明的。因此如果显式的用'var result'申明一次，那么result将变成一个普通的变量了（即覆盖了隐藏的申明）。 <br/>
result变量将初始化为proc的返回值类型的默认值。 <br/>
注意： (referential data)引用类型的数据将被初始化为 <tt class="docutils literal"><span class="pre">nil</span></tt> ，因此可能需要手动的初始化。</p>

<h2><a class="toc-backref" id="procedures-parameters" href="#procedures-parameters">Parameters(形参)</a></h2>
<p>形参在proce中是常量。默认情况下，他们的值是不能修改的，这样有利于编译器以更有效的方式来实现参数传递。<br/>
如果需要这个参数在proc中是可修改的，那么在申明的时候必须加上 <tt class="docutils literal"><span class="pre">var</span></tt>(类似引用传参)。<br/>
 覆盖参数名字也是可行的，通常都这么干了：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printSeq</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">nprinted</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nprinted</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">nprinted</span> <span class="Operator">==</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">min</span><span class="Punctuation">(</span><span class="Identifier">nprinted</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">&lt;</span><span class="Identifier">nprinted</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre>
    <p>如果proc需要修改这个实参以便返回给调用者，<tt class="docutils literal"><span class="pre">var</span></tt>就能派上用场了：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>        <span class="Comment"># integer division</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>  <span class="Comment"># integer modulo operation</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span></pre>
<p>例子中 <tt class="docutils literal"><span class="pre">res</span></tt> 和 <tt class="docutils literal"><span class="pre">remainder</span></tt> 是 <cite>var 形参</cite>。Var形参能够被proc所修改，这个修改后的结果对调用者来说是可见的。<br/>注意，上面的例子用可以返回tuple的方式来取代使用var形参，返回tuple的方式更好。</p>

<h2><a class="toc-backref" id="procedures-discard-statement" href="#procedures-discard-statement">Discard statement(Discard语句)</a></h2>
<p>调用一个带有返回值的procedure，如果想忽略其返回值那么<strong>必须使用</strong><tt class="docutils literal"><span class="pre">discard</span></tt> 语句。<br/>Nim中返回值不允许隐性丢弃：</p>
<pre><span class="Keyword">discard</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;May I ask a pointless question?&quot;</span><span class="Punctuation">)</span></pre>
<p>如果这个proc/iterator在申明的时候增加了<tt class="docutils literal"><span class="pre">discardable</span></tt> 语法，那么他的返回值是可以隐性丢弃:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 现在合法了</span></pre>
<p><tt class="docutils literal"><span class="pre">discard</span></tt> 语句也能用来创建大块的注释，我们在<a class="reference external" href="#comments">Comments(注释)</a>这一节中已经提到了。</p>

<h2><a class="toc-backref" id="procedures-named-arguments" href="#procedures-named-arguments">Named arguments(命名实参)</a></h2>
<p>一旦proc中有很多形参，那么就很难记得清楚这些形参的先后位置了。在创建复杂数据类型的时，这种情况最为常见。 <br/>因此，实参能够被命名就能很清楚的知道他们是属于哪个形参的了：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">width</span><span class="Punctuation">,</span> <span class="Identifier">height</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">title</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span>
                  <span class="Identifier">show</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre>
<p>如上所示我们使用了命名实参来调用 <tt class="docutils literal"><span class="pre">createWindow</span></tt> 函数，这样实参的顺序就不在重要了。混合命名实参和顺序参数也是可以的，但是这样会增加不可读性：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span></pre>
<p>编译器来检查每个形参都有一个实参来对应。</p>

<h2><a class="toc-backref" id="procedures-default-values" href="#procedures-default-values">Default values(默认值)</a></h2>
<p>为了使得<tt class="docutils literal"><span class="pre">createWindow</span></tt> proc更易于使用，提供<cite>default values(默认值)</cite>就很有必要了。<br/>如果调用者没有特别指定这些对应的实参值，那么这些默认值将被使用：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">500</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">700</span><span class="Punctuation">,</span>
                  <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;unknown&quot;</span><span class="Punctuation">,</span>
                  <span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre>
<p>现在调用 <tt class="docutils literal"><span class="pre">createWindow</span></tt> 时只设置了一些与形参默认值不同的参数值</p>
<p>注意: 在默认值设定的时候，参数的类型推导是起作用的。<br/>
因此例子中不需要写 <tt class="docutils literal"><span class="pre">title: string = &quot;unknown&quot;</span></tt>，直接简写为 <tt class="docutils literal"><span class="pre">title = &quot;unknown&quot;</span></tt>就可以了</p>

<h2><a class="toc-backref" id="procedures-overloaded-procedures" href="#procedures-overloaded-procedures">Overloaded procedures(过程重载)</a></h2>
<p>Nim 提供了类似C++的proc重载功能：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;true&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;false&quot;</span>

<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">toString</span><span class="Punctuation">(</span><span class="DecNumber">13</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># 调用的是 toString(x: int) </span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># 调用的是 toString(x: bool) </span></pre>
<p>(注：<tt class="docutils literal"><span class="pre">toString</span></tt> 在Nim中通常是用 <a class="reference external" href="system.html#$">$</a> 操作符)<br/>在调用<tt class="docutils literal"><span class="pre">toString</span></tt>时，编译器会选择最恰当的proc来执行<br/>最恰当的proc是如何选择的就不展开说了 (在后续的手册中会有详细说明)<br/>
然而，选择算法必须不能导致怪异的结果。它是基于一个相当简单的联合算法。任何有歧义的调用将被报告为错误。</p>

<h2><a class="toc-backref" id="procedures-operators" href="#procedures-operators">Operators(操作符)</a></h2>
<p>Nim库中重度使用了重载。每个操作符仅仅是一个重载后的proc而已，比如<tt class="docutils literal"><span class="pre">+</span></tt>。<br/>操作符有 <cite>infix notation(中缀)</cite> (<tt class="docutils literal"><span class="pre">a + b</span></tt>) 或 <cite>prefix notation(前缀)</cite> (<tt class="docutils literal"><span class="pre">+ a</span></tt>)两种类型。<br/>中缀操作符总是需要２个参数，前缀操作符只需要１个。<br/>后缀操作符是不允许的，因为他们会带来歧义 <tt class="docutils literal"><span class="pre">a @ @ b</span></tt> 到底是 <tt class="docutils literal"><span class="pre">(a) @ (@b)</span></tt> 还是 <tt class="docutils literal"><span class="pre">(a@) @ (b)</span></tt>呢？<br/>在Nim中没有后缀操作符，因此是 <tt class="docutils literal"><span class="pre">(a) @ (@b)</span></tt></p>

<p>除了内置的关键字操作符，如：<tt class="docutils literal"><span class="pre">and</span></tt>、<tt class="docutils literal"><span class="pre">or</span></tt>、<tt class="docutils literal"><span class="pre">not</span></tt>， 操作符总是由下面这些字符组成的：<br/><tt class="docutils literal"><span class="pre">+ - * \ / &lt; &gt; = @ $ ~ &amp; % ! ? ^ . |</span></tt></p>
<p>自定义操作符是可以的，没啥能阻止你定义这样的一个操作符 <tt class="docutils literal"><span class="pre">@!?+~</span></tt> ，不过可读性就成问题了</p>
<p>操作符的优先级是他的第一个字符决定的，更多的细节在manual中可以找到</p>
<p>定义新的操作符，只需要用&quot;``&quot;将它包裹起来就好了：</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myDataType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Comment"># 现在 $ 操作符也能对 myDataType 类型起左右了</span></pre>
<p> 用&quot;``&quot;  包裹操作符，就可以像调用普通proc一样直接调用这个操作符：</p>
<pre><span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;True&quot;</span><span class="Punctuation">)</span></pre>

<h2><a class="toc-backref" id="procedures-forward-declarations" href="#procedures-forward-declarations">Forward declarations(提前申明)</a></h2>
<p>每个变量、proc等在使用前都需要申明。(The reason for this is that it is non-trivial to do better than that in a language that supports meta programming as extensively as Nim does原因是不这么作，元编程实现起来异常麻烦.而且Nim中广泛的使用了元编程)。但是，对于相互引用的proc不是必须的：</p>
<pre><span class="Comment"># 提前申明even proc</span>
<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
<span class="Keyword">proc</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span> <span class="Keyword">or</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span> <span class="Keyword">or</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre>
  <p>例子中 <tt class="docutils literal"><span class="pre">odd</span></tt> 依赖 <tt class="docutils literal"><span class="pre">even</span></tt>，反之亦然。<br/>因此<tt class="docutils literal"><span class="pre">even</span></tt> 需要在它完全被定义之前，告诉编译器even是什么样的。<br/>
  提前申明的语法非常简单：只需要省略掉 <tt class="docutils literal"><span class="pre">=</span></tt> 和对应的实现就可以了</p>
<p>Nim以后的版本实现中将弱化这个需要</p>
<p>这个例子也展示了一个proc的实现可以仅是一个表达式，表达式的值将被隐含的作为proc的返回值</p>

<h1><a class="toc-backref" id="iterators" href="#iterators">Iterators(迭代器)</a></h1>
<p>我们回到上面那个无聊的计数例子：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Counting to ten: &quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span></pre>
  <p>能写个支持这个循环的 <a class="reference external" href="system.html#countup">countup</a> proc 吗?我们来尝试下：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre>
    <p>然而，这并不能达到我们的要求。 问题在于，这个proc不能只是 <tt class="docutils literal"><span class="pre">return</span></tt>，应该是返回然后在后续的一个迭代完成后能继续跳转回来。<em>return and continue(返回和继续)</em> 被称为 <cite>yield</cite> 语句。<br/>
    现在还需要作的最后一件事情是将 <tt class="docutils literal"><span class="pre">proc</span></tt> 关键字替换为 <tt class="docutils literal"><span class="pre">iterator</span></tt> 。好了这是我们第一个迭代器：</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre>
    <p>迭代器看上去和proc非常相似，但是他们有几个重要的区别：</p>
<ul class="simple"><li>迭代器只能在循环中使用</li>
<li>迭代器不能包含 <tt class="docutils literal"><span class="pre">return</span></tt> 语句，类似的proc不能包含 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句</li>
<li>迭代器没有隐含的 <tt class="docutils literal"><span class="pre">result</span></tt> 变量</li>
<li>迭代器不支持递归</li>
<li>迭代器不能提前申明，因为编译器必须能够内联它。(这个限制在后续Nim中可能会被取消)</li>
</ul>
<p>然而，你可以使用 <tt class="docutils literal"><span class="pre">closure(封闭)</span></tt>的迭代器得到不同的限制。 详情可见 <a class="reference external" href="manual.html#first-class-iterators">first class iterators</a>。<br/>迭代器可以和proc有同样的名字和参数，因为他们在各自的命名空间中。<br/>因此通常实践中都会将迭代器的名字设定与对应proc的名字一样,这样这个proc只需要收集相应迭代器的返回值作为序列返回就好了。如<a class="reference external" href="strutils.html">strutils</a>模块中的<tt class="docutils literal"><span class="pre">split</span></tt>。</p>

<h1><a class="toc-backref" id="basic-types" href="#basic-types">Basic types(基础类型)</a></h1>
<p>本节讨论内置的基础类型以及他们可能的操作。</p>

<h2><a class="toc-backref" id="basic-types-booleans" href="#basic-types-booleans">Booleans(布尔)</a></h2>
<p>Nim中布尔类型用 <tt class="docutils literal"><span class="pre">bool</span></tt> 来表示，有２个可用的值<tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt>。<br/>while, if, elif, when 语句中条件部分都必须是bool类型。</p>
<p>bool类型使用操作有 <tt class="docutils literal"><span class="pre">not, and, or, xor, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></tt>。<br/>其中 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> 是short-cut evaluation(短路评价)。如：</p>
<pre><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果 p == nil,那么p.name != "xyz"就不会评价。通过这类方式，就可以避免一些不必要的if语句了.</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre>

<h2><a class="toc-backref" id="basic-types-characters" href="#basic-types-characters">Characters(字符)</a></h2>
<p>Nim中字符类型用 <tt class="docutils literal"><span class="pre">char</span></tt>来表示。<br/>
基于效率原因，char大小设置为１个Byte(字节)，因此char只能表示一部分的UTF-8字符(注: UTF-8是一个不定长编码需要1-6个字节来表示一个字符)。<br/>
char值用单引号包裹起来，如'a'。<br/>
for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this.</p>
<p>字符之间能够用 <tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt> 来比较操作。<br/><tt class="docutils literal"><span class="pre">$</span></tt>操作符将一个<tt class="docutils literal"><span class="pre">字符</span></tt> 转换为<tt class="docutils literal"><span class="pre">string(字符串)</span></tt>。<br/>字符不能和整数混用<br/>可以用<tt class="docutils literal"><span class="pre">ord</span></tt>过程得到某个<tt class="docutils literal"><span class="pre">字符</span></tt>的序数值，通过<tt class="docutils literal"><span class="pre">chr</span></tt>过程将一个<tt class="docutils literal"><span class="pre">整数</span></tt>转换为字符。(注:整数要是大于255,chr将会抛出异常的)</p>

<h2><a class="toc-backref" id="basic-types-strings" href="#basic-types-strings">Strings(字符串)</a></h2>
<p>Nim中字符串是<strong>可变的</strong>,因此给字符串添加新串效率是非常高的。<br/>Nim中字符串是<strong>0结尾</strong>的，而且还有一个<strong>长度字段</strong>。<br/>内置过程<tt class="docutils literal"><span class="pre">len</span></tt>可以得到字符串的长度；长度值不计算结尾零。<br/>
读取结尾零不会发生错误，这样代码会简单点：</p>
<pre><span class="Keyword">if</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="CharLit">'a'</span> <span class="Keyword">and</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Operator">+</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="CharLit">'b'</span><span class="Punctuation">:</span>
  <span class="Comment"># 不需要检查 ``i &lt; len(s)``!</span>
  <span class="Operator">...</span></pre>
  <p>字符串见的赋值是用<strong>完全拷贝</strong>来实现(这样原始的和赋值后的是２个独立的字符串了)。<br/>
  <tt class="docutils literal"><span class="pre">&amp;</span></tt> 操作符连接字符串<br/>
  <tt class="docutils literal"><span class="pre">add</span></tt> 过程添加到字符串(如: astring.add(onestring))</p>

<p>字符串之间通过他们的字典序来判定大小，所以可以使用全部的比较操作。<br/>
习惯上字符串都是UTF-8串来表示的，注意这不是强制的。 例如: 当从一个二进制文件中读取字符串时，这时是一个字节序列。<br/><tt class="docutils literal"><span class="pre">s[i]</span></tt> 返回的是 <tt class="docutils literal"><span class="pre">s</span></tt>的第i个<em>字符</em>，而不是第i个<em>unichar(unicode字符)</em>。</p>

<p>字符串变量都是用一个特殊值 <tt class="docutils literal"><span class="pre">nil</span></tt>来初始化的(基于性能考虑)。<br/> 但是一个坑是，大多数的字符串操作是不能处理 <tt class="docutils literal"><span class="pre">nil</span></tt>的 (会抛出异常)。<br/>
一个解决办法是用空串 <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt>而不是用 <tt class="docutils literal"><span class="pre">nil</span></tt>　来作为 <em>empty value(空值)</em>。不过会有性能上的开销，因为<tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> 需要是在堆上创建一个字符串对象。</p>

<h2><a class="toc-backref" id="basic-types-integers" href="#basic-types-integers">Integers(整数)</a></h2>
<p>Nim有如下内置的整数类型： <tt class="docutils literal"><span class="pre">int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64</span></tt></p>
<p>默认的整数类型是 <tt class="docutils literal"><span class="pre">int</span></tt>。立即值增加 <em>type suffix(类型后缀)</em> 用来特指某种整数类型：</p>
<pre><span class="Keyword">let</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># x 是 ``int`` 类型</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0'i8</span>  <span class="Comment"># y 是 ``int8`` 类型</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="DecNumber">0'i64</span> <span class="Comment"># z 是 ``int64`` 类型</span>
  <span class="Identifier">u</span> <span class="Operator">=</span> <span class="DecNumber">0'</span><span class="Identifier">u</span>   <span class="Comment"># u 是 ``uint`` 类型</span></pre>
  <p>Most often integers are used for counting objects that reside in memory, <tt class="docutils literal"><span class="pre">int</span></tt> 和pointer(指针)的占用的字节数相同。</p>
<p>常用操作 <tt class="docutils literal"><span class="pre">+ - * div mod &lt; &lt;= == != &gt; &gt;=</span></tt> 整数都是适用的。<br/> 整数的<em>bitwise(位)</em>操作有 <tt class="docutils literal"><span class="pre">and or xor not</span></tt> 。 <br/>左移位 <tt class="docutils literal"><span class="pre">shl</span></tt>，右移位 <tt class="docutils literal"><span class="pre">shr</span></tt> 。<br/> 移位操作时，整数总是看待为 <em>unsigned(无符号)</em>的(注：汇编之类的有符号移位、无符号移位)。<br/>For <span id="arithmetic-bit-shifts_1">arithmetic bit shifts</span> ordinary multiplication or division can be used.</p>
<p>Unsigned operations all wrap around(无符号操作是自动回绕的); 无符号操作不会有溢出(上溢，下溢)错误。</p>
<p>在不同类型的整数之间发生运算时，会执行<span id="automatic-type-conversion_1">Automatic type conversion(自动类型转换)</span> 。<br/>但是，如果类型转换过程中丢失了一些信息， 将抛出 <span id="eoutofrange_1">EOutOfRange</span> 异常 (在编译器这个错误不能检测出的情况下)</p>

<h2><a class="toc-backref" id="basic-types-floats" href="#basic-types-floats">Floats(浮点数)</a></h2>
<p>Nim中有如下的内置浮点类型：<tt class="docutils literal"><span class="pre">float float32 float64</span></tt>.</p>
<p>默认的浮点类型是 <tt class="docutils literal"><span class="pre">float</span></tt>. 在当前实现中，<tt class="docutils literal"><span class="pre">float</span></tt> 总是64位的</p>
<p>浮点立即数一样有 <em>类型后缀</em>来明确指出是哪种类型的浮点数：</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>      <span class="Comment"># x 是 ``float`` 类型</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f32</span>  <span class="Comment"># y 是 ``float32``  类型</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f64</span>  <span class="Comment"># z 是``float64``  类型</span></pre>
  <p>浮点类型也适用这些常见的操作 <tt class="docutils literal"><span class="pre">+ - * / &lt; &lt;= == != &gt; &gt;=</span></tt> ，并且遵守 IEEE 标准。</p>
<p>在不同类型的浮点数之间发生运算时，会自动进行类型转换：小的类型转换为大的。<br/>
在整数和浮点混合运算时，整数型并<strong>不会</strong>自动的转换为浮点型，反之亦然。<br/>
必须使用 <a class="reference external" href="system.html#toInt">toInt</a> 和 <a class="reference external" href="system.html#toFloat">toFloat</a> 过程进行转换</p>

<h2><a class="toc-backref" id="basic-types-type-conversion" href="#basic-types-type-conversion">Type Conversion(类型转换)</a></h2>
<p>Nim中，可以用类型作为函数来显示的进行基础类型的类型转换：</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">int32</span>   <span class="Comment"># 与调用 int32(1) 一样</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int8</span>  <span class="Operator">=</span> <span class="Identifier">int8</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Comment"># 'a' == 97'i8</span>
  <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="FloatNumber">2.5</span>       <span class="Comment"># int(2.5) 会取整到2</span>
  <span class="Identifier">sum</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># sum == 100</span></pre>
<h1><a class="toc-backref" id="internal-type-representation" href="#internal-type-representation">Internal type representation(内部类型表达)</a></h1>
<p>前面提到, 内置操作符 <a class="reference external" href="system.html#$">$</a> (stringify) 将任何基础类型转换为字符串。这样就能够用 <tt class="docutils literal"><span class="pre">echo</span></tt> 过程输出到屏幕上了。<br/>
然而高级类型或则你自定义的类型用操作符<tt class="docutils literal"><span class="pre">$</span></tt>并不能转换为字符串，除非你定义了这个转换(用操作符重载)。 <br/>
有时你只是想调试下当前没有定义<tt class="docutils literal"><span class="pre">$</span></tt>操作符的复杂类型的值 ，这时可以用 <a class="reference external" href="system.html#repr">repr</a> 过程来转换。此过程能适用于任何的类型甚至复杂的complex data graphs with cycles(带有循环的数据图)。<br/>
从下面的例子还能看出，即使是基础类型 <tt class="docutils literal"><span class="pre">$</span></tt> 和 <tt class="docutils literal"><span class="pre">repr</span></tt> 的输出还是有所不同的：</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">myBool</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">myCharacter</span> <span class="Operator">=</span> <span class="CharLit">'n'</span>
  <span class="Identifier">myString</span> <span class="Operator">=</span> <span class="StringLit">&quot;nim&quot;</span>
  <span class="Identifier">myInteger</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
  <span class="Identifier">myFloat</span> <span class="Operator">=</span> <span class="FloatNumber">3.14</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myBool</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myBool</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; true:true</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myCharacter</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myCharacter</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; n:'n'</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myString</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myString</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; nim:0x10fa8c050&quot;nim&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myInteger</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myInteger</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 42:42</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">myFloat</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myFloat</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 3.1400000000000001e+00:3.1400000000000001e+00</span></pre>

<h1><a class="toc-backref" id="advanced-types" href="#advanced-types">Advanced types(高级类型)</a></h1>
<p>在Nim中可以使用 <tt class="docutils literal"><span class="pre">type</span></tt> 语句来定义个新的类型：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">biggestInt</span> <span class="Operator">=</span> <span class="Identifier">int64</span>      <span class="Comment"># biggest integer type that is available</span>
  <span class="Identifier">biggestFloat</span> <span class="Operator">=</span> <span class="Identifier">float64</span>  <span class="Comment"># biggest float type that is available</span></pre>
  <p>枚举和对象类型只能在 <tt class="docutils literal"><span class="pre">type</span></tt> 语句中定义</p>

<h2><a class="toc-backref" id="advanced-types-enumerations" href="#advanced-types-enumerations">Enumerations(枚举)</a></h2>
<p>枚举类型的变量的值必须在一个有限可能的集合中。这个集合是由有序的符号组成。<br/>
每个符号在内部对应一个整数值。第一个符号对应0，第二个对应１，以此类推。 如：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">south</span>      <span class="Comment"># `x` 是 `Direction` 类型，值为 `south`</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span>           <span class="Comment"># 输出 &quot;south&quot; 到屏幕</span></pre>
<p>枚举类型可以进行各类比较操作</p>
<p>枚举符号通过提拎可以避免歧义: <tt class="docutils literal"><span class="pre">Direction.south</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">$</span></tt> 能将任何枚举值转变成对应的名字(字符串)，<tt class="docutils literal"><span class="pre">ord</span></tt> 过程返回这个枚举值对应的内部整数值。</p>
<p>为了对其他语言接口更友好，枚举类型的符号可以被显式的设定一个序数值。但是同一个枚举类型的序数值必须是按照升序设定的。 没有显式设定的符号的值将会是它前一个符号的值 + 1</p>
<p>一个明确设定的枚举类型的值是运行不连续的，也就是可以有 <em>洞</em>：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="DecNumber">89</span></pre>

<h2><a class="toc-backref" id="advanced-types-ordinal-types" href="#advanced-types-ordinal-types">Ordinal types(序数类型)</a></h2>
<p>序数类型包括连续值的枚举、整数类型、 <tt class="docutils literal"><span class="pre">char</span></tt> 以及 <tt class="docutils literal"><span class="pre">bool</span></tt> (and 子区间)。<br/>序数类型有如下特别的操作：</p>
<table border="1" class="docutils"><tr><th>操作</th><th>操作说明</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">ord(x)</span></tt></td><td>返回 <cite>x</cite> 的整数值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">inc(x)</span></tt></td><td> <cite>x</cite> 加 1</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">inc(x, n)</span></tt></td><td><cite>x</cite> 加 <cite>n</cite>; <cite>n</cite> 是整数</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">dec(x)</span></tt></td><td><cite>x</cite> 减 1</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">dec(x, n)</span></tt></td><td><cite>x</cite> 减 <cite>n</cite>; <cite>n</cite> 是整数</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">succ(x)</span></tt></td><td>返回 <cite>x</cite> 的下一个值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">succ(x, n)</span></tt></td><td>返回 <cite>x</cite> 后的第 <cite>n</cite>位的值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">pred(x)</span></tt></td><td>返回 <cite>x</cite> 前一位的值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">pred(x, n)</span></tt></td><td>返回 <cite>x</cite> 前第 <cite>n</cite>个的值</td></tr>
</table>
<p><a class="reference external" href="system.html#inc">inc</a>、 <a class="reference external" href="system.html#dec">dec</a>、 <a class="reference external" href="system.html#succ">succ</a> 和 <a class="reference external" href="system.html#pred">pred</a> 操作可能会抛出 <cite>EOutOfRange(越界)</cite> 或 <cite>EOverflow(溢出)</cite> 异常(如果编译代码的时候启用了runtime checks(运行期检查) 开关)。</p>

<h2><a class="toc-backref" id="advanced-types-subranges" href="#advanced-types-subranges">Subranges(子区间)</a></h2>
<p>子区间是整数值或枚举值中一部分值形成的值区间。如：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Subrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span></pre>
  <p><tt class="docutils literal"><span class="pre">Subrange</span></tt> 是一个 <tt class="docutils literal"><span class="pre">int</span></tt>类型的子区间，它的值只能是从 0 到 5。给<tt class="docutils literal"><span class="pre">Subrange</span></tt> 赋一个同类型的其他值都将引发编译器错误或则运行期错误。在基础类型和子区间来回赋值是可以的，只要相应的基础类型的值在子区间中。</p>
<p><tt class="docutils literal"><span class="pre">system</span></tt> 模块定义了一个重要的类型 <a class="reference external" href="system.html#Natural">Natural</a> ，内容为 <tt class="docutils literal"><span class="pre">range[0..high(int)]</span></tt> (<a class="reference external" href="system.html#high">high</a> 过程返回int的最大值)。<br/>其他的变成语言要求用无符号整数作为自然数，但这通常是 <strong>错误</strong>的：<br/>
you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative(并不是因为这些数不是负数就用无符号的算数运算)。 <br/>Nim 的 <tt class="docutils literal"><span class="pre">Natural</span></tt> 类型帮助避免这种编程错误。</p>

<h2><a class="toc-backref" id="advanced-types-sets" href="#advanced-types-sets">Sets(集合)</a></h2>
<p>集合类型是数学中的集合概念。集合的基础类型只能是序数类型，因为集合是用高性能的位向量实现的。</p>
<p>一个集合可以通过集合构造器来构造： <tt class="docutils literal"><span class="pre">{}</span></tt> 是一个空集合。空集合与任何具体的集合类型在类型上都是兼容的。<br/>
构造器可以包含多个元素或元素区间：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># 集合构造器包含了</span>
                         <span class="Comment"># 从 'a' 到 'z' 的英文字符</span>
                         <span class="Comment"># 从 '0' to '9' 的数字字符</span></pre>
<p>集合支持如下的操作：</p>
<table border="1" class="docutils"><tr><th>操作</th><th>说明</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">A + B</span></tt></td><td>两个集合的并 of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A * B</span></tt></td><td>两个集合的交</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A - B</span></tt></td><td>两个集合的不同 (Ａ中存在，B中不存在的)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A == B</span></tt></td><td>两个集合是否相等</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt;= B</span></tt></td><td>子集关系(A 是 B 的子集或则等于 B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt; B</span></tt></td><td>真子集关系(A 是 B 的真子集)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e in A</span></tt></td><td>集合成员 (A中含有元素 e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e notin A</span></tt></td><td>A 中不含有元素 e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">contains(A, e)</span></tt></td><td>A 中含有元素 e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">card(A)</span></tt></td><td>A集合的势 (A中元素的数目)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">incl(A, elem)</span></tt></td><td>与 <tt class="docutils literal"><span class="pre">A = A + {elem}</span></tt>相同。在 A 中增加一个元素elem</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">excl(A, elem)</span></tt></td><td>与 <tt class="docutils literal"><span class="pre">A = A - {elem}</span></tt>相同。在 A 中减少一个元素elem</td></tr>
</table><p>集合常用来定义为一个过程的<em>标志</em>。</p>

<h2><a class="toc-backref" id="advanced-types-arrays" href="#advanced-types-arrays">Arrays(数组)</a></h2>
<p>数组只是一个简单的固定长度的容器。数组中的每个元素具有相同的类型。数字的index(下标)类型可以是任意序数类型</p>
<p>数组可以通过 <tt class="docutils literal"><span class="pre">[]</span></tt>构造：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 一个数组，下标从0到5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
  <p><tt class="docutils literal"><span class="pre">x[i]</span></tt> 表示得到<tt class="docutils literal"><span class="pre">x</span></tt>的第 i 个元素。 数组的读写默认总是检查下标的，防制越界(无论编译期还是运行期)。 在编译的时候使用开关 <tt class="docutils literal"><span class="pre">--bound_checks:off</span></tt> 可以关闭这个检查。</p>
<p>数组同其他Nim类型一样是<strong>值类型</strong>。赋值操作将复制整个数组的内容。</p>
<p>内置的 <a class="reference external" href="system.html#len,TOpenArray">len</a> 过程返回数组的长度。<a class="reference external" href="system.html#low">low(a)</a> 返回数组<cite>a</cite>最小的下标值 ，<a class="reference external" href="system.html#high">high(a)</a> 返回最大的下标值。</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>
  <span class="Identifier">BlinkLights</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">slowBlink</span><span class="Punctuation">,</span> <span class="Identifier">mediumBlink</span><span class="Punctuation">,</span> <span class="Identifier">fastBlink</span>
  <span class="Identifier">LevelSetting</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">level</span><span class="Punctuation">:</span> <span class="Identifier">LevelSetting</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">on</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">south</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">fastBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; [on, fastBlink, slowBlink, off]</span>
<span class="Identifier">echo</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; north</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; west</span></pre>
<p>嵌套数组(多维数组)，在其他语言语言中只要增加上更多的括号就够了，因为通常每个维度的下标类型都散一样的。
在Nim中每维可以有不同的下标类型，因此嵌套语法有点不同。<br/>
前面的例子中，Level是一个２维的数组，每个维度的下标都是枚举类型。<br/>我们添加下面的代码就可将一个灯塔类型添加进去，这个类型的数组的下标是数字的：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">LevelSetting</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">tower</span><span class="Punctuation">:</span> <span class="Identifier">LightTower</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">mediumBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>     <span class="Comment"># --&gt; 10</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>    <span class="Comment"># --&gt; [[slowBlink, mediumBlink, ...more output..</span>
<span class="Comment"># The following lines don't compile due to type mismatch errors</span>
<span class="Comment">#tower[north][east] = on</span>
<span class="Comment">#tower[0][1] = on</span></pre>
<p>注意，内置的 <tt class="docutils literal"><span class="pre">len</span></tt> 过程只返回数组的第一维的长度。<br/>另外一种定义 <tt class="docutils literal"><span class="pre">LightTower</span></tt>类型的方法能更好的显示出嵌套的内容，省略前面提到的 <tt class="docutils literal"><span class="pre">LevelSetting</span></tt>　类型，直接的将LevelSetting类型的定义内嵌过来：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span><span class="Punctuation">]</span></pre>
  <p>数组从0开始是相当频繁的，因此有个简洁的数组下标范围的写法。<br/>直接指定这个数组的长度，这时的下标范围就是从０到数组长度-1：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 数组，下标从 0 到 5 </span>
  <span class="Identifier">QuickArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>  <span class="Comment"># 数组，下标也是从 0 到 5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">QuickArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">x</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="advanced-types-sequences" href="#advanced-types-sequences">Sequences(序列)</a></h2>
<p>序列类似数组但是序列的长度在运行期是可以动态调整的，因此序列都是在Heap(堆)上分配、而且会被自动垃圾回收(GC)</p>
<p>序列总是有一个类型为<tt class="docutils literal"><span class="pre">int</span></tt>且从0开始的下标。<br/><a class="reference external" href="system.html#len,seq[T]">len</a>、<a class="reference external" href="system.html#low">low</a> 以及 <a class="reference external" href="system.html#high">high</a> 过程对序列也是适用的。<tt class="docutils literal"><span class="pre">x[i]</span></tt> 表示序列 <tt class="docutils literal"><span class="pre">x</span></tt> 的第i个元素</p>

<p>序列可以通过在构造好的数组 <tt class="docutils literal"><span class="pre">[]</span></tt>前加上一个序列操作符 <tt class="docutils literal"><span class="pre">@</span></tt>来构造。另外一个方法就是使用内置的 <a class="reference external" href="system.html#newSeq">newSeq</a> 过程。</p>
<p>序列能够被传递给一个(openarray)开放数组参数。</p>
<p>例如：</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 一个整数序列</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># @操作符将数组转化为序列</span></pre>
<p>序列变量默认是被初始化为 <tt class="docutils literal"><span class="pre">nil</span></tt>的。 但是因为性能原因，大多数的序列操作是不处理 <tt class="docutils literal"><span class="pre">nil</span></tt>的(如果是nil会引发一个异常leading to)。因此，最好使用一个空序列 <tt class="docutils literal"><span class="pre">@[]</span></tt> 来初始化一个空值。不过 <tt class="docutils literal"><span class="pre">@[]</span></tt> 这样就会在堆上创建了一个序列对象带来一个小小的性能消耗。</p>
<p>当 <tt class="docutils literal"><span class="pre">for</span></tt> 语句在序列上遍历迭代时，有两种形式分别是导出一个变量和两个变量。 <br/>如果是一个变量的形式，那么这个变量对应的是序列的值。即 <tt class="docutils literal"><span class="pre">for</span></tt> 语句循环迭代的是<a class="reference external" href="system.html">system</a>模块中的<a class="reference external" href="system.html#items.i,seq[T]">items()</a>迭代子的结果。<br/>
如果使用两个变量的形式，第一个变量对应的是下标位置，第二个变量对应的是序列的值。即 <tt class="docutils literal"><span class="pre">for</span></tt> 语句循环迭代的是<a class="reference external" href="system.html">system</a>模块中的<a class="reference external" href="system.html#pairs.i,seq[T]">pairs()</a> 迭代子的结果。 <br/>如：</p>
<pre><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 3</span>
<span class="Comment"># --&gt; 4</span>
<span class="Comment"># --&gt; 5</span>

<span class="Keyword">for</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;index: &quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="StringLit">&quot;, value:&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">value</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; index: 0, value:3</span>
<span class="Comment"># --&gt; index: 1, value:4</span>
<span class="Comment"># --&gt; index: 2, value:5</span></pre>
<h2><a class="toc-backref" id="advanced-types-open-arrays" href="#advanced-types-open-arrays">Open arrays(开放数组)</a></h2><p><strong>注意</strong>：开放数组只能用于parameters(参数)</p>
<p>通常尺寸固定的数组都是不够灵活的；过程应当能够处理各种不同尺寸大小的数组 。而<span id="openarray_1">开放数组</span> 类型能满足这个需要。<br/>开放数组的下标总是从0开始，类型为 <tt class="docutils literal"><span class="pre">int</span></tt>。<br/><a class="reference external" href="system.html#len,TOpenArray">len</a>、<a class="reference external" href="system.html#low">low</a> 和 <a class="reference external" href="system.html#high">high</a> 操作也是对开放数组使用的。<br/>
任何兼容的基础类型数组都可以传给一个开放数组参数，下标的类型是无所谓兼容(Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter)</p>
<p>开放数组不支持嵌套定义(即多维开放数组是不支持的)，这没必要也不高效。</p>

<h2><a class="toc-backref" id="advanced-types-varargs" href="#advanced-types-varargs">Varargs(可变参数)</a></h2>
<p><tt class="docutils literal"><span class="pre">可变参数</span></tt> 和开放参数功能类似。<br/> 可变参数也可以将数目不定的变参传给过程。编译器自动的将这些调用参数转变为一个数组：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># 编译器将自动转化成下面的样子：</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
<p>只有当这个可变参数是过程的最后一个参数是，这个转化才会进行！！！<br/>转化的时候还可以进行类型转化：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># 编译器将自动转化成下面的样子：</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>上面的例子中 <a class="reference external" href="system.html#$">$</a> 将会对可变参<tt class="docutils literal"><span class="pre">a</span></tt>的每个传递过来的实际参数进行转化。<br/>注：对字符串进行 <a class="reference external" href="system.html#$">$</a> 转化是可以且没有任何变化的，相当于一个空操作。</p>

<h2><a class="toc-backref" id="advanced-types-slices" href="#advanced-types-slices">Slices(切片)</a></h2><p>切片和子区间在语法上很相似，但是他们用在不同的场景下。分片是Slice类型的对象，包括2个界限 <cite>a</cite> 和 <cite>b</cite>。<br/>一个分片独立的用途是不大的，但是其他的集合类型的操作都接受切片作为参数定义区间的。</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;Nim is a progamming language&quot;</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;Slices are useless.&quot;</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="FloatNumber">7.</span><span class="Operator">.</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Comment"># --&gt; 'a prog'</span>
<span class="Identifier">b</span><span class="Punctuation">[</span><span class="FloatNumber">11.</span><span class="Operator">.</span> <span class="Operator">-</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Comment"># --&gt; 'Slices are useful.'</span></pre>
<p>上面的例子中,切片用来修改一个字符串，甚至用了一个负的下标值。<br/>
The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.</p>
<p><strong>问题来了</strong>： 负的下标怎么算的?</p>

<h2><a class="toc-backref" id="advanced-types-tuples" href="#advanced-types-tuples">Tuples(元组)</a></h2><p>每个元组的类型由命名了的<em>fields(字段)</em> 以及字段的 <em>顺序(order)</em>唯一确定。<br/>
元组可以通过构造符 <tt class="docutils literal"><span class="pre">()</span></tt> 来创建。创建时候的字段顺序必须和定义的时候一样。 <br/>
如果两个不同的元组类型定义中的字段名字、字段类型、以及字段的顺序都相同，那么这两个元组类型认为是<em>等价(equivalent)</em>的。</p>
<p>元组的赋值操作是拷贝元组内的全部字段。<br/>
<tt class="docutils literal"><span class="pre">t.field</span></tt> 来访问元组的某个字段。<br/>
<tt class="docutils literal"><span class="pre">t[i]</span></tt> 访问元组的第<tt class="docutils literal"><span class="pre">i</span></tt>个字段。<tt class="docutils literal"><span class="pre">i</span></tt> 必须是一个常量整数(也就是在编译期能确定值)。</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 定义了一个 person 类型：</span>
                                         <span class="Comment"># 包含: name 和 age 字段</span>
<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># the same, but less readable:</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">name</span><span class="Punctuation">)</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">age</span><span class="Punctuation">)</span>  <span class="Comment"># 30</span>

<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># 30</span>

<span class="Comment"># 也可以直接的嵌套定义，不是必须在type里定义好类型再申明变量</span>
<span class="Keyword">var</span> <span class="Identifier">building</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">street</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">number</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
<span class="Identifier">building</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Rue del Percebe&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">13</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">building</span><span class="Operator">.</span><span class="Identifier">street</span><span class="Punctuation">)</span>

<span class="Comment"># 下面的代码是不能编译通过的，这两个是不同的元组！</span>
<span class="Comment">#person = building</span>
<span class="Comment"># 错误提示 &gt; Error: type mismatch: got (tuple[street: string, number: int])</span>
<span class="Comment">#     but expected 'Person'</span>

<span class="Comment"># 下面是合法的，因为他们的字段名称、类型、顺序都是一样的。</span>
<span class="Keyword">var</span> <span class="Identifier">teacher</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Mark&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">42</span><span class="Punctuation">)</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Identifier">teacher</span></pre>
<p>元组在变量赋值时可以被 <em>unpacked(拆箱)</em>(也只有这个时候可以！)。 <br/>
这样能很方面的将元组各字段的值付给一堆独立的变量。<br/>
 <a class="reference external" href="os.html">os 模块</a>中的<a class="reference external" href="os.html#splitFile">splitFile</a> 过程就是一个很好的例子，这个过程一次返回目录、基础名以及扩展名。<br/> 在元组拆箱时，<span class="pre">必须将你要赋的变量用括号()括起来</span>，否则将不是拆箱，而是<a href="#the-assignment-statement"><span class="pre">连续赋值</span></a>操作。</p>
<pre><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">let</span>
  <span class="Identifier">path</span> <span class="Operator">=</span> <span class="StringLit">&quot;usr/local/nimc.html&quot;</span>
  <span class="Punctuation">(</span><span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
  <span class="Identifier">baddir</span><span class="Punctuation">,</span> <span class="Identifier">badname</span><span class="Punctuation">,</span> <span class="Identifier">badext</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">dir</span>      <span class="Comment"># 输出 `usr/local`</span>
<span class="Identifier">echo</span> <span class="Identifier">name</span>     <span class="Comment"># 输出 `nimc`</span>
<span class="Identifier">echo</span> <span class="Identifier">ext</span>      <span class="Comment"># 输出 `.html`</span>
<span class="Comment"># 下面3个echo都输出同样的一行：</span>
<span class="Comment"># `(dir: usr/local, name: nimc, ext: .html)`</span>
<span class="Identifier">echo</span> <span class="Identifier">baddir</span>
<span class="Identifier">echo</span> <span class="Identifier">badname</span>
<span class="Identifier">echo</span> <span class="Identifier">badext</span></pre>
<p>元组拆箱<strong>只能运用在</strong> <tt class="docutils literal"><span class="pre">var</span></tt> 或 <tt class="docutils literal"><span class="pre">let</span></tt> 区块。下面的代码不能编译通过：</p>
<pre><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">var</span>
  <span class="Identifier">path</span> <span class="Operator">=</span> <span class="StringLit">&quot;usr/local/nimc.html&quot;</span>
  <span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Punctuation">(</span><span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; Error: '(dir, name, ext)' cannot be assigned to</span></pre>

<h2><a class="toc-backref" id="advanced-types-reference-and-pointer-types" href="#advanced-types-reference-and-pointer-types">Reference and pointer types(引用和指针类型)</a></h2>
<p>引用 与其他语言中的指针类似，一种引入多对一的关系的途径。也就是说多个不同的引用能够指向同一块内存位置，并修改对应的内容。</p>
<p>Nim 区分 <span id="traced_1">traced(追踪)</span> 和 <span id="untraced_1">untraced(不追踪)</span> 的引用，不追踪的引用也被称为 <em>pointers(指针)</em>。<br/>
追踪的引用指向一个在GC堆上的对象；指针指向一个手动分配的对象或则某些已经在内存中被分配好的对象，
因此指针是 <em>unsafe(不安全)</em>的。 <br/>
但是对于某些低级操作(比如访问硬件) 指针是不可避免也是必须的。</p>
<p>追踪的引用用关键字 <strong>ref</strong> ，指针用关键字 <strong>ptr</strong> </p>
<p> 空的<tt class="docutils literal"><span class="pre">[]</span></tt> 用来 <em>derefer(提领)</em> 一个引用，也就是得到这个引用指向的内容。<br/>
<tt class="docutils literal"><span class="pre">.</span></tt> (访问一个 元组或对象的字段) 和 <tt class="docutils literal"><span class="pre">[]</span></tt> (数组/字符串/序列的操作符) 都是隐含的执行了被引用类型的提领操作：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># 不需要写成 n[].data，相反 n[].data 是极度不鼓励的写法！(为啥呢?)</span></pre>
<p>内置过程 <tt class="docutils literal"><span class="pre">new</span></tt> 用来创建一个新的被追踪对象，同时设定了引用指向了这个对象。<br/>过程<tt class="docutils literal"><span class="pre">alloc</span></tt>、 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 和 <tt class="docutils literal"><span class="pre">realloc</span></tt> 用来分配不被追踪的对象(适用于指针)，
更多信息请参看<a class="reference external" href="system.html">system</a> 模块中相应说明。</p>
<p>空引用(未指向任何东西)的默认值为 <tt class="docutils literal"><span class="pre">nil</span></tt></p>

<h2><a class="toc-backref" id="advanced-types-procedural-type" href="#advanced-types-procedural-type">Procedural type(过程类型)</a></h2>
<p>过程类型某种意义上讲就是一个指向过程的指针。<tt class="docutils literal"><span class="pre">nil</span></tt> 可以被赋给任意的过程类型。Nim 用过程类型来实现 <span id="functional_1">functional programming(函数式编程)</span>  技术。</p>
<p>例如：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">echoItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">action</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">const</span>
    <span class="Identifier">data</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">,</span> <span class="DecNumber">11</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">d</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">action</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">echoItem</span><span class="Punctuation">)</span></pre>
<p>过程类型有一个需要注意的地方,那就是对相应过程调用的约定方式会影响这个过程类型的兼容性。<br/> 
过程类型只有他们对应的过程有相同的调用约定方式的情况下才是兼容的。详细的调用的约定方式列表见 <a class="reference external" href="manual.html">manual</a>(如stdcall,cdecl这样的)</p>

<h1><a class="toc-backref" id="modules" href="#modules">Modules(模块)</a></h1>
<p>Nim支持将程序按照模块划分。每个模块都有对应的文件。运用模块可以做到 <span id="information-hiding_1">信息隐藏</span> 和 <span id="separate-compilation_1">分开编写</span>。<br/>
通过  <span id="import_1">import</span> 语句，一个模块可以访问另外模块的符号。<br/>
只有最顶层的，并且用星号(<tt class="docutils literal"><span class="pre">*</span></tt>) 标识了的符号才是导出的符号(也就是其他模块可以访问的)：</p>
<pre><span class="Comment"># 模块 A</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># 调用newSeq过程，分配一个长度为len(a)的新序列</span>
  <span class="Identifier">newSeq</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># 两个int序列相乘</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Comment"># 检测下新的序列间 ``*`` 操作符</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">9</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
  <p>上面的模块中导出了 <tt class="docutils literal"><span class="pre">x</span></tt> 和 <tt class="docutils literal"><span class="pre">*</span></tt>(乘法操作符)， <tt class="docutils literal"><span class="pre">y</span></tt>是没有被导出的</p>

<p>模块的最顶层语句会在程序开始的时候被自动执行，如此可以用来初始化一些复杂的数据结构。</p>
<p>每个模块有一个特殊的魔法常量 <tt class="docutils literal"><span class="pre">isMainModule</span></tt> ，如果这个模块是主模块(程序入口模块)那么isMainModule将是true(真)。如上面例子所示，非常合适用来作内嵌的模块测试。</p>

<p>模块之间是可以互相依赖的。但是非常不建议如此，因为在此情况下，要想重用任一模块，必须包含全部互相依赖的模块了。</p>
<p>模块编译算法如下：</p>
<ul class="simple"><li>编译时，如果有import语句则先编译被import的模块。</li>
<li>如果编译存在一个圈了，那么只导入那些已经被编译过的符号(这些符号是被注明导出的)；如果有一个未知的标识符出现则报错退出。</li>
</ul>
<p>通过一个例子来说明：</p>
<pre><span class="Comment"># 模块 A</span>
<span class="Keyword">type</span>
  <span class="Identifier">T1</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">int</span>  <span class="Comment"># 模块 A 导出了类型 ``T1``</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>     <span class="Comment"># 编译器开始分析模块B了</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 工作正常，此时模块B已经编译完毕了</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><pre><span class="Comment"># 模块 B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>  <span class="Comment">#　遇到个圈了，A在此还没有编译完呢，那么现在只有A中已经编译好的符号才导入。</span>
          <span class="Comment"># 在此也不跳回A继续编译A了，而是继续向下编译模块B。</span>
          <span class="Comment"># 对照A，也就是说此时A中的T1是可见的了</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span> <span class="Operator">=</span>
  <span class="Comment"># 正常工作，编译器此时已经知道T1是啥的了</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">1</span></pre>
<p>模块中的符号 <em>可以通过</em> <tt class="docutils literal"><span class="pre">module.symbol</span></tt> 这种语法被明确。如果符号有歧义就必须通过这种方式来明确了。 <br/>比如在两个或则更多的模块中都导出了相同的符号，他们都被第三方模块导入：</p>
<pre><span class="Comment"># 模块 A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre><pre><span class="Comment"># 模块 B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre><pre><span class="Comment"># 模块 C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 错误: x 有歧义了</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 正常：x被限定了</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 没歧义了: 用模块C的 x</span>
                 <span class="Comment"># 因为上面定义了x，在模块C的空间中出现了x，优先选择本空间的。</span></pre>
<p>但是这个规则不适用于过程和迭代器，他们使用重载规则：</p>
<pre><span class="Comment"># 模块 A</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre><pre><span class="Comment"># 模块  B</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre><pre><span class="Comment"># 模块  C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># 正常：调用 A.x </span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>  <span class="Comment"># 正常：调用  B.x</span>

<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">nil</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># 有歧义了: 调用哪个 `x`? (A.x还是C.x?)</span></pre>
<h2><a class="toc-backref" id="modules-excluding-symbols" href="#modules-excluding-symbols">Excluding symbols(排除符号)</a></h2>
<p><tt class="docutils literal"><span class="pre">import</span></tt> 语句会导入相应模块的全部的导出符号，可以通过<tt class="docutils literal"><span class="pre">except</span></tt>来排除需不需要导入的符号。</p>
<pre><span class="Keyword">import</span> <span class="Identifier">mymodule</span> <span class="Keyword">except</span> <span class="Identifier">y</span></pre>

<h2><a class="toc-backref" id="modules-from-statement" href="#modules-from-statement">From statement(From语句)</a></h2>
<p>我们已经知道单纯的 <tt class="docutils literal"><span class="pre">import</span></tt> 会导入全部的导出符号，另外一个只导入部分符号的办法是 <tt class="docutils literal"><span class="pre">from import</span></tt> 语句。</p>
<pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span></pre>
<p> <tt class="docutils literal"><span class="pre">from</span></tt> 语句也能强制使用命名空间来限定符号，这样可以使得那些没明确导入的符号也可用。</p>
<pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># 合法 x被明确导入了的</span></pre><pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">mymodule</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>  <span class="Comment"># 必须用模块名字限定x</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># 编译出错</span></pre>
<p>因为模块名称通常上会比较长，因此也可以定义一个简短的别名，这样限定的时候就能少输入好几次了。</p>
<pre><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">as</span> <span class="Identifier">m</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>         <span class="Comment"># m 是模块的别名</span></pre>
<h2><a class="toc-backref" id="modules-include-statement" href="#modules-include-statement">Include statement(Include语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">include</span></tt>语句与导入语句有些根本不同：即include语句只是将文件包含进来，成为当前模块的一部分。<br/>因此可以用来将一个大的模块分隔成几个小的文件：</p>
<pre><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre>

<h1><a class="toc-backref" id="part-2" href="#part-2">Part 2(第二部分)</a></h1>
<p>好了，基础的到此结束了。<br/>
让我们看看Nim除此之外还提供了点什么：<a class="reference external" href="tut2.html">Part II(第二部分)</a></p>
</p>
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-05-04 19:40:46 UTC</small>
        <small> <a href="http://d-l.github.io" target="_blank">D-L</a>译于2015-07-28 00:07:21</small>
      </div>
    </div>
  </div>
</div>    
</body>
</html>