<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Favicon -->
<link rel="shortcut icon" href="./nim.ico" />
<link href="./tut.css" rel="stylesheet">
<!-- Google fonts -->
<!-- 先屏蔽google 字体
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'>
-->
<!-- CSS -->
<title>Nim Tutorial (第二部分)</title>
</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim Tutorial (第二部分)</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="introduction_toc" href="#introduction">Introduction(介绍)</a></li>
<li><a class="reference" id="pragmas_toc" href="#pragmas">Pragmas(编译指示)</a></li>
<li><a class="reference" id="object-oriented-programming_toc" href="#object-oriented-programming">Object Oriented Programming(面向对象编程)</a></li>
<ul class="simple"><li><a class="reference" id="object-oriented-programming-objects_toc" href="#object-oriented-programming-objects">Objects(对象)</a></li>
<li><a class="reference" id="object-oriented-programming-mutually-recursive-types_toc" href="#object-oriented-programming-mutually-recursive-types">Mutually recursive types(相互引用类型)</a></li>
<li><a class="reference" id="object-oriented-programming-type-conversions_toc" href="#object-oriented-programming-type-conversions">Type conversions(类型转换)</a></li>
<li><a class="reference" id="object-oriented-programming-object-variants_toc" href="#object-oriented-programming-object-variants">Object variants(变异对象)</a></li>
<li><a class="reference" id="object-oriented-programming-methods_toc" href="#object-oriented-programming-methods">Methods(方法)</a></li>
<li><a class="reference" id="object-oriented-programming-method-call-syntax_toc" href="#object-oriented-programming-method-call-syntax">Method call syntax(方法调用语法)</a></li>
<li><a class="reference" id="object-oriented-programming-properties_toc" href="#object-oriented-programming-properties">Properties(属性)</a></li>
<li><a class="reference" id="object-oriented-programming-dynamic-dispatch_toc" href="#object-oriented-programming-dynamic-dispatch">Dynamic dispatch(动态分发)</a></li>
</ul><li><a class="reference" id="exceptions_toc" href="#exceptions">Exceptions(异常)</a></li>
<ul class="simple"><li><a class="reference" id="exceptions-raise-statement_toc" href="#exceptions-raise-statement">Raise statement(Raise语句)</a></li>
<li><a class="reference" id="exceptions-try-statement_toc" href="#exceptions-try-statement">Try statement(Try语句)</a></li>
<li><a class="reference" id="exceptions-annotating-procs-with-raised-exceptions_toc" href="#exceptions-annotating-procs-with-raised-exceptions">Annotating procs with raised exceptions(过程的异常抛出指示)</a></li>
</ul><li><a class="reference" id="generics_toc" href="#generics">Generics(范型)</a></li>
<li><a class="reference" id="templates_toc" href="#templates">Templates(模板)</a></li>
<li><a class="reference" id="macros_toc" href="#macros">Macros(宏)</a></li>
<ul class="simple"><li><a class="reference" id="macros-expression-macros_toc" href="#macros-expression-macros">Expression Macros(表达式宏)</a></li>
<li><a class="reference" id="macros-statement-macros_toc" href="#macros-statement-macros">Statement Macros(申明宏)</a></li>
<li><a class="reference" id="macros-building-your-first-macro_toc" href="#macros-building-your-first-macro">Building your first macro(创建你的第一个宏)</a></li>
<ul class="simple"><li><a class="reference" id="building-your-first-macro-generating-source-code_toc" href="#building-your-first-macro-generating-source-code">Generating source code(产生源代码)</a></li>
<li><a class="reference" id="building-your-first-macro-generating-ast-by-hand_toc" href="#building-your-first-macro-generating-ast-by-hand">Generating AST by hand(手工生成AST)</a></li>
</ul></ul>
</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">作者：</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">适用版本：</th><td> 0.11.2</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="introduction" href="#introduction">Introduction(介绍)</a></h1>
<blockquote><p>&quot;Repetition renders the ridiculous reasonable.&quot; -- Norman Wildberger</p></blockquote>
<p>本文档是关于<em>Nim</em>编程语言高级结构的教程。<strong>注意，本文档相对<a class="reference external" href="manual.html">手册</a> <strong>来说更生动，毕竟包含了更多的实例哟。</p>

<h1><a class="toc-backref" id="pragmas" href="#pragmas">Pragmas(编译指示)</a></h1>
<p>通过编译指示可以告知编译器一些额外的信息或命令，这样避免又要增加一大堆的关键字来作这些工作。 <br/>
编译指示由 <tt class="docutils literal"><span class="pre">{.</span></tt> 和 <tt class="docutils literal"><span class="pre">.}</span></tt> 包裹起来。本教程中没有涉及编译指示的相关内容。更多可见 <a class="reference external" href="manual.html#pragmas">手册</a> 或 <a class="reference external" href="nimc.html#additional-features">用户指导文档</a>。</p>
<h1><a class="toc-backref" id="object-oriented-programming" href="#object-oriented-programming">Object Oriented Programming(面向对象编程)</a></h1>
<p>虽然Nim对OOP是最小限度的支持，但是高级的OOP技术也是能运用的。<br/>
OOP 是设计程序的一条途径，但不是唯一的一条。 <br/>
通常来说程序越简单，生成的代码效率越高。<br/>
实践上，组合相对继承来说是更优的设计。</p>
<h2><a class="toc-backref" id="object-oriented-programming-objects" href="#object-oriented-programming-objects">Objects(对象)</a></h2>
<p>与元组类似，对象也可以将不同的值以一种结构化的方式打包在一起。但是对象也提供了很多元组所不具有的特性：继承以及信息隐藏。<br/>
既然对象封装了数据，那么 <tt class="docutils literal"><span class="pre">T()</span></tt> (对象内的数据)的构造应该只在对象内部使用，因此开发人员应该提供一个过程来初始化这个对象(这个过程也被成为 <em>constructor(构造器)</em>)。</p>
<p>对象可以在运行期用 <tt class="docutils literal"><span class="pre">of</span></tt> 操作符来检查对象的类型：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>  <span class="Comment">#  * 说明 `name`字段可以被其他的模块访问</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>       <span class="Comment"># 没有 * 说明其他的模块是不能访问这个字段的</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># Student 从 Person 继承而来</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                      <span class="Comment"># 附带了一个 id 字段</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># 真</span>
<span class="Comment"># object construction:</span>
<span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">student</span><span class="Punctuation">[</span><span class="Punctuation">]</span></pre>
<p>1. 对象中只有标了 <tt class="docutils literal"><span class="pre">*</span></tt>的字段在其他的模块中才是可以见的。<br/>
2. 与元组相反，不同的对象类型是<em>永不相等</em>。<br/>
3. 对象类型只能在type区域定义，而不能像元组一样在定义变量的时候直接设定。<br/>
4. Nim中对象依旧是值类型。</p>
<p>继承用 <tt class="docutils literal"><span class="pre">object of</span></tt> 语法来表示，当前不支持多重继承。 <br/>
如果一个对象没有适合的根，习惯上可以用 <tt class="docutils literal"><span class="pre">RootObj</span></tt> 来作为根，没有指定根的对象默认是 <tt class="docutils literal"><span class="pre">final</span></tt>。<br/>
<tt class="docutils literal"><span class="pre">inheritable</span></tt> 编译指示用来定义一个可继承的对象且这个对象的根不是从<tt class="docutils literal"><span class="pre">system.RootObj</span></tt>继承来的 (GTK的封装中大量使用了这个方式)</p>

<p>!!!不明白!!!当使用继承时，最好使用Ref对象 with non-ref objects assignments such as <tt class="docutils literal"><span class="pre">let person: Person = Student(id: 123)</span></tt> will truncate subclass fields.</p>

<p><strong>注</strong>: 对于简单代码重用来说，组合通常是比继承来的更好。</p>

<h2><a class="toc-backref" id="object-oriented-programming-mutually-recursive-types" href="#object-oriented-programming-mutually-recursive-types">Mutually recursive types(相互引用类型)</a></h2>
<p>对象、元组和引用之间递归引用的话就可以创造出非常复杂的数据结构，他们是 <em>mutually recursive(互相引用)</em>。<br/>
Nim中这些相互递归引用的申明必须在同一个type定义内。</p>
<p>例：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span> <span class="Comment"># 指向 NodeObj的被追踪的引用</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># 左右子树</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># 包含指向 Sym 的叶子</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># 符号对象 (final) </span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 符号被定义时的行号</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># 符号的名字</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span>      <span class="Comment"># 对应的抽象语法树</span></pre>

<h2><a class="toc-backref" id="object-oriented-programming-type-conversions" href="#object-oriented-programming-type-conversions">Type conversions(类型转换)</a></h2>
<p>Nim区分下面两种转换方式： <span id="type-casts_1">casts转换</span> 和 <span id="type-conversions_1">conversions转换</span>。<br/>
1. Casts转换 使用 <tt class="docutils literal"><span class="pre">cast</span></tt> 操作符，编译器将按照<span class="pre"> 位模式 </span>将一个类型"翻译"为另外一个类型。<br/>
2. conversions转换用一个更优雅的方式进行类型转换：保留抽象的<em>值</em>，而不是按照<em>位模式</em>进行。 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;如果一个conversion转换是不能进行的，那么编译器将显示编译错误或抛出一个异常。</p>
<p>conversions转换语法: <tt class="docutils literal"><span class="pre">destination_type(expression_to_convert)</span></tt> (像一个普通的调用):</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">getID</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Person</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">id</span></pre>
  <p>如果 <tt class="docutils literal"><span class="pre">x</span></tt> 不能转化为一个<tt class="docutils literal"><span class="pre">Student</span></tt>,异常<tt class="docutils literal"><span class="pre">InvalidObjectConversionError</span></tt> 将被抛出。</p>

<h2><a class="toc-backref" id="object-oriented-programming-object-variants" href="#object-oriented-programming-object-variants">Object variants(对象变量)</a></h2>
<p>运用对象继承模式在那些只需要简单的变量类型就太不灵活笨重了。</p>
<p>例如：</p>
<pre><span class="Comment"># 示例: Nim如何构造抽象语法树</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># 不同的节点类型</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># 叶节点值为整数</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># 叶节点值为浮点数</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># 叶节点值为字符串</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># 加</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># 减</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># if语句</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># ``kind`` 字段是分类字段(根据这个字段形成不同类型的value值)</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">PNode</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">1.0</span><span class="Punctuation">)</span>
<span class="Comment"># 下面的语句将抛出 `FieldError` 异常，因为</span>
<span class="Comment"># n.strVal是不存在的，这个时候只存在n.floatVal</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span></pre>

<h2><a class="toc-backref" id="object-oriented-programming-methods" href="#object-oriented-programming-methods">Methods(方法)</a></h2>
<p>在传统的面向对象语言中，过程(也叫<em>方法</em>)是被绑定到一个类中的。这种做法的缺点有：</p>
<ul class="simple"><li>当需要添加一个方法到类中时，程序员需要整个类的控制权或则采用一些"丑陋"的底层方法来解决。</li>
<li>经常性的一个方法应该属于哪里也不是很清楚。如, <tt class="docutils literal"><span class="pre">join</span></tt> 方法应该是一个字符串的方法，还是数组的方法?(其实跟好的逻辑应该这样，join是一个通用算法，绑定就好了)</li>
</ul>
<p>Nim通过不分配方法到类中来避免这些问题。Nim中所有的方法都是multi-methods(多方法)。我们随后将看到,多方法和过程的区别只在于动态绑定。</p>

<h2><a class="toc-backref" id="object-oriented-programming-method-call-syntax" href="#object-oriented-programming-method-call-syntax">Method call syntax(方法调用语法)</a></h2>
<p>调用方法的时候有个语法糖：使用语法 <tt class="docutils literal"><span class="pre">obj.method(args)</span></tt> 效果等同于 <tt class="docutils literal"><span class="pre">method(obj, args)</span></tt>。<br/>
如调用时不需参数，括号也可以省略： <tt class="docutils literal"><span class="pre">obj.len</span></tt> (等同 <tt class="docutils literal"><span class="pre">len(obj)</span></tt>)。</p>
<p>方法调用语法不仅仅适用于对象，它能够适用于任意类型：</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span> <span class="Comment"># 等同于 echo(len(&quot;abc&quot;))</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 等同于 writeln(stdout, &quot;Hallo&quot;)</span></pre><p>(从另一个角度康方法调用语法，这就是一个前面确实的后缀表达法)</p>
<p>因此， &quot;纯面向对象&quot; 代码也是能很容易写出的：</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;Give a list of numbers (separated by spaces): &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Operator">.</span><span class="Identifier">readLine</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Operator">.</span><span class="Identifier">map</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">max</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot; is the maximum!&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="object-oriented-programming-properties" href="#object-oriented-programming-properties">Properties(属性)</a></h2>
<p>如上面的例子所示，Nim 不需要特殊的 <em>get-properties(get属性方法)</em>，用通常的方法调用语法就可以得到了特定的属性了。但是设置一个值不一样，需要一个特别的设置语法了：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">FHost</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 没有加注*，因此此模块外不能访问</span>
               <span class="Comment"># 加上 `F` 前缀，外部访问将通过`host`这个名字来进行</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## 设置器</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## 获得器</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span>

<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">new</span> <span class="Identifier">s</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># 等同于 `host=`(s, 34)</span></pre><p>(例子中也展示了 <tt class="docutils literal"><span class="pre">inline</span></tt> 这个编译指示，希望过程被inline化)</p>
<p>数组的访问操作符 <tt class="docutils literal"><span class="pre">[]</span></tt> 也能被重载用来获取 <span id="array-properties_1">array properties(数组属性)</span>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Vector</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 设置器</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Comment"># 获取器</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span></pre>
  <p>例子是很笨但是说明了这个用法。因为这个向量vector可以直接用元组来实现。元组已经提供了<tt class="docutils literal"><span class="pre">v[]</span></tt> 的访问方法。</p>

<h2><a class="toc-backref" id="object-oriented-programming-dynamic-dispatch" href="#object-oriented-programming-dynamic-dispatch">Dynamic dispatch(动态分发)</a></h2>
<p>过程总是使用静态分发。动态分发用关键字 <tt class="docutils literal"><span class="pre">method</span></tt> 来替换 <tt class="docutils literal"><span class="pre">proc</span></tt>：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">PExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## 表达式的抽象基础类</span>
  <span class="Identifier">PLiteral</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">PExpr</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PPlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">PExpr</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PExpr</span>

<span class="Comment"># 注意: 'eval' 依赖动态绑定</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 请重载这个基础方法</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PLiteral</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PPlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PLiteral</span> <span class="Operator">=</span> <span class="Identifier">PLiteral</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PPlusExpr</span> <span class="Operator">=</span> <span class="Identifier">PPlusExpr</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre>
<p>上面的例子中<tt class="docutils literal"><span class="pre">newLit</span></tt> 和 <tt class="docutils literal"><span class="pre">newPlus</span></tt> 都是过程， 它们用静态绑定更为恰当。<br/>
但是 <tt class="docutils literal"><span class="pre">eval</span></tt> 需要使用动态绑定，所以它就是一个方法</p>
<p>如果一组方法都有参数，在分发的时候，根据第一个参数的适配情况来觉得采用哪个方法：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span> <span class="Comment"># 第1个方法</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;2&quot;</span> <span class="Comment"># 第２个方法</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span>
<span class="Identifier">new</span> <span class="Identifier">a</span>
<span class="Identifier">new</span> <span class="Identifier">b</span>
<span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Comment"># 输出 2</span></pre>
<p>如上面的例子显示的，`collide` 方法组必须要解决选择问题。<br/>
第２个collide方法比第1个更优，因为参数的适配选择是从左到右。即 <tt class="docutils literal"><span class="pre">Unit, Thing</span></tt> 优先于 <tt class="docutils literal"><span class="pre">Thing, Unit</span></tt>。</p>

<p><strong>性能提示：</strong>: Nim 不生成virtual method table(虚拟方法表)但是会生成dispatch trees(分发树) 。这样能够避免动态查找带来的代价，直接进行调用操作了。但同时其他的优化比如编译期评估或无用代码消除都不会进行。</p>

<h1><a class="toc-backref" id="exceptions" href="#exceptions">Exceptions(异常)</a></h1>
<p>Nim中异常是对象。通常异常类型的命名都是以'Error'结尾。 <a class="reference external" href="system.html">system</a> 模块定义了异常的继承体系。<br/>
异常继承于 <tt class="docutils literal"><span class="pre">system.Exception</span></tt>，它提供了通用的一些接口</p>
<p>因为异常的生命周期未知，因此他们都必须在堆上分配。如果你要在堆栈上创建一个异常对象，编译器将会阻止这么作。所有的异常至少应该设置异常的原因到异常对象的 <tt class="docutils literal"><span class="pre">msg</span></tt> 字段。</p>
<p>一个抛出异常的约定，异常应当在特殊的情况下才抛出：例如,如果一个文件不能被打开，那么不应该抛出异常。因为这样的情况是可以预见的(如文件不存在)。</p>

<h2><a class="toc-backref" id="exceptions-raise-statement" href="#exceptions-raise-statement">Raise statement(Raise语句)</a></h2>
<p>用 <tt class="docutils literal"><span class="pre">raise</span></tt> 语句来抛出一个异常：</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">OSError</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
<span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">e</span></pre>

<p>如果 <tt class="docutils literal"><span class="pre">raise</span></tt> 关键字后面没有接着任何表达式，那么上一个异常将被 <em>re-raised(重新抛出)</em>。<br/>
为了避免类似重复，可以用<tt class="docutils literal"><span class="pre">system</span></tt>模块中的模板 <tt class="docutils literal"><span class="pre">newException</span></tt>来减少不必要的重复代码：</p>
<pre><span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="exceptions-try-statement" href="#exceptions-try-statement">Try statement(Try语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">try</span></tt> 语句可以用来处理异常：</p>
<pre><span class="Comment"># 读取一个文本文件的头２行，每行都是一个数字</span>
<span class="Comment"># 将这２个数字相加</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;sum: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;overflow!&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;could not convert string to integer&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;IO error!&quot;</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Unknown exception!&quot;</span>
    <span class="Comment"># 再次抛出这个未知的异常</span>
    <span class="Keyword">raise</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre>
    <p><tt class="docutils literal"><span class="pre">try</span></tt> 后的语句遇到异常后停止，接着相应的 <tt class="docutils literal"><span class="pre">except</span></tt> 部分开始执行。</p>
<p>空的 <tt class="docutils literal"><span class="pre">except</span></tt>部分，只有出现了未被明确列出的异常时才会被执行，类似 <tt class="docutils literal"><span class="pre">if</span></tt>语句中的 <tt class="docutils literal"><span class="pre">else</span></tt></p>

<p>如果还有 <tt class="docutils literal"><span class="pre">finally</span></tt> 部分，它会在最后被执行。(有异常，则在异常捕捉对应的except执行后；无异常则正常完成后)</p>
<p>异常对象会被 <tt class="docutils literal"><span class="pre">except</span></tt>部分 <em>consumed(消耗)</em>。 如果一个异常没有被捕捉，它将沿着调用堆栈依次传播，直到被捕捉。这意味着接下去的不在<tt class="docutils literal"><span class="pre">finally</span></tt>中的语句将不会被执行。</p>

<p>如果需要在<tt class="docutils literal"><span class="pre">except</span></tt>处理中获取确切的异常对象或消息，可以使用<a class="reference external" href="system.html">system</a>模块中的 <a class="reference external" href="system.html#getCurrentException">getCurrentException()</a> 和 <a class="reference external" href="system.html#getCurrentExceptionMsg">getCurrentExceptionMsg()</a> 过程。<br/>
如:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">doSomethingHere</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">except</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span>
    <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Got exception &quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; with message &quot;</span><span class="Punctuation">,</span> <span class="Identifier">msg</span></pre>
<h2><a class="toc-backref" id="exceptions-annotating-procs-with-raised-exceptions" href="#exceptions-annotating-procs-with-raised-exceptions">Annotating procs with raised exceptions(过程的异常抛出指示)</a></h2>
<p>通过增加编译指示 <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> 你能告诉编译器这个过程可能会抛出一个特定的异常集合或根本就不会抛出异常。一旦你用了编译指示<tt class="docutils literal"><span class="pre">{.raises.}</span></tt>，编译器将验证指示的异常是不是真的。<br/>
比如你指示一个过程会抛出异常 <tt class="docutils literal"><span class="pre">IOError</span></tt>，在某个地方 (或则它调用的一个其他过程) 抛出了一个新异常，编译器将会阻止这个编译过程。<br/>
指示的使用例子：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">complexProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">ArithmeticError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">simpleProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span></pre>
  <p>一旦你有这样的代码，如果列出来的异常集合和实际的不匹配了，编译器将停止编译。并告诉你错误说在。Great!</p>

<p>如果你想给现有的代码也加上 <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> 编译指示列出可能的异常，可以给这个过程加上 <tt class="docutils literal"><span class="pre">{.effects.}</span></tt> 编译指示。这样编译器将输出针对这个过程的全部潜在影响。另一个方法是用 Nim <tt class="docutils literal"><span class="pre">doc2</span></tt> 命令。doc2产生整个模块的文档，并且给每个过程标记上了会抛出的异常。更多可见手册中的<a class="reference external" href="manual.html#effect-system">effect system and related pragmas</a></p>

<h1><a class="toc-backref" id="generics" href="#generics">Generics(泛型)</a></h1>
<p>泛型在Nim中意味这参数化的过程、迭代器或类型，他们都有类型作为参数。</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment"># BinaryTree是一个通用的类型</span>
                            <span class="Comment"># 特化参数 ``T``</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>   <span class="Comment"># 左右子树，可为nil</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                 <span class="Comment"># 节点保存的数据</span>
  <span class="Identifier">BinaryTree</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Comment"># 可输出的</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># 构造一个节点</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">data</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 插入节点到树中</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Comment"># 比较data字段，使用通用的 ``cmp`` 过程</span>
      <span class="Comment"># 任何类型只要支持 ``==`` 和 ``&lt;`` 操作符就可以使用这个过程进行比较</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># convenience proc:</span>
  <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">preorder</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># 先序遍历了</span>
  <span class="Comment"># 因为循环迭代子还没有被实现</span>
  <span class="Comment"># 因此这里用了一个显式的堆栈来实现(也更有效率)</span>
  <span class="Keyword">var</span> <span class="Identifier">stack</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">while</span> <span class="Identifier">n</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
      <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">stack</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>  <span class="Comment"># 右子树压入堆栈</span>
      <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">le</span>          <span class="Comment"># 进行左子树</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># 实例化一个特化为 ``string`` 类型的BinaryTree</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">preorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">)</span></pre>
  <p>例子展示了一个通用的二叉树。 中括号用来申明特化的类型或则实例化相应的过程、迭代子或类型。<br/>
  如上所示，泛型也能被重载：最适配的<tt class="docutils literal"><span class="pre">add</span></tt>会被相应调用。<br/>
  <tt class="docutils literal"><span class="pre">preorder</span></tt> 迭代子中的<tt class="docutils literal"><span class="pre">add</span></tt> 过程是序列的内置过程。</p>

<h1><a class="toc-backref" id="templates" href="#templates">Templates(模板)</a></h1>
<p>模板只是一个简单的在Nim的抽象语法树上的替换机制，在编译器的语义处理阶段进行。<br/>模板和Nim语言的其他部分结合的很好，而且避免了C语言预处理宏的缺点。</p>
<p> <em>invoke(调用)</em>模板就和调用过程一样。</p>
<p>如：</p>
<pre><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Comment"># 这个定义在 System 的模板中</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># 编译器重写为：assert(not (5 == 6))</span></pre>
<p> <tt class="docutils literal"><span class="pre">!=</span></tt>、<tt class="docutils literal"><span class="pre">&gt;</span></tt>、<tt class="docutils literal"><span class="pre">&gt;=</span></tt>、<tt class="docutils literal"><span class="pre">in</span></tt>、<tt class="docutils literal"><span class="pre">notin</span></tt>、<tt class="docutils literal"><span class="pre">isnot</span></tt> 操作符其实就是模板。这么作的好处是 如果重载了 <tt class="docutils literal"><span class="pre">==</span></tt> 操作符，那么 <tt class="docutils literal"><span class="pre">!=</span></tt> 操作符也就自动的被转换过来了。 (除了 IEEE 的浮点数 - NaN 打破了基本的布尔逻辑)</p>

<p><tt class="docutils literal"><span class="pre">a &gt; b</span></tt> 转化为 <tt class="docutils literal"><span class="pre">b &lt; a</span></tt>。<tt class="docutils literal"><span class="pre">a in b</span></tt> 转化为 <tt class="docutils literal"><span class="pre">contains(b, a)</span></tt>。 <tt class="docutils literal"><span class="pre">notin</span></tt> 和 <tt class="docutils literal"><span class="pre">isnot</span></tt>就很直白的纸面意思了。</p>
<p>模板对惰性评价非常有用。看看下面这个简单的logging过程：</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>
<span class="Keyword">proc</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<p>这个代码有个缺点：如果某天 <tt class="docutils literal"><span class="pre">debug</span></tt> 设为false假， 这个相当复杂昂贵的 <tt class="docutils literal"><span class="pre">$</span></tt> and <tt class="docutils literal"><span class="pre">&amp;</span></tt> 操作依旧要进行！(过程的参数评估是<em>eager(优先的)</em>)。</p>
<p>将 <tt class="docutils literal"><span class="pre">log</span></tt> 过程变成模板就可以解决这个问题：</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Keyword">template</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<p>模板参数的类型可以是 序数类型 或  meta types(元类型) <tt class="docutils literal"><span class="pre">expr</span></tt> (表示 <em>expression(表达式)</em>)、<tt class="docutils literal"><span class="pre">stmt</span></tt> (表示 <em>statement(语句)</em>) 或 <tt class="docutils literal"><span class="pre">typedesc</span></tt> (表示 <em>type description(类型描述)</em>)。<br/>
如果模板没有明确的返回类型， 默认使用 <tt class="docutils literal"><span class="pre">stmt</span></tt> 作为返回类型，这样和过程、方法一致了。</p>
<p>如果模板中参数有个类型是 <tt class="docutils literal"><span class="pre">stmt</span></tt> ,那么这个参数应该是模板申明中最后一个。原因是这些要传递给模板的语句参数可以用一个特殊的语法 <tt class="docutils literal"><span class="pre">:</span></tt> 来实现：</p>
<pre><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">filename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">FileMode</span><span class="Punctuation">,</span>
                  <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">fn</span> <span class="Operator">=</span> <span class="Identifier">filename</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre>
  <p>例子中 这两个 <tt class="docutils literal"><span class="pre">writeln</span></tt> 语句被绑定为 <tt class="docutils literal"><span class="pre">body</span></tt> 参数。<br/>
  <tt class="docutils literal"><span class="pre">withFile</span></tt> 模板中包含一些样板代码，有助于避免一个常见的Bug：忘记关闭文件。<br/>
 注意： <tt class="docutils literal"><span class="pre">let fn = filename</span></tt> 语句确保 <tt class="docutils literal"><span class="pre">filename</span></tt> 只被评估一次。</p>

<h1><a class="toc-backref" id="macros" href="#macros">Macros(宏)</a></h1>
<p>宏使得高级编译期代码变形成为可能，但是并不改变Nim的语法。实际上没有限制，因为Nim的语法足够的灵活。<br/>
宏必须使用纯的Nim代码实现，因为编译器不能实现<a class="reference external" href="manual.html#foreign-function-interface">foreign function interface (FFI)</a>。除了这个限制(未来可能取消这个限制) 你可以编写任意的Nim代码，编译器将在编译期运行这个宏的对应代码。</p>

<p>宏有两个方法实现<br/>
1. <em>generating(编写)</em> Nim 源代码，然后用编译器分析代码。<br/>
2. 手动创建一个抽象语法树(AST)，提供给编译器。为了创建AST,需要知道Nim如何将具体的语法转换为抽象语法树(AST)。AST 的文档可见 <a class="reference external" href="macros.html">macros</a> 模块。</p>
<p>一旦宏完成了，有两个方法去调用：</p>
<ol class="simple">
<li>类似过程调用一样去调用(expression macros(表达式宏))</li>
<li>用特殊的<tt class="docutils literal"><span class="pre">macrostmt</span></tt> 语法调用 (statement macros(申明宏))</li>
</ol>
<h2><a class="toc-backref" id="macros-expression-macros" href="#macros-expression-macros">Expression Macros(表达式宏)</a></h2>
<p>下面的例子实现了一个强大的 <tt class="docutils literal"><span class="pre">debug</span></tt> 命令。这个命令接受可变数量的参数：</p>
<pre><span class="Comment"># 为了操作Nim的语法数，我们需要个定义在``macros`` 模块里的API：</span>
<span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># `n` 是一个Nim 抽象语法树，包含了一个表达式列表</span>
  <span class="Comment"># 宏返回一个语句列表</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Comment"># iterate over any argument that is passed to this macro:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Comment"># add a call to the statement list that writes the expression;</span>
    <span class="Comment"># `toStrLit` 转换一个抽象语法树为它的字符串形式：</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes &quot;: &quot;</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes the expressions value:</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;writeln&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>宏调用被扩展为：</p>
<pre><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre>

<h2><a class="toc-backref" id="macros-statement-macros" href="#macros-statement-macros">Statement Macros(申明宏)</a></h2>
<p>申明宏和表达式宏一样定义。然而调用方式不一样了，直接的在这个表达式后跟冒号。</p>
<p>下面的例子展示一个 从正则表达式中生成正文分析器的宏：</p>
<pre><span class="Keyword">macro</span> <span class="Identifier">case_token</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># creates a lexical analyzer from regular expressions</span>
  <span class="Comment"># ... (implementation is an exercise for the reader :-)</span>
  <span class="Keyword">discard</span>

<span class="Identifier">case_token</span><span class="Punctuation">:</span> <span class="Comment"># this colon tells the parser it is a macro statement</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[A-Za-z_]+[A-Za-z_0-9]*&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkIdentifier</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;0-9+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkInteger</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[\+\-\*\?]+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkOperator</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkUnknown</span></pre>
<h2><a class="toc-backref" id="macros-building-your-first-macro" href="#macros-building-your-first-macro">Building your first macro(创建你的第一个宏)</a></h2>
<p>为了演示下怎么写个宏，我们将展示如何将一个典型的动态代码转换为静态编译的版本。<br/>
我们从下面的代码开始吧</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">tables</span>

<span class="Keyword">proc</span> <span class="Identifier">readCfgAtRuntime</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">let</span>
    <span class="Identifier">inputString</span> <span class="Operator">=</span> <span class="Identifier">readFile</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span>
    <span class="Identifier">source</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">initTable</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">line</span> <span class="Keyword">in</span> <span class="Identifier">inputString</span><span class="Operator">.</span><span class="Identifier">splitLines</span><span class="Punctuation">:</span>
    <span class="Comment"># Ignore empty lines</span>
    <span class="Keyword">if</span> <span class="Identifier">line</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
    <span class="Keyword">var</span> <span class="Identifier">chunks</span> <span class="Operator">=</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="CharLit">','</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">chunks</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">!=</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
      <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input needs comma split values, got: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">line</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  
  <span class="Keyword">if</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input file empty!&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Identifier">info</span> <span class="Operator">=</span> <span class="Identifier">readCfgAtRuntime</span><span class="Punctuation">(</span><span class="StringLit">&quot;data.cfg&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">info</span><span class="Punctuation">[</span><span class="StringLit">&quot;licenseOwner&quot;</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">info</span><span class="Punctuation">[</span><span class="StringLit">&quot;licenseKey&quot;</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">info</span><span class="Punctuation">[</span><span class="StringLit">&quot;version&quot;</span><span class="Punctuation">]</span></pre>

  <p>假设这段代码在一个商业软件中用来读取配置文件显示购买了这个软件的用户信息。<br/>
  这个外部的文件(data.cfg)可能被一个在线店铺购物车创建好，用来保存许可信息：<pre>
version,1.1
licenseOwner,Hyori Lee
licenseKey,M1Tl3PjBWO2CC48m</pre>
</p>
<p><tt class="docutils literal"><span class="pre">readCfgAtRuntime</span></tt> 过程打开这个文件，返回一个<a class="reference external" href="tables.html">tables模块</a>中的 <tt class="docutils literal"><span class="pre">Table</span></tt> 。<br/>
文件的分析用<a class="reference external" href="strutils.html#splitLines">strutils模块中的splitLines过程</a>进行(就不考虑无效数据或一些旮旯问题了)。有很多可能失败的地方，既然我们至少演示如何使得这个在编译期运行起来，就不考虑这些了。</p>
<p>这段代码我们要改造成一个编译期的过程，这样我们就可以去掉 <tt class="docutils literal"><span class="pre">data.cfg</span></tt> 文件了，只能分发二进制文件就好了(也就是说将特定的用户信息直接嵌入到二进制文件中)</p>
<h3><a class="toc-backref" id="building-your-first-macro-generating-source-code" href="#building-your-first-macro-generating-source-code">Generating source code(产生源代码)</a></h3>

<p>我们先修改程序生成一个编译期的字符串，接着我们将这个字符串传给<a class="reference external" href="macros.html">macros模块</a>中的<tt class="docutils literal"><span class="pre">parseStmt</span></tt>过程，这样就可以得到一个stmt语句。<br/>下面是修改后的源代码：</p>

<table class="line-nums-table"><tbody><tr><td class="blob-line-nums"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span class="Keyword">import</span> <span class="Identifier">macros</span><span class="Punctuation">,</span> <span class="Identifier">strutils</span>

<span class="Keyword">macro</span> <span class="Identifier">readCfgAndBuildSource</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">let</span>
    <span class="Identifier">inputString</span> <span class="Operator">=</span> <span class="Identifier">slurp</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Operator">.</span><span class="Identifier">strVal</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span>
    <span class="Identifier">source</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>
  
  <span class="Keyword">for</span> <span class="Identifier">line</span> <span class="Keyword">in</span> <span class="Identifier">inputString</span><span class="Operator">.</span><span class="Identifier">splitLines</span><span class="Punctuation">:</span>
    <span class="Comment"># Ignore empty lines</span>
    <span class="Keyword">if</span> <span class="Identifier">line</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
    <span class="Keyword">var</span> <span class="Identifier">chunks</span> <span class="Operator">=</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="CharLit">','</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">chunks</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">!=</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input needs comma split values, got: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">line</span><span class="Punctuation">)</span>
    <span class="Identifier">source</span> <span class="Operator">&amp;=</span> <span class="StringLit">&quot;const cfg&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;= </span><span class="EscapeSequence">\&quot;</span><span class="StringLit">&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span>
  
  <span class="Keyword">if</span> <span class="Identifier">source</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input file empty!&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">parseStmt</span><span class="Punctuation">(</span><span class="Identifier">source</span><span class="Punctuation">)</span>

<span class="Identifier">readCfgAndBuildSource</span><span class="Punctuation">(</span><span class="StringLit">&quot;data.cfg&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseOwner</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseKey</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfgversion</span></pre></td></tr></tbody></table>

  <p>好消息是代码不需要改太多！<br/> <tt class="docutils literal"><span class="pre">首先</span></tt>， 我们需要改变输入参数的处理(第３行)。<br/>动态版本中 <tt class="docutils literal"><span class="pre">readCfgAtRuntime</span></tt> 过程接受一个字符串参数。<br/>然而在宏版本中它虽然申明的也是字符串，其实它是宏的 <em>outside(外部)</em> 接口。  当宏运行的时候，这个参数得到的不是字符串其实是 <tt class="docutils literal"><span class="pre">PNimNode</span></tt> 对象，可以通过<a class="reference external" href="macros.html">macros模块</a>中的 <a class="reference external" href="macros.html#strVal">strVal过程</a> (第5行)得到传过来的字符串值。</p>
<p><tt class="docutils literal"><span class="pre">第二</span></tt>，因为编译期FFI的限制，我们不再使用<a class="reference external" href="system.html">system模块</a>中的<a class="reference external" href="system.html#readFile">readFile过程了</a> 。如果我们试图使用这个过程或则其他依赖FFI的过程，编译器将报错并且错误信息为<tt class="docutils literal"><span class="pre">cannot evaluate</span></tt> 同时打印出这个宏的源代码，以及编译器当前的堆栈信息。<br/>我们可以使用<a class="reference external" href="system.html">system模块</a>中的<a class="reference external" href="system.html#slurp">slurp 过程</a>来消除这个限制(这个过程就是为编译期准备的，如同 <a class="reference external" href="system.html#gorge">gorge</a> 执行外部程序并且得到它的输出)。</p>

<p>有趣的事情是我们的宏并不返回一个运行期的 <a class="reference external" href="tables.html#Table">Table</a> 对象，相反它拼接成Nim的源代码放进 <tt class="docutils literal"><span class="pre">source</span></tt> 变量。配置文件中的每行都会生成一个 <tt class="docutils literal"><span class="pre">const</span></tt> 变量(第15行)。为了避免冲突，我们给变量加上 <tt class="docutils literal"><span class="pre">cfg</span></tt> 前缀。<br/>本质上，编译器运行这个宏时就是将相应的行替换成如下的代码：</p>
<pre><span class="Keyword">const</span> <span class="Identifier">cfgversion</span><span class="Operator">=</span> <span class="StringLit">&quot;1.1&quot;</span>
<span class="Keyword">const</span> <span class="Identifier">cfglicenseOwner</span><span class="Operator">=</span> <span class="StringLit">&quot;Hyori Lee&quot;</span>
<span class="Keyword">const</span> <span class="Identifier">cfglicenseKey</span><span class="Operator">=</span> <span class="StringLit">&quot;M1Tl3PjBWO2CC48m&quot;</span></pre>
<p>你可以这么验证下，在宏的后面加上此行 <tt class="docutils literal"><span class="pre">echo source</span></tt> 并且编译。 <br/>
另外一个不同是前版本中用来退出的 <a class="reference external" href="system.html#quit">quit过程</a> ，这个版本将用 <a class="reference external" href="macros.html#error">error过程</a> (第14行)来替换。<tt class="docutils literal"><span class="pre">error</span></tt> 过程与 <tt class="docutils literal"><span class="pre">quit</span></tt> 的作用相同但是error还打印出错误时的源代码和错误说在的行信息，这样我们更容易发现错误的地方了。<br/> 上面例子中，错误指向的是调用宏的行号，不是我们在处理的 <tt class="docutils literal"><span class="pre">data.cfg</span></tt> 文件中的错误行号，这个是宏自身需要控制的。</p>

<h3><a class="toc-backref" id="building-your-first-macro-generating-ast-by-hand" href="#building-your-first-macro-generating-ast-by-hand">Generating AST by hand(手工生成AST)</a></h3>
<p>为了生成AST，我们必须非常熟悉<a class="reference external" href="macros.html">macros模块</a>中的那些提供给Nim编译器使用的数据结构，乍看上去要熟悉这件事情令人生畏。<br/>
但是我们可以用使用作为辅助快捷的<a class="reference external" href="macros.html#dumpTree">dumpTree宏</a>, 它是一个申明宏并不是表达式宏。 既然我们知道我们想产生一串 <tt class="docutils literal"><span class="pre">const</span></tt> 符号，那么我们可以创建如下的一个源代码并且编译它。这样我们可以就知道编译器期望从我们这得到什么(这样把这些期望的嵌入到静态编译二进制中就好了)：</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Identifier">dumpTree</span><span class="Punctuation">:</span>
  <span class="Keyword">const</span> <span class="Identifier">cfgversion</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;1.1&quot;</span>
  <span class="Keyword">const</span> <span class="Identifier">cfglicenseOwner</span><span class="Operator">=</span> <span class="StringLit">&quot;Hyori Lee&quot;</span>
  <span class="Keyword">const</span> <span class="Identifier">cfglicenseKey</span><span class="Operator">=</span> <span class="StringLit">&quot;M1Tl3PjBWO2CC48m&quot;</span></pre>
  <p>编译这个代码时，我们就能看到如下的输出(在提醒一次,　因为这是一个宏，编译就够了，不需要运行编译后的二进制程序。运行也是啥都不输出的):<pre>
StmtList
  ConstSection
    ConstDef
      Ident !&quot;cfgversion&quot;
      Ident !&quot;string&quot;
      StrLit 1.1
  ConstSection
    ConstDef
      Ident !&quot;cfglicenseOwner&quot;
      Empty
      StrLit Hyori Lee
  ConstSection
    ConstDef
      Ident !&quot;cfglicenseKey&quot;
      Empty
      StrLit M1Tl3PjBWO2CC48m</pre>
</p>
<p>有这个输出，我们更了解编译器想要啥了。我们需要创建一个申明列表。每个const代码生成了一个 <tt class="docutils literal"><span class="pre">ConstSection</span></tt> 和一个 <tt class="docutils literal"><span class="pre">ConstDef</span></tt>。如果我们将全部的const都合并到同一个 <tt class="docutils literal"><span class="pre">const</span></tt> 块中，我们就能看到只需要一个 <tt class="docutils literal"><span class="pre">ConstSection</span></tt> 和三个子(也就是ConstDef)。</p>
<p>可能你没有注意，在 <tt class="docutils literal"><span class="pre">dumpTree</span></tt> 例子中，第一个常量申明中清楚的指明了这个常量的类型。这也就是为什么后面两个申明中的第二行都是 <tt class="docutils literal"><span class="pre">Empty</span></tt> ，但是第一个申明对应的是字符串标识(Ident !"string")。<br/>
所以简单来说，一个 <tt class="docutils literal"><span class="pre">const</span></tt> 定义由一个标识符、可选的类型(可能是<em>empty</em>) 和值 这三部分组成。 <br/>
有了这些知识，让我们回过头看看最终版本的AST建立宏：</p>
<table class="line-nums-table"><tbody><tr><td class="blob-line-nums"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td><pre><span class="Keyword">import</span> <span class="Identifier">macros</span><span class="Punctuation">,</span> <span class="Identifier">strutils</span>

<span class="Keyword">macro</span> <span class="Identifier">readCfgAndBuildAST</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">let</span>
    <span class="Identifier">inputString</span> <span class="Operator">=</span> <span class="Identifier">slurp</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Operator">.</span><span class="Identifier">strVal</span><span class="Punctuation">)</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">line</span> <span class="Keyword">in</span> <span class="Identifier">inputString</span><span class="Operator">.</span><span class="Identifier">splitLines</span><span class="Punctuation">:</span>
    <span class="Comment"># Ignore empty lines</span>
    <span class="Keyword">if</span> <span class="Identifier">line</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
    <span class="Keyword">var</span> <span class="Identifier">chunks</span> <span class="Operator">=</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="CharLit">','</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">chunks</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">!=</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input needs comma split values, got: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">line</span><span class="Punctuation">)</span>
    <span class="Keyword">var</span>
      <span class="Identifier">section</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkConstSection</span><span class="Punctuation">)</span>
      <span class="Identifier">constDef</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkConstDef</span><span class="Punctuation">)</span>
    <span class="Identifier">constDef</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;cfg&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">constDef</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newEmptyNode</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">constDef</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">section</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">constDef</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">section</span><span class="Punctuation">)</span>
  
  <span class="Keyword">if</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input file empty!&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">readCfgAndBuildAST</span><span class="Punctuation">(</span><span class="StringLit">&quot;data.cfg&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseOwner</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseKey</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfgversion</span></pre></td></tr></tbody></table>
  <p>让我们看看现在的版本和前面直接产生源代码的版本有什么不同。<br/>
  不再创建一个临时的 <tt class="docutils literal"><span class="pre">字符串</span></tt> 变量source用来保存<em>手工拼凑</em>的源代码，而是直接的使用 <tt class="docutils literal"><span class="pre">result</span></tt> 变量，并且创建好申明列表节点 (<tt class="docutils literal"><span class="pre">nnkStmtList</span></tt>) 来容纳接下去的nnkConstSection节点(第７行)。</p>

<p>配置文件中的每一行我们对相应的创建了一个常量定义 (<tt class="docutils literal"><span class="pre">nnkConstDef</span></tt>) 并且都放到了一个常量区域中 (<tt class="docutils literal"><span class="pre">nnkConstSection</span></tt>)。一旦这些变量创建好了，我们将按照他们的层次关系填充(第17行)，和前面AST打印出的层次一样：常量定义是区域定义的子，常量定义有一个标识符节点，一个空节点(我们让编译器自己去识别这个类型) 和一个字符串值。</p>

<p>写宏时的一个提示：<br/>
如果你不确定你写的对应的AST是咋样， 你可以尝试用 <tt class="docutils literal"><span class="pre">dumpTree</span></tt> 宏，但是你不能在你写的宏里面使用或调试它。<br/>
<a class="reference external" href="macros.html#treeRepr">treeRepr</a> 类似 <tt class="docutils literal"><span class="pre">dumpTree</span></tt> 的功用，返回dump出的语句的AST。<br/>
因此如果在这个例子最后加上 <tt class="docutils literal"><span class="pre">echo treeRepr(result)</span></tt> ，你将得到和 <tt class="docutils literal"><span class="pre">dumpTree</span></tt> 宏一样的输出结果，当然你也能在任何地方用这个宏。 </p>
  </div>
</div>
    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-05-04 19:40:46 UTC</small>
        <small> <a href="http://d-l.github.io" target="_blank">D-L</a>译于2015-08-09 21:12:31</small>
      </div>
    </div>
  </div>
</div>
</body>
</html>
