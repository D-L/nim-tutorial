<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- Favicon -->
<link rel="shortcut icon" href="./nim.ico" />
<link href="./tut.css" rel="stylesheet">
<!-- CSS -->
<title>Nim Manual(Nim手册)</title>
</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim Manual</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="about-this-document_toc" href="#about-this-document">About this document(关于此文档)</a></li>
<li><a class="reference" id="definitions_toc" href="#definitions">Definitions(定义)</a></li>
<li><a class="reference" id="lexical-analysis_toc" href="#lexical-analysis">Lexical Analysis(词法分析)</a></li>
<ul class="simple"><li><a class="reference" id="lexical-analysis-encoding_toc" href="#lexical-analysis-encoding">Encoding(编码)</a></li>
<li><a class="reference" id="lexical-analysis-indentation_toc" href="#lexical-analysis-indentation">Indentation(缩进)</a></li>
<li><a class="reference" id="lexical-analysis-comments_toc" href="#lexical-analysis-comments">Comments(注释)</a></li>
<li><a class="reference" id="lexical-analysis-identifiers-keywords_toc" href="#lexical-analysis-identifiers-keywords">Identifiers &amp; Keywords(标识符和关键字)</a></li>
<li><a class="reference" id="lexical-analysis-identifier-equality_toc" href="#lexical-analysis-identifier-equality">Identifier equality(标识符相等判断)</a></li>
<li><a class="reference" id="lexical-analysis-string-literals_toc" href="#lexical-analysis-string-literals">String literals(字符串文本)</a></li>
<li><a class="reference" id="lexical-analysis-triple-quoted-string-literals_toc" href="#lexical-analysis-triple-quoted-string-literals">Triple quoted string literals</a></li>
<li><a class="reference" id="lexical-analysis-raw-string-literals_toc" href="#lexical-analysis-raw-string-literals">Raw string literals</a></li>
<li><a class="reference" id="lexical-analysis-generalized-raw-string-literals_toc" href="#lexical-analysis-generalized-raw-string-literals">Generalized raw string literals</a></li>
<li><a class="reference" id="lexical-analysis-character-literals_toc" href="#lexical-analysis-character-literals">Character literals</a></li>
<li><a class="reference" id="lexical-analysis-numerical-constants_toc" href="#lexical-analysis-numerical-constants">Numerical constants</a></li>
<li><a class="reference" id="lexical-analysis-operators_toc" href="#lexical-analysis-operators">Operators</a></li>
<li><a class="reference" id="lexical-analysis-other-tokens_toc" href="#lexical-analysis-other-tokens">Other tokens</a></li>
</ul><li><a class="reference" id="syntax_toc" href="#syntax">Syntax</a></li>
<ul class="simple"><li><a class="reference" id="syntax-associativity_toc" href="#syntax-associativity">Associativity</a></li>
<li><a class="reference" id="syntax-precedence_toc" href="#syntax-precedence">Precedence</a></li>
<li><a class="reference" id="syntax-strong-spaces_toc" href="#syntax-strong-spaces">Strong spaces</a></li>
<li><a class="reference" id="syntax-grammar_toc" href="#syntax-grammar">Grammar</a></li>
</ul><li><a class="reference" id="types_toc" href="#types">Types</a></li>
<ul class="simple"><li><a class="reference" id="types-ordinal-types_toc" href="#types-ordinal-types">Ordinal types</a></li>
<li><a class="reference" id="types-pre-defined-integer-types_toc" href="#types-pre-defined-integer-types">Pre-defined integer types</a></li>
<li><a class="reference" id="types-subrange-types_toc" href="#types-subrange-types">Subrange types</a></li>
<li><a class="reference" id="types-pre-defined-floating-point-types_toc" href="#types-pre-defined-floating-point-types">Pre-defined floating point types</a></li>
<li><a class="reference" id="types-boolean-type_toc" href="#types-boolean-type">Boolean type</a></li>
<li><a class="reference" id="types-character-type_toc" href="#types-character-type">Character type</a></li>
<li><a class="reference" id="types-enumeration-types_toc" href="#types-enumeration-types">Enumeration types</a></li>
<li><a class="reference" id="types-string-type_toc" href="#types-string-type">String type</a></li>
<li><a class="reference" id="types-cstring-type_toc" href="#types-cstring-type">cstring type</a></li>
<li><a class="reference" id="types-structured-types_toc" href="#types-structured-types">Structured types</a></li>
<li><a class="reference" id="types-array-and-sequence-types_toc" href="#types-array-and-sequence-types">Array and sequence types</a></li>
<li><a class="reference" id="types-open-arrays_toc" href="#types-open-arrays">Open arrays</a></li>
<li><a class="reference" id="types-varargs_toc" href="#types-varargs">Varargs</a></li>
<li><a class="reference" id="types-tuples-and-object-types_toc" href="#types-tuples-and-object-types">Tuples and object types</a></li>
<li><a class="reference" id="types-object-construction_toc" href="#types-object-construction">Object construction</a></li>
<li><a class="reference" id="types-object-variants_toc" href="#types-object-variants">Object variants</a></li>
<li><a class="reference" id="types-set-type_toc" href="#types-set-type">Set type</a></li>
<li><a class="reference" id="types-reference-and-pointer-types_toc" href="#types-reference-and-pointer-types">Reference and pointer types</a></li>
<li><a class="reference" id="types-not-nil-annotation_toc" href="#types-not-nil-annotation">Not nil annotation</a></li>
<li><a class="reference" id="types-memory-regions_toc" href="#types-memory-regions">Memory regions</a></li>
<li><a class="reference" id="types-procedural-type_toc" href="#types-procedural-type">Procedural type</a></li>
<li><a class="reference" id="types-distinct-type_toc" href="#types-distinct-type">Distinct type</a></li>
<ul class="simple"><li><a class="reference" id="distinct-type-modelling-currencies_toc" href="#distinct-type-modelling-currencies">Modelling currencies</a></li>
<li><a class="reference" id="distinct-type-avoiding-sql-injection-attacks_toc" href="#distinct-type-avoiding-sql-injection-attacks">Avoiding SQL injection attacks</a></li>
</ul><li><a class="reference" id="types-void-type_toc" href="#types-void-type">Void type</a></li>
</ul><li><a class="reference" id="type-relations_toc" href="#type-relations">Type relations</a></li>
<ul class="simple"><li><a class="reference" id="type-relations-type-equality_toc" href="#type-relations-type-equality">Type equality</a></li>
<li><a class="reference" id="type-relations-type-equality-modulo-type-distinction_toc" href="#type-relations-type-equality-modulo-type-distinction">Type equality modulo type distinction</a></li>
<li><a class="reference" id="type-relations-subtype-relation_toc" href="#type-relations-subtype-relation">Subtype relation</a></li>
<li><a class="reference" id="type-relations-convertible-relation_toc" href="#type-relations-convertible-relation">Convertible relation</a></li>
<li><a class="reference" id="type-relations-assignment-compatibility_toc" href="#type-relations-assignment-compatibility">Assignment compatibility</a></li>
</ul><li><a class="reference" id="overloading-resolution_toc" href="#overloading-resolution">Overloading resolution</a></li>
<ul class="simple"><li><a class="reference" id="overloading-resolution-overloading-based-on-var-t_toc" href="#overloading-resolution-overloading-based-on-var-t">Overloading based on 'var T'</a></li>
<li><a class="reference" id="overloading-resolution-automatic-dereferencing_toc" href="#overloading-resolution-automatic-dereferencing">Automatic dereferencing</a></li>
<li><a class="reference" id="overloading-resolution-lazy-type-resolution-for-expr_toc" href="#overloading-resolution-lazy-type-resolution-for-expr">Lazy type resolution for expr</a></li>
<li><a class="reference" id="overloading-resolution-varargs-matching_toc" href="#overloading-resolution-varargs-matching">Varargs matching</a></li>
</ul><li><a class="reference" id="statements-and-expressions_toc" href="#statements-and-expressions">Statements and expressions</a></li>
<ul class="simple"><li><a class="reference" id="statements-and-expressions-statement-list-expression_toc" href="#statements-and-expressions-statement-list-expression">Statement list expression</a></li>
<li><a class="reference" id="statements-and-expressions-discard-statement_toc" href="#statements-and-expressions-discard-statement">Discard statement</a></li>
<li><a class="reference" id="statements-and-expressions-var-statement_toc" href="#statements-and-expressions-var-statement">Var statement</a></li>
<li><a class="reference" id="statements-and-expressions-let-statement_toc" href="#statements-and-expressions-let-statement">let statement</a></li>
<li><a class="reference" id="statements-and-expressions-tuple-unpacking_toc" href="#statements-and-expressions-tuple-unpacking">Tuple unpacking</a></li>
<li><a class="reference" id="statements-and-expressions-const-section_toc" href="#statements-and-expressions-const-section">Const section</a></li>
<li><a class="reference" id="statements-and-expressions-static-statement-expression_toc" href="#statements-and-expressions-static-statement-expression">Static statement/expression</a></li>
<li><a class="reference" id="statements-and-expressions-if-statement_toc" href="#statements-and-expressions-if-statement">If statement</a></li>
<li><a class="reference" id="statements-and-expressions-case-statement_toc" href="#statements-and-expressions-case-statement">Case statement(Case语句)</a></li>
<li><a class="reference" id="statements-and-expressions-when-statement_toc" href="#statements-and-expressions-when-statement">When statement</a></li>
<li><a class="reference" id="statements-and-expressions-return-statement_toc" href="#statements-and-expressions-return-statement">Return statement</a></li>
<li><a class="reference" id="statements-and-expressions-yield-statement_toc" href="#statements-and-expressions-yield-statement">Yield statement</a></li>
<li><a class="reference" id="statements-and-expressions-block-statement_toc" href="#statements-and-expressions-block-statement">Block statement</a></li>
<li><a class="reference" id="statements-and-expressions-break-statement_toc" href="#statements-and-expressions-break-statement">Break statement</a></li>
<li><a class="reference" id="statements-and-expressions-while-statement_toc" href="#statements-and-expressions-while-statement">While statement</a></li>
<li><a class="reference" id="statements-and-expressions-continue-statement_toc" href="#statements-and-expressions-continue-statement">Continue statement</a></li>
<li><a class="reference" id="statements-and-expressions-assembler-statement_toc" href="#statements-and-expressions-assembler-statement">Assembler statement</a></li>
<li><a class="reference" id="statements-and-expressions-using-statement_toc" href="#statements-and-expressions-using-statement">Using statement</a></li>
<li><a class="reference" id="statements-and-expressions-if-expression_toc" href="#statements-and-expressions-if-expression">If expression</a></li>
<li><a class="reference" id="statements-and-expressions-when-expression_toc" href="#statements-and-expressions-when-expression">When expression</a></li>
<li><a class="reference" id="statements-and-expressions-case-expression_toc" href="#statements-and-expressions-case-expression">Case expression</a></li>
<li><a class="reference" id="statements-and-expressions-table-constructor_toc" href="#statements-and-expressions-table-constructor">Table constructor</a></li>
<li><a class="reference" id="statements-and-expressions-type-conversions_toc" href="#statements-and-expressions-type-conversions">Type conversions</a></li>
<li><a class="reference" id="statements-and-expressions-type-casts_toc" href="#statements-and-expressions-type-casts">Type casts</a></li>
<li><a class="reference" id="statements-and-expressions-the-addr-operator_toc" href="#statements-and-expressions-the-addr-operator">The addr operator</a></li>
</ul><li><a class="reference" id="procedures_toc" href="#procedures">Procedures</a></li>
<ul class="simple"><li><a class="reference" id="procedures-export-marker_toc" href="#procedures-export-marker">Export marker</a></li>
<li><a class="reference" id="procedures-method-call-syntax_toc" href="#procedures-method-call-syntax">Method call syntax</a></li>
<li><a class="reference" id="procedures-properties_toc" href="#procedures-properties">Properties</a></li>
<li><a class="reference" id="procedures-command-invocation-syntax_toc" href="#procedures-command-invocation-syntax">Command invocation syntax</a></li>
<li><a class="reference" id="procedures-closures_toc" href="#procedures-closures">Closures</a></li>
<li><a class="reference" id="procedures-anonymous-procs_toc" href="#procedures-anonymous-procs">Anonymous Procs</a></li>
<li><a class="reference" id="procedures-do-notation_toc" href="#procedures-do-notation">Do notation</a></li>
<li><a class="reference" id="procedures-nonoverloadable-builtins_toc" href="#procedures-nonoverloadable-builtins">Nonoverloadable builtins</a></li>
<li><a class="reference" id="procedures-var-parameters_toc" href="#procedures-var-parameters">Var parameters</a></li>
<li><a class="reference" id="procedures-var-return-type_toc" href="#procedures-var-return-type">Var return type</a></li>
<li><a class="reference" id="procedures-overloading-of-the-subscript-operator_toc" href="#procedures-overloading-of-the-subscript-operator">Overloading of the subscript operator</a></li>
</ul><li><a class="reference" id="multi-methods_toc" href="#multi-methods">Multi-methods</a></li>
<li><a class="reference" id="iterators-and-the-for-statement_toc" href="#iterators-and-the-for-statement">Iterators and the for statement</a></li>
<ul class="simple"><li><a class="reference" id="iterators-and-the-for-statement-implict-items-pairs-invocations_toc" href="#iterators-and-the-for-statement-implict-items-pairs-invocations">Implict items/pairs invocations</a></li>
<li><a class="reference" id="iterators-and-the-for-statement-first-class-iterators_toc" href="#iterators-and-the-for-statement-first-class-iterators">First class iterators</a></li>
</ul><li><a class="reference" id="converters_toc" href="#converters">Converters</a></li>
<li><a class="reference" id="type-sections_toc" href="#type-sections">Type sections</a></li>
<li><a class="reference" id="exception-handling_toc" href="#exception-handling">Exception handling</a></li>
<ul class="simple"><li><a class="reference" id="exception-handling-try-statement_toc" href="#exception-handling-try-statement">Try statement</a></li>
<li><a class="reference" id="exception-handling-try-expression_toc" href="#exception-handling-try-expression">Try expression</a></li>
<li><a class="reference" id="exception-handling-except-clauses_toc" href="#exception-handling-except-clauses">Except clauses</a></li>
<li><a class="reference" id="exception-handling-defer-statement_toc" href="#exception-handling-defer-statement">Defer statement</a></li>
<li><a class="reference" id="exception-handling-raise-statement_toc" href="#exception-handling-raise-statement">Raise statement</a></li>
<li><a class="reference" id="exception-handling-exception-hierarchy_toc" href="#exception-handling-exception-hierarchy">Exception hierarchy</a></li>
</ul><li><a class="reference" id="effect-system_toc" href="#effect-system">Effect system</a></li>
<ul class="simple"><li><a class="reference" id="effect-system-exception-tracking_toc" href="#effect-system-exception-tracking">Exception tracking</a></li>
<li><a class="reference" id="effect-system-tag-tracking_toc" href="#effect-system-tag-tracking">Tag tracking</a></li>
<li><a class="reference" id="effect-system-read-write-tracking_toc" href="#effect-system-read-write-tracking">Read/Write tracking</a></li>
<li><a class="reference" id="effect-system-effects-pragma_toc" href="#effect-system-effects-pragma">Effects pragma</a></li>
</ul><li><a class="reference" id="generics_toc" href="#generics">Generics</a></li>
<ul class="simple"><li><a class="reference" id="generics-is-operator_toc" href="#generics-is-operator">Is operator</a></li>
<li><a class="reference" id="generics-type-operator_toc" href="#generics-type-operator">Type operator</a></li>
<li><a class="reference" id="generics-type-classes_toc" href="#generics-type-classes">Type Classes</a></li>
<li><a class="reference" id="generics-concepts_toc" href="#generics-concepts">Concepts</a></li>
<li><a class="reference" id="generics-symbol-lookup-in-generics_toc" href="#generics-symbol-lookup-in-generics">Symbol lookup in generics</a></li>
<li><a class="reference" id="generics-bind-statement_toc" href="#generics-bind-statement">Bind statement</a></li>
</ul><li><a class="reference" id="templates_toc" href="#templates">Templates</a></li>
<ul class="simple"><li><a class="reference" id="templates-ordinary-vs-immediate-templates_toc" href="#templates-ordinary-vs-immediate-templates">Ordinary vs immediate templates</a></li>
<li><a class="reference" id="templates-passing-a-code-block-to-a-template_toc" href="#templates-passing-a-code-block-to-a-template">Passing a code block to a template</a></li>
<li><a class="reference" id="templates-symbol-binding-in-templates_toc" href="#templates-symbol-binding-in-templates">Symbol binding in templates</a></li>
<li><a class="reference" id="templates-identifier-construction_toc" href="#templates-identifier-construction">Identifier construction</a></li>
<li><a class="reference" id="templates-lookup-rules-for-template-parameters_toc" href="#templates-lookup-rules-for-template-parameters">Lookup rules for template parameters</a></li>
<li><a class="reference" id="templates-hygiene-in-templates_toc" href="#templates-hygiene-in-templates">Hygiene in templates</a></li>
<li><a class="reference" id="templates-limitations-of-the-method-call-syntax_toc" href="#templates-limitations-of-the-method-call-syntax">Limitations of the method call syntax</a></li>
</ul><li><a class="reference" id="macros_toc" href="#macros">Macros</a></li>
<ul class="simple"><li><a class="reference" id="macros-expression-macros_toc" href="#macros-expression-macros">Expression Macros</a></li>
<li><a class="reference" id="macros-bindsym_toc" href="#macros-bindsym">BindSym</a></li>
<li><a class="reference" id="macros-statement-macros_toc" href="#macros-statement-macros">Statement Macros</a></li>
<li><a class="reference" id="macros-macros-as-pragmas_toc" href="#macros-macros-as-pragmas">Macros as pragmas</a></li>
</ul><li><a class="reference" id="special-types_toc" href="#special-types">Special Types</a></li>
<ul class="simple"><li><a class="reference" id="special-types-static-t_toc" href="#special-types-static-t">static[T]</a></li>
<li><a class="reference" id="special-types-typedesc_toc" href="#special-types-typedesc">typedesc</a></li>
</ul><li><a class="reference" id="special-operators_toc" href="#special-operators">Special Operators</a></li>
<ul class="simple"><li><a class="reference" id="special-operators-dot-operators_toc" href="#special-operators-dot-operators">dot operators</a></li>
<li><a class="reference" id="special-operators-operator_toc" href="#special-operators-operator">operator <cite>.</cite></a></li>
<li><a class="reference" id="special-operators-operator_toc" href="#special-operators-operator">operator <cite>.()</cite></a></li>
<li><a class="reference" id="special-operators-operator_toc" href="#special-operators-operator">operator <cite>.=</cite></a></li>
</ul><li><a class="reference" id="type-bound-operations_toc" href="#type-bound-operations">Type bound operations</a></li>
<ul class="simple"><li><a class="reference" id="type-bound-operations-operator_toc" href="#type-bound-operations-operator">operator <cite>=</cite></a></li>
<li><a class="reference" id="type-bound-operations-destructors_toc" href="#type-bound-operations-destructors">destructors</a></li>
<li><a class="reference" id="type-bound-operations-deepcopy_toc" href="#type-bound-operations-deepcopy">deepCopy(深度拷贝)</a></li>
</ul><li><a class="reference" id="term-rewriting-macros_toc" href="#term-rewriting-macros">Term rewriting macros</a></li>
<ul class="simple"><li><a class="reference" id="term-rewriting-macros-parameter-constraints_toc" href="#term-rewriting-macros-parameter-constraints">Parameter constraints</a></li>
<li><a class="reference" id="term-rewriting-macros-pattern-operators_toc" href="#term-rewriting-macros-pattern-operators">Pattern operators</a></li>
<ul class="simple"><li><a class="reference" id="pattern-operators-the-operator_toc" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">|</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-operator_toc" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">{}</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-operator_toc" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">~</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-operator_toc" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">*</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-operator_toc" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">**</span></tt> operator</a></li>
</ul><li><a class="reference" id="term-rewriting-macros-parameters_toc" href="#term-rewriting-macros-parameters">Parameters</a></li>
<li><a class="reference" id="term-rewriting-macros-example-partial-evaluation_toc" href="#term-rewriting-macros-example-partial-evaluation">Example: Partial evaluation</a></li>
<li><a class="reference" id="term-rewriting-macros-example-hoisting_toc" href="#term-rewriting-macros-example-hoisting">Example: Hoisting</a></li>
</ul><li><a class="reference" id="ast-based-overloading_toc" href="#ast-based-overloading">AST based overloading</a></li>
<ul class="simple"><li><a class="reference" id="ast-based-overloading-move-optimization_toc" href="#ast-based-overloading-move-optimization">Move optimization</a></li>
</ul><li><a class="reference" id="modules_toc" href="#modules">Modules</a></li>
<ul class="simple"><li><a class="reference" id="modules-import-statement_toc" href="#modules-import-statement">Import statement</a></li>
<li><a class="reference" id="modules-include-statement_toc" href="#modules-include-statement">Include statement</a></li>
<li><a class="reference" id="modules-module-names-in-imports_toc" href="#modules-module-names-in-imports">Module names in imports</a></li>
<li><a class="reference" id="modules-from-import-statement_toc" href="#modules-from-import-statement">From import statement</a></li>
<li><a class="reference" id="modules-export-statement_toc" href="#modules-export-statement">Export statement</a></li>
</ul><ul class="simple"><li><a class="reference" id="modules-scope-rules_toc" href="#modules-scope-rules">Scope rules</a></li>
<ul class="simple"><li><a class="reference" id="scope-rules-block-scope_toc" href="#scope-rules-block-scope">Block scope</a></li>
<li><a class="reference" id="scope-rules-tuple-or-object-scope_toc" href="#scope-rules-tuple-or-object-scope">Tuple or object scope</a></li>
<li><a class="reference" id="scope-rules-module-scope_toc" href="#scope-rules-module-scope">Module scope</a></li>
</ul></ul><li><a class="reference" id="compiler-messages_toc" href="#compiler-messages">Compiler Messages</a></li>
<li><a class="reference" id="pragmas_toc" href="#pragmas">Pragmas</a></li>
<ul class="simple"><li><a class="reference" id="pragmas-deprecated-pragma_toc" href="#pragmas-deprecated-pragma">deprecated pragma</a></li>
<li><a class="reference" id="pragmas-nosideeffect-pragma_toc" href="#pragmas-nosideeffect-pragma">noSideEffect pragma</a></li>
<li><a class="reference" id="pragmas-destructor-pragma_toc" href="#pragmas-destructor-pragma">destructor pragma</a></li>
<li><a class="reference" id="pragmas-override-pragma_toc" href="#pragmas-override-pragma">override pragma</a></li>
<li><a class="reference" id="pragmas-procvar-pragma_toc" href="#pragmas-procvar-pragma">procvar pragma</a></li>
<li><a class="reference" id="pragmas-compiletime-pragma_toc" href="#pragmas-compiletime-pragma">compileTime pragma</a></li>
<li><a class="reference" id="pragmas-noreturn-pragma_toc" href="#pragmas-noreturn-pragma">noReturn pragma</a></li>
<li><a class="reference" id="pragmas-acyclic-pragma_toc" href="#pragmas-acyclic-pragma">acyclic pragma</a></li>
<li><a class="reference" id="pragmas-final-pragma_toc" href="#pragmas-final-pragma">final pragma</a></li>
<li><a class="reference" id="pragmas-shallow-pragma_toc" href="#pragmas-shallow-pragma">shallow pragma</a></li>
<li><a class="reference" id="pragmas-pure-pragma_toc" href="#pragmas-pure-pragma">pure pragma</a></li>
<li><a class="reference" id="pragmas-asmnostackframe-pragma_toc" href="#pragmas-asmnostackframe-pragma">asmNoStackFrame pragma</a></li>
<li><a class="reference" id="pragmas-error-pragma_toc" href="#pragmas-error-pragma">error pragma</a></li>
<li><a class="reference" id="pragmas-fatal-pragma_toc" href="#pragmas-fatal-pragma">fatal pragma</a></li>
<li><a class="reference" id="pragmas-warning-pragma_toc" href="#pragmas-warning-pragma">warning pragma</a></li>
<li><a class="reference" id="pragmas-hint-pragma_toc" href="#pragmas-hint-pragma">hint pragma</a></li>
<li><a class="reference" id="pragmas-line-pragma_toc" href="#pragmas-line-pragma">line pragma</a></li>
<li><a class="reference" id="pragmas-linearscanend-pragma_toc" href="#pragmas-linearscanend-pragma">linearScanEnd pragma</a></li>
<li><a class="reference" id="pragmas-computedgoto-pragma_toc" href="#pragmas-computedgoto-pragma">computedGoto pragma</a></li>
<li><a class="reference" id="pragmas-unroll-pragma_toc" href="#pragmas-unroll-pragma">unroll pragma</a></li>
<li><a class="reference" id="pragmas-immediate-pragma_toc" href="#pragmas-immediate-pragma">immediate pragma</a></li>
<li><a class="reference" id="pragmas-compilation-option-pragmas_toc" href="#pragmas-compilation-option-pragmas">compilation option pragmas</a></li>
<li><a class="reference" id="pragmas-push-and-pop-pragmas_toc" href="#pragmas-push-and-pop-pragmas">push and pop pragmas</a></li>
<li><a class="reference" id="pragmas-register-pragma_toc" href="#pragmas-register-pragma">register pragma</a></li>
<li><a class="reference" id="pragmas-global-pragma_toc" href="#pragmas-global-pragma">global pragma</a></li>
<li><a class="reference" id="pragmas-deadcodeelim-pragma_toc" href="#pragmas-deadcodeelim-pragma">deadCodeElim pragma</a></li>
<li><a class="reference" id="pragmas-pragma-pragma_toc" href="#pragmas-pragma-pragma">pragma pragma</a></li>
<li><a class="reference" id="pragmas-disabling-certain-messages_toc" href="#pragmas-disabling-certain-messages">Disabling certain messages</a></li>
<li><a class="reference" id="pragmas-experimental-pragma_toc" href="#pragmas-experimental-pragma">experimental pragma</a></li>
</ul><li><a class="reference" id="foreign-function-interface_toc" href="#foreign-function-interface">Foreign function interface</a></li>
<ul class="simple"><li><a class="reference" id="foreign-function-interface-importc-pragma_toc" href="#foreign-function-interface-importc-pragma">Importc pragma</a></li>
<li><a class="reference" id="foreign-function-interface-exportc-pragma_toc" href="#foreign-function-interface-exportc-pragma">Exportc pragma</a></li>
<li><a class="reference" id="foreign-function-interface-extern-pragma_toc" href="#foreign-function-interface-extern-pragma">Extern pragma</a></li>
<li><a class="reference" id="foreign-function-interface-bycopy-pragma_toc" href="#foreign-function-interface-bycopy-pragma">Bycopy pragma</a></li>
<li><a class="reference" id="foreign-function-interface-byref-pragma_toc" href="#foreign-function-interface-byref-pragma">Byref pragma</a></li>
<li><a class="reference" id="foreign-function-interface-varargs-pragma_toc" href="#foreign-function-interface-varargs-pragma">Varargs pragma</a></li>
<li><a class="reference" id="foreign-function-interface-union-pragma_toc" href="#foreign-function-interface-union-pragma">Union pragma</a></li>
<li><a class="reference" id="foreign-function-interface-packed-pragma_toc" href="#foreign-function-interface-packed-pragma">Packed pragma</a></li>
<li><a class="reference" id="foreign-function-interface-unchecked-pragma_toc" href="#foreign-function-interface-unchecked-pragma">Unchecked pragma</a></li>
<li><a class="reference" id="foreign-function-interface-dynlib-pragma-for-import_toc" href="#foreign-function-interface-dynlib-pragma-for-import">Dynlib pragma for import</a></li>
<li><a class="reference" id="foreign-function-interface-dynlib-pragma-for-export_toc" href="#foreign-function-interface-dynlib-pragma-for-export">Dynlib pragma for export</a></li>
</ul><li><a class="reference" id="threads_toc" href="#threads">Threads</a></li>
<ul class="simple"><li><a class="reference" id="threads-thread-pragma_toc" href="#threads-thread-pragma">Thread pragma</a></li>
<li><a class="reference" id="threads-gc-safety_toc" href="#threads-gc-safety">GC safety</a></li>
<li><a class="reference" id="threads-threadvar-pragma_toc" href="#threads-threadvar-pragma">Threadvar pragma</a></li>
<li><a class="reference" id="threads-threads-and-exceptions_toc" href="#threads-threads-and-exceptions">Threads and exceptions</a></li>
</ul><li><a class="reference" id="parallel-spawn_toc" href="#parallel-spawn">Parallel &amp; Spawn</a></li>
<ul class="simple"><li><a class="reference" id="parallel-spawn-spawn-statement_toc" href="#parallel-spawn-spawn-statement">Spawn statement</a></li>
<li><a class="reference" id="parallel-spawn-parallel-statement_toc" href="#parallel-spawn-parallel-statement">Parallel statement</a></li>
</ul><li><a class="reference" id="guards-and-locks_toc" href="#guards-and-locks">Guards and locks</a></li>
<ul class="simple"><li><a class="reference" id="guards-and-locks-guards-and-the-locks-section_toc" href="#guards-and-locks-guards-and-the-locks-section">Guards and the locks section</a></li>
<ul class="simple"><li><a class="reference" id="guards-and-the-locks-section-protecting-global-variables_toc" href="#guards-and-the-locks-section-protecting-global-variables">Protecting global variables</a></li>
<li><a class="reference" id="guards-and-the-locks-section-protecting-general-locations_toc" href="#guards-and-the-locks-section-protecting-general-locations">Protecting general locations</a></li>
</ul><li><a class="reference" id="guards-and-locks-lock-levels_toc" href="#guards-and-locks-lock-levels">Lock levels</a></li>
</ul><li><a class="reference" id="taint-mode_toc" href="#taint-mode">Taint mode</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">作者:</th><td> Andreas Rumpf, Zahary Karadjov</td></tr>
<tr><th class="docinfo-name">适用版本:</th><td> 0.11.2</td></tr>
</tbody></table><blockquote><p>&quot;Complexity&quot; seems to be a lot like &quot;energy&quot;: you can transfer it from the end user to one/some of the other players, but the total amount seems to remain pretty much constant for a given task. -- Ran</p></blockquote>

<h1><a class="toc-backref" id="about-this-document" href="#about-this-document">About this document(关于此文档)</a></h1>
<p><strong>注意</strong>: 本文档还是一个草稿! <strong>David.Liu Say：这篇文档被精简，一些不需要的或则简单的说明被删除了的</strong><br/>
Several of Nim's features need more precise wording。This manual will evolve into a proper specification some day.</p>

<p>本文档描述了Nim的词法、语法和语义。</p>

<p>Nim语言是用扩展的BNF来解释： <br/>
<tt class="docutils literal"><span class="pre">(a)*</span></tt> 意味着 0个或则多个 <tt class="docutils literal"><span class="pre">a</span></tt>，<tt class="docutils literal"><span class="pre">a+</span></tt> 意味着 1个或则多个 <tt class="docutils literal"><span class="pre">a</span></tt>，<tt class="docutils literal"><span class="pre">(a)?</span></tt> 意味着一个可选的 <em>a</em>。括号用来分组之用。</p>
<p><tt class="docutils literal"><span class="pre">&amp;</span></tt>是一个向前看操作符。 <tt class="docutils literal"><span class="pre">&amp;a</span></tt> 意味着期望一个 <tt class="docutils literal"><span class="pre">a</span></tt> 但是现在还没被消耗掉，它在接下去的规则中被消耗掉。</p>

<p>符号 <tt class="docutils literal"><span class="pre">|</span></tt> 和 <tt class="docutils literal"><span class="pre">/</span></tt> 用来标记可供选择(OR)，它们都是最低的优先级。<br/>
<tt class="docutils literal"><span class="pre">/</span></tt> 是有序的选择，需要分析器按照给定的顺序依次去尝试。<tt class="docutils literal"><span class="pre">/</span></tt> 常用来确保语法没有歧义。</p>
<p>Non-terminals(非终结符)以一个小写字母开始, abstract terminal symbols(抽象终结符)都大写。 Verbatim terminal symbol(符号终结符号) (包括关键字)都用 <tt class="docutils literal"><span class="pre">'</span></tt>包裹起来。如:<pre>
ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?</pre>
</p>
<p>二元符 <tt class="docutils literal"><span class="pre">^*</span></tt> 是一个缩写，表示的是0个或则多个被它第二个参数分隔的成对出现； 而 <tt class="docutils literal"><span class="pre">^+</span></tt> 表示的是 1个或则多个的成对出现：<br/>
<tt class="docutils literal"><span class="pre">a ^+ b</span></tt> 等于 <tt class="docutils literal"><span class="pre">a (b a)*</span></tt> ^后面的符号+是作用在第一个参数上的，因此就是a (b a)*<br/> <tt class="docutils literal"><span class="pre">a ^* b</span></tt> 等于 <tt class="docutils literal"><span class="pre">(a (b a)*)?</span></tt><br/>
如：<pre>
arrayConstructor = '[' expr ^* ',' ']'</pre>
</p>
<p>Nim的其他部分 - 如 作用域规则 或 运行期语义都是口语化来描述的。</p>

<h1><a class="toc-backref" id="definitions" href="#definitions">Definitions(定义)</a></h1>
<p>一个Nim程序就是发生在由被称为<span id="locations_1">locations(地址)</span>的单元组成的存储器上的指定计算。一个变量基本上就是一个locations的名字。每个变量和location都有一个特定的 <span id="type_1">type(类型)</span>。变量的类型被成为 <span id="static-type_1">static type(静态类型)</span>, location的类型被称为 <span id="dynamic-type_1">dynamic type(动态类型)</span>。如果静态类型和动态类型不一致，那么它可能是动态类型的超类型(父类)或子类型。</p>

<p><span id="identifier_1">identifier(标识符)</span> 就是一个符号，这个符号被申明为变量或则类型或则过程等的名字。一个申明在程序中能起作用的区域称为这个申明的 <span id="scope_1">scope(空间)</span>。Scopes可以嵌套。 
这就是说 标识符说起作用的空间，一定是最小最接近它申明的那个空间，除非重载机制发挥作用了。</p>
<p>表达式计算的结果是 value(值) 或 location(地址)。表达式的结果为地址的话，这个值被称为 <span id="l-values_1">l-values(左值)</span>。左值根据需要，既能够表达地址也能表达出这个地址上包含的值来。 静态方式就能决定值的表达式称为 <span id="constant-expressions_1">constant expressions(常数表达式)</span>;常数表达式永远都不会是左值。</p>
<p><span id="static-error_1">static error(静态错误)</span>就是在程序运行前就能被检测出来的错误。除非特别指明，我们说的错误都是指静态错误。</p>
<p><span id="checked-runtime-error_1">checked runtime error(检查了的运行期错误)</span>就是是在运行期被检测和报告的错误。此类错误的报告的方式通过 <em>raising exceptions(抛出异常)</em> 或 <em>dying with a fatal error(程序接受到致命错误并退出)</em>。现在的Nim实现 t中提供了一个方法禁用掉这些运行期检查，详见 <a class="reference external" href="#pragmas">pragmas</a> </p>

<p>无论一个检查了的运行期错误是导致异常还是一个致命错误，在运行期都应该进行特定的处理。 因此，下面的程序总是出错的：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">let</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="CharLit">'N'</span>
<span class="Keyword">except</span> <span class="Identifier">IndexError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;invalid index&quot;</span></pre>
  <p><span id="unchecked-runtime-error_1">unchecked runtime error(未检查的运行期错误)</span> 就是那些在运行时不保证一定被检测出的错误，因此一旦发生将导致后面出现不可预测的行为。<br/> 
  只有使用了 <span id="safe_1">safe(安全)</span> 语言特性时，未检查的运行期错误才有可能发生。
  </p>

<h1><a class="toc-backref" id="lexical-analysis" href="#lexical-analysis">Lexical Analysis(词法分析)</a></h1>
<h2><a class="toc-backref" id="lexical-analysis-encoding" href="#lexical-analysis-encoding">Encoding(编码)</a></h2>
<p>Nim的源代码文件都必须是UTF-8编码格式。各种行结束符号都可以使用 - Unix平台使用的LF字符, Windows用的CR LF,或则老Mac用的CR。</p>

<h2><a class="toc-backref" id="lexical-analysis-indentation" href="#lexical-analysis-indentation">Indentation(缩进)</a></h2>
<p>Nim是一个 <span id="indentation-sensitive_1">indentation sensitive(缩进敏感)</span> 的语言，这意味着全部的控制结构都是通过缩进来识别的。<br/>只能使用空格来进行缩进，Tab是不可以的。</p>
<p>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</p>

<p>语法解析器采用了一个缩进层级栈：栈由数字组成，每个数字代表空格的数量。<br/>
缩进信息只在解析器确定层级位置时有用：<br/>
伪终结符 <tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> 表示 一个比栈顶的的缩进更深的来了； IND{=} 表示和栈顶一样的缩进深度。<br/>
<tt class="docutils literal"><span class="pre">DED</span></tt> 是另外一个伪操作符，表示从栈中弹出一个值来；<tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> 另外暗示则要压堆栈了。</p>
<p>有了这些符号，我们能很容易的描述出核心的语法了，如Block语句的简单例子：<pre>
ifStmt = 'if' expr ':' stmt
         (IND{=} 'elif' expr ':' stmt)*
         (IND{=} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND{&gt;} stmt ^+ IND{=} DED  # list of statements
     / simpleStmt                 # or a simple statement</pre>
</p>

<h2><a class="toc-backref" id="lexical-analysis-comments" href="#lexical-analysis-comments">Comments(注释)</a></h2>
<p>Comments start anywhere outside a string or character literal with the hash character <tt class="docutils literal"><span class="pre">#</span></tt>. Comments consist of a concatenation of <span id="comment-pieces_1">comment pieces</span>. A comment piece starts with <tt class="docutils literal"><span class="pre">#</span></tt> and runs until the end of the line. The end of line characters belong to the piece. If the next line only consists of a comment piece with no other tokens between it and the preceding one, it does not start a new comment:</p>
<pre><span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># This is a single comment over multiple lines.</span>
  <span class="Comment"># The scanner merges these two pieces.</span>
  <span class="Comment"># The comment continues here.</span></pre><p><span id="documentation-comments_1">Documentation comments</span> are comments that start with two <tt class="docutils literal"><span class="pre">##</span></tt>. Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree!</p>

<h2><a class="toc-backref" id="lexical-analysis-identifiers-keywords" href="#lexical-analysis-identifiers-keywords">Identifiers &amp; Keywords(标识符和关键字)</a></h2>
<p>Nim中的标识符由字母、数字和下划线组成，但必须以字母开始。 <tt class="docutils literal"><span class="pre">下划线</span></tt>不能多个连在一起：<pre>
letter ::= 'A'..'Z' | 'a'..'z' | '\x80'..'\xff'
digit ::= '0'..'9'
IDENTIFIER ::= letter ( ['_'] (letter | digit) )*</pre>
</p>
<p>当前任何值大于127的unicode字符都被归到 <tt class="docutils literal"><span class="pre">字母</span></tt>，在Nim的后续版本中可能会有一部分的Unicode字符归到操作符中</p>
<p>下列关键字被保留，不能用作标识符：</p>
<pre><span class="Keyword">addr</span> <span class="Keyword">and</span> <span class="Keyword">as</span> <span class="Keyword">asm</span> <span class="Keyword">atomic</span>
<span class="Keyword">bind</span> <span class="Keyword">block</span> <span class="Keyword">break</span>
<span class="Keyword">case</span> <span class="Keyword">cast</span> <span class="Keyword">concept</span> <span class="Keyword">const</span> <span class="Keyword">continue</span> <span class="Keyword">converter</span>
<span class="Keyword">defer</span> <span class="Keyword">discard</span> <span class="Keyword">distinct</span> <span class="Keyword">div</span> <span class="Keyword">do</span>
<span class="Keyword">elif</span> <span class="Keyword">else</span> <span class="Keyword">end</span> <span class="Keyword">enum</span> <span class="Keyword">except</span> <span class="Keyword">export</span>
<span class="Keyword">finally</span> <span class="Keyword">for</span> <span class="Keyword">from</span> <span class="Keyword">func</span>
<span class="Keyword">generic</span>
<span class="Keyword">if</span> <span class="Keyword">import</span> <span class="Keyword">in</span> <span class="Keyword">include</span> <span class="Keyword">interface</span> <span class="Keyword">is</span> <span class="Keyword">isnot</span> <span class="Keyword">iterator</span>
<span class="Keyword">let</span>
<span class="Keyword">macro</span> <span class="Keyword">method</span> <span class="Keyword">mixin</span> <span class="Keyword">mod</span>
<span class="Keyword">nil</span> <span class="Keyword">not</span> <span class="Keyword">notin</span>
<span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Keyword">or</span> <span class="Keyword">out</span>
<span class="Keyword">proc</span> <span class="Keyword">ptr</span>
<span class="Keyword">raise</span> <span class="Keyword">ref</span> <span class="Keyword">return</span>
<span class="Keyword">shl</span> <span class="Keyword">shr</span> <span class="Keyword">static</span>
<span class="Keyword">template</span> <span class="Keyword">try</span> <span class="Keyword">tuple</span> <span class="Keyword">type</span>
<span class="Keyword">using</span>
<span class="Keyword">var</span>
<span class="Keyword">when</span> <span class="Keyword">while</span> <span class="Keyword">with</span> <span class="Keyword">without</span>
<span class="Keyword">xor</span>
<span class="Keyword">yield</span>
</pre>
<p>有些关键字还未被使用，保留将来使用</p>

<h2><a class="toc-backref" id="lexical-analysis-identifier-equality" href="#lexical-analysis-identifier-equality">Identifier equality(标识符相等)</a></h2>
<p>如果下面的算法返回true,那么这两个标识符认为是相等的：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">sameIdentifier</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Keyword">and</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLower</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLower</span></pre>
  <p>即比较时：<br/><ul>
   <li>只有第一个字母比较的时候区分大小写，其他的字母不区分大小写</li>
  <li>下划线被忽略</li>
  </ul>
  </p>
<h2><a class="toc-backref" id="lexical-analysis-string-literals" href="#lexical-analysis-string-literals">String literals(字符串文本)</a></h2>
<p>在语法中的终结符为： <tt class="docutils literal"><span class="pre">STR_LIT</span></tt>.</p>
<p>字符串由双引号包裹起来，能包含如下的 <span id="escape-sequences_1">escape sequences(转义序列)</span>:</p>
<table border="1" class="docutils"><tr><th>转义序列</th><th>说明</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt></td><td><span id="newline_1">newline(新行)</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_1">carriage return(回车)</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_1">line feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_1">form feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_1">tabulator(Tab键)</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_1">vertical tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_1">backslash(反斜杠)</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_1">quotation mark(双引号)</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_1">apostrophe(单引号)</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_1">字符的十进制值表示</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_1">alert</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_1">backspace(退格)</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_1">escape</span> <span id="esc_1">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_1">字符的十六进制值表示</span></td></tr>
</table>
<p>Nim中字符串可以包含任意的8位值，甚至是0。但是有些操作可能会将遇到的第一个二进制的0当作字符串终结</p>

<h2><a class="toc-backref" id="lexical-analysis-triple-quoted-string-literals" href="#lexical-analysis-triple-quoted-string-literals">Triple quoted string literals</a></h2><p>Terminal symbol in the grammar: <tt class="docutils literal"><span class="pre">TRIPLESTR_LIT</span></tt>.</p>
<p>String literals can also be delimited by three double quotes <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> ... <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>. Literals in this form may run for several lines, may contain <tt class="docutils literal"><span class="pre">&quot;</span></tt> and do not interpret any escape sequences. For convenience, when the opening <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> is followed by a newline (there may be whitespace between the opening <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;[^&quot;]</span></tt>, so this:</p>
<pre><span class="LongStringLit">&quot;&quot;&quot;&quot;long string within quotes&quot;&quot;&quot;&quot;</span></pre><p>Produces:<pre>
&quot;long string within quotes&quot;</pre>
</p>

<h2><a class="toc-backref" id="lexical-analysis-raw-string-literals" href="#lexical-analysis-raw-string-literals">Raw string literals(Raw字符串文本)</a></h2><p>在语法中的对应终结符是： <tt class="docutils literal"><span class="pre">RSTR_LIT</span></tt>.</p>
<p>There are also raw string literals that are preceded with the letter <tt class="docutils literal"><span class="pre">r</span></tt> (or <tt class="docutils literal"><span class="pre">R</span></tt>) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">openFile</span><span class="Punctuation">(</span><span class="RawData">r&quot;C:\texts\text.txt&quot;</span><span class="Punctuation">)</span> <span class="Comment"># a raw string, so ``\t`` is no tab</span></pre><p>To produce a single <tt class="docutils literal"><span class="pre">&quot;</span></tt> within a raw string literal, it has to be doubled:</p>
<pre><span class="RawData">r&quot;a&quot;&quot;</span><span class="RawData">b&quot;</span></pre><p>Produces:<pre>
a&quot;b</pre>
</p>
<p><tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;&quot;</span></tt> is not possible with this notation, because the three leading quotes introduce a triple quoted string literal. <tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;</span></tt> is the same as <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> since triple quoted string literals do not interpret escape sequences either.</p>

<h2><a class="toc-backref" id="lexical-analysis-generalized-raw-string-literals" href="#lexical-analysis-generalized-raw-string-literals">Generalized raw string literals(广义raw字符串文本)</a></h2>
<p>语法中对应的终结符是： <tt class="docutils literal"><span class="pre">GENERALIZED_STR_LIT</span></tt>, <tt class="docutils literal"><span class="pre">GENERALIZED_TRIPLESTR_LIT</span></tt>.</p>
<p> 构造器 <tt class="docutils literal"><span class="pre">identifier&quot;string literal&quot;</span></tt> (在identifier和双引号之间没有空格) 就是广义raw字符串文本，这是构造器 <tt class="docutils literal"><span class="pre">identifier(r&quot;string literal&quot;)</span></tt>的一种简写方式。so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</p>
<p>The construct <tt class="docutils literal"><span class="pre">identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;</span></tt> exists too. It is a shortcut for <tt class="docutils literal"><span class="pre">identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)</span></tt>.</p>

<h2><a class="toc-backref" id="lexical-analysis-character-literals" href="#lexical-analysis-character-literals">Character literals(字符文本)</a></h2>
<p>字符文本是用单引号<tt class="docutils literal"><span class="pre">''</span></tt>包裹起来的，也能有和字符串一样的转义序列 - 除了<span id="newline_2">新行</span> (<tt class="docutils literal"><span class="pre">\n</span></tt>)  ，因为新行有可能是2个字符的 (比如 Windows下是CR/LF)。 <br/>
下面是字符中合法的 <span id="escape-sequences_2">转义序列</span>：</p>
<table border="1" class="docutils"><tr><th>Escape sequence</th><th>Meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_2">carriage return</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_2">line feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_2">form feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_2">tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_2">vertical tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_2">backslash</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_2">quotation mark</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_2">apostrophe</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_2">character with decimal value d</span>; all decimal digits directly following are used for the character</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_2">alert</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_2">backspace</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_2">escape</span> <span id="esc_2">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_2">character with hex value HH</span>; exactly two hex digits are allowed</td></tr>
</table><p>一个char字符不是一个Unicode字符，而是一个字节。<br/>
The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support <tt class="docutils literal"><span class="pre">array[char, int]</span></tt> or <tt class="docutils literal"><span class="pre">set[char]</span></tt> efficiently as many algorithms rely on this feature. <br/>
Unicode字符用 <cite>Rune</cite> 类型来表示，它能展示任意的unicode字符。<tt class="docutils literal"><span class="pre">Rune</span></tt> 在 <a class="reference external" href="unicode.html">unicode 模块</a>中定义。</p>

<h2><a class="toc-backref" id="lexical-analysis-numerical-constants" href="#lexical-analysis-numerical-constants">Numerical constants(数字常量)</a></h2>
<p>数字常量是一个类型，有如下的形式：<pre>
hexdigit = digit | 'A'..'F' | 'a'..'f'
octdigit = '0'..'7'
bindigit = '0'..'1'
HEX_LIT = '0' ('x' | 'X' ) hexdigit ( ['_'] hexdigit )*
DEC_LIT = digit ( ['_'] digit )*
OCT_LIT = '0o' octdigit ( ['_'] octdigit )*
BIN_LIT = '0' ('b' | 'B' ) bindigit ( ['_'] bindigit )*

INT_LIT = HEX_LIT
        | DEC_LIT
        | OCT_LIT
        | BIN_LIT

INT8_LIT = INT_LIT ['\''] ('i' | 'I') '8'
INT16_LIT = INT_LIT ['\''] ('i' | 'I') '16'
INT32_LIT = INT_LIT ['\''] ('i' | 'I') '32'
INT64_LIT = INT_LIT ['\''] ('i' | 'I') '64'

UINT_LIT = INT_LIT ['\''] ('u' | 'U')
UINT8_LIT = INT_LIT ['\''] ('u' | 'U') '8'
UINT16_LIT = INT_LIT ['\''] ('u' | 'U') '16'
UINT32_LIT = INT_LIT ['\''] ('u' | 'U') '32'
UINT64_LIT = INT_LIT ['\''] ('u' | 'U') '64'

exponent = ('e' | 'E' ) ['+' | '-'] digit ( ['_'] digit )*
FLOAT_LIT = digit (['_'] digit)* (('.' (['_'] digit)* [exponent]) |exponent)
FLOAT32_LIT = HEX_LIT '\'' ('f'|'F') '32'
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] ('f'|'F') '32'
FLOAT64_LIT = HEX_LIT '\'' ('f'|'F') '64'
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] ('f'|'F') '64'</pre>
</p>
<p>如上面的产生式一样，数字常量是可以包含下划线的，这样可读性更强。<br/>
整数和浮点数可以增加前缀符号来表示不同的进制关系，十进制(没有前缀)，二进制 (前缀为 <tt class="docutils literal"><span class="pre">0b</span></tt>), 八进制 (前缀为 <tt class="docutils literal"><span class="pre">0o</span></tt>) 以及 16进制 (前缀为 <tt class="docutils literal"><span class="pre">0x</span></tt>) </p>
<p>对于数字类型来说，还可以增加一个单引号的后缀(<span id="type-suffix_1">类型后缀</span>)。 <br/>
文本中不含有 点(.) 或 <tt class="docutils literal"><span class="pre">E|e</span></tt>的无类型后缀的数字的类型为 <tt class="docutils literal"><span class="pre">int(整型)</span></tt>，
含有点(.) 或 <tt class="docutils literal"><span class="pre">E|e</span></tt>的为<tt class="docutils literal"><span class="pre">float(浮点)</span></tt>。<br/>
类型后缀是可选的，有如下类型后缀：</p>
<table border="1" class="docutils"><tr><th>Type Suffix</th><th>Resulting type of literal</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i8</span></tt></td><td>int8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i16</span></tt></td><td>int16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i32</span></tt></td><td>int32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i64</span></tt></td><td>int64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u</span></tt></td><td>uint</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u8</span></tt></td><td>uint8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u16</span></tt></td><td>uint16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u32</span></tt></td><td>uint32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u64</span></tt></td><td>uint64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f32</span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f64</span></tt></td><td>float64</td></tr>
</table><p>Floating point literals may also be in binary, octal or hexadecimal notation: <tt class="docutils literal"><span class="pre">0B0_10001110100_0000101001000111101011101111111011000101001101001001'f64</span></tt> is approximately 1.72826e35 according to the IEEE floating point standard.</p>

<h2><a class="toc-backref" id="lexical-analysis-operators" href="#lexical-analysis-operators">Operators(操作符)</a></h2>
<p>Nim中可以自定义操作符。自定义的操作符可以是下面字符的任意组合：<pre>
=     +     -     *     /     &lt;     &gt;
@     $     ~     &amp;     %     |
!     ?     ^     .     :     \</pre>
</p>
<p>下面这些关键字也是操作符： <tt class="docutils literal"><span class="pre">and or not xor shl shr div mod in notin is isnot of</span></tt>.</p>
<p><span class="tok">=</span>, <span class="tok">:</span>, <span class="tok">::</span> are not available as general operators; they are used for other notational purposes.</p>
<p><tt class="docutils literal"><span class="pre">*:</span></tt> is as a special case the two tokens <span class="tok">*</span> and <span class="tok">:</span> (to support <tt class="docutils literal"><span class="pre">var v*: T</span></tt>).</p>

<h2><a class="toc-backref" id="lexical-analysis-other-tokens" href="#lexical-analysis-other-tokens">Other tokens(其他Tokens)</a></h2>
<p>下列为其他的Tokens：<pre>
`   (     )     {     }     [     ]     ,  ;   [.    .]  {.   .}  (.  .)</pre>
</p>
<p>The <span id="slice_1">slice</span> operator <span class="tok">..</span> takes precedence over other tokens that contain a dot: <span class="tok">{..}</span> are the three tokens <span class="tok">{</span>, <span class="tok">..</span>, <span class="tok">}</span> and not the two tokens <span class="tok">{.</span>, <span class="tok">.}</span>.</p>

<h1><a class="toc-backref" id="syntax" href="#syntax">Syntax(语法)</a></h1>
<p>This section lists Nim's standard syntax. How the parser handles the indentation is already described in the <a class="reference external" href="#lexical-analysis">Lexical Analysis</a> section.</p>
<p>Nim 运行自定义操作符。二元操作符有 11种优先层级</p>

<h2><a class="toc-backref" id="syntax-associativity" href="#syntax-associativity">Associativity(结合)</a></h2><p>二元操作符的第一个字符是 <tt class="docutils literal"><span class="pre">^</span></tt> 则是右结合的操作符, 否则是左结合的。</p>

<h2><a class="toc-backref" id="syntax-precedence" href="#syntax-precedence">Precedence(优先级)</a></h2>
<p>一元操作符总是比二元操作符结合紧密，即优先级高的： <tt class="docutils literal"><span class="pre">$a + b</span></tt> 是 <tt class="docutils literal"><span class="pre">($a) + b</span></tt> 而不是 <tt class="docutils literal"><span class="pre">$(a + b)</span></tt>.</p>
<p>如果一个一元操作符的第一个字符是 <tt class="docutils literal"><span class="pre">@</span></tt> ，那么它比 <tt class="docutils literal"><span class="pre">primarySuffix</span></tt>结合紧密(优先级高)：<br/>
<tt class="docutils literal"><span class="pre">@x.abc</span></tt> 就是 <tt class="docutils literal"><span class="pre">(@x).abc</span></tt> ，而 <tt class="docutils literal"><span class="pre">$x.abc</span></tt> 是 <tt class="docutils literal"><span class="pre">$(x.abc)</span></tt>。(一元操作符也可以有多个字符的，因为可以自定义操作符的)</p>
<p>对于不是关键字的二元操作来说，优先级按照下列规则进行：</p>
<p>1. 以 <tt class="docutils literal"><span class="pre">-&gt;</span></tt> 或 <tt class="docutils literal"><span class="pre">~&gt;</span></tt> 或 <tt class="docutils literal"><span class="pre">=&gt;</span></tt> 结尾的操作符是所有操作符中的最低优先级</p>
<p>2. 以 <tt class="docutils literal"><span class="pre">=</span></tt>结尾，并且第一个字符不是 <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">=</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">?</span></tt> 中的任何一个的操作符，是倒数第二低的优先级</p>
<p>3. 其他的按照第一个字符来判定优先级</p>
<table border="1" class="docutils"><tr><th>Precedence level</th><th>Operators</th><th>First character</th><th>Terminal symbol</th></tr>
<tr><td>10 (highest)</td><td></td><td><tt class="docutils literal"><span class="pre">$ ^</span></tt></td><td>OP10</td></tr>
<tr><td>9</td><td><tt class="docutils literal"><span class="pre">* / div mod shl shr %</span></tt></td><td><tt class="docutils literal"><span class="pre">* % \ /</span></tt></td><td>OP9</td></tr>
<tr><td>8</td><td><tt class="docutils literal"><span class="pre">+ -</span></tt></td><td><tt class="docutils literal"><span class="pre">+ - ~ |</span></tt></td><td>OP8</td></tr>
<tr><td>7</td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td>OP7</td></tr>
<tr><td>6</td><td><tt class="docutils literal"><span class="pre">..</span></tt></td><td><tt class="docutils literal"><span class="pre">.</span></tt></td><td>OP6</td></tr>
<tr><td>5</td><td><tt class="docutils literal"><span class="pre">== &lt;= &lt; &gt;= &gt; != in notin is isnot not of</span></tt></td><td><tt class="docutils literal"><span class="pre">= &lt; &gt; !</span></tt></td><td>OP5</td></tr>
<tr><td>4</td><td><tt class="docutils literal"><span class="pre">and</span></tt></td><td></td><td>OP4</td></tr>
<tr><td>3</td><td><tt class="docutils literal"><span class="pre">or xor</span></tt></td><td></td><td>OP3</td></tr>
<tr><td>2</td><td></td><td><tt class="docutils literal"><span class="pre">@ : ?</span></tt></td><td>OP2</td></tr>
<tr><td>1</td><td><em>assignment operator</em> (like <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>)</td><td></td><td>OP1</td></tr>
<tr><td>0 (lowest)</td><td><em>arrow like operator</em> (like <tt class="docutils literal"><span class="pre">-&gt;</span></tt>, <tt class="docutils literal"><span class="pre">=&gt;</span></tt>)</td><td></td><td>OP0</td></tr>
</table>
<h2><a class="toc-backref" id="syntax-strong-spaces" href="#syntax-strong-spaces">Strong spaces(没有意思的，直接删除了)</a></h2>
<pre>
<span class="Comment">有下面的类似字符的，进入strongSpaces模式</span>
<span class="Comment">#! strongSpaces</span>
</pre>

<h2><a class="toc-backref" id="syntax-grammar" href="#syntax-grammar">Grammar(语法)</a></h2>
<p>语法的起点符号是 <tt class="docutils literal"><span class="pre">module</span></tt></p>
<pre>module = stmt ^* (';' / IND{=})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
colcom = ':' COMMENT?
operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of'
         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'
prefixOperator = operator
optInd = COMMENT?
optPar = (IND{&gt;} | IND{=})?
simpleExpr = arrowExpr (OP0 optInd arrowExpr)*
arrowExpr = assignExpr (OP1 optInd assignExpr)*
assignExpr = orExpr (OP2 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
       | IDENT | 'addr' | 'type'
indexExpr = expr
indexExprList = indexExpr ^+ comma
exprColonEqExpr = expr (':'|'=' expr)?
exprList = expr ^+ comma
dotExpr = expr '.' optInd symbol
qualifiedIdent = symbol ('.' optInd symbol)?
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'
castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
        | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
        | 'when' | 'var' | 'mixin'
par = '(' optInd (&amp;parKeyw complexOrSimpleStmt ^+ ';'
                 | simpleExpr ('=' expr (';' complexOrSimpleStmt ^+ ';' )? )?
                            | (':' expr)? (',' (exprColonEqExpr comma?)*)?  )?
        optPar ')'
literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT
          | NIL
generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
identOrLiteral = generalizedLit | symbol | literal
               | par | arrayConstr | setOrTableConstr
               | castExpr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonEqExpr comma?)* ')' doBlocks?
      | doBlocks
      | '.' optInd symbol generalizedLit?
      | '[' optInd indexExprList optPar ']'
      | '{' optInd indexExprList optPar '}'
      | &amp;( '`'|IDENT|literal|'cast'|'addr'|'type') expr # command syntax
condExpr = expr colcom expr optInd
        ('elif' expr colcom expr optInd)*
         'else' colcom expr
ifExpr = 'if' condExpr
whenExpr = 'when' condExpr
pragma = '{.' optInd (exprColonExpr comma?)* optPar ('.}' | '}')
identVis = symbol opr?  # postfix position
identWithPragma = identVis pragma?
declColonEquals = identWithPragma (comma identWithPragma)* comma?
                  (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals = ident (comma ident)* comma?
     (':' optInd typeDesc)? ('=' optInd expr)?)
inlTupleDecl = 'tuple'
    [' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']'
extTupleDecl = 'tuple'
    COMMENT? (IND{&gt;} identColonEquals (IND{=} identColonEquals)*)?
tupleClass = 'tuple'
paramList = '(' declColonEquals ^* (comma/semicolon) ')'
paramListArrow = paramList? ('-&gt;' optInd typeDesc)?
paramListColon = paramList? (':' optInd typeDesc)?
doBlock = 'do' paramListArrow pragmas? colcom stmt
doBlocks = doBlock ^* IND{=}
procExpr = 'proc' paramListColon pragmas? ('=' COMMENT? stmt)?
distinct = 'distinct' optInd typeDesc
expr = (ifExpr
      | whenExpr
      | caseExpr
      | tryExpr)
      / simpleExpr
typeKeyw = 'var' | 'ref' | 'ptr' | 'shared' | 'tuple'
         | 'proc' | 'iterator' | 'distinct' | 'object' | 'enum'
primary = typeKeyw typeDescK
        /  prefixOperator* identOrLiteral primarySuffix*
        / 'static' primary
        / 'bind' primary
typeDesc = simpleExpr
typeDefAux = simpleExpr
           | 'concept' typeClass
macroColon = ':' stmt? ( IND{=} 'of' exprList ':' stmt
                       | IND{=} 'elif' expr ':' stmt
                       | IND{=} 'except' exprList ':' stmt
                       | IND{=} 'else' ':' stmt )*
exprStmt = simpleExpr
         (( '=' optInd expr )
         / ( expr ^+ comma
             doBlocks
              / macroColon
           ))?
importStmt = 'import' optInd expr
              ((comma expr)*
              / 'except' optInd (expr ^+ comma))
includeStmt = 'include' optInd expr ^+ comma
fromStmt = 'from' moduleName 'import' optInd expr (comma expr)*
returnStmt = 'return' optInd expr?
raiseStmt = 'raise' optInd expr?
yieldStmt = 'yield' optInd expr?
discardStmt = 'discard' optInd expr?
breakStmt = 'break' optInd expr?
continueStmt = 'break' optInd expr?
condStmt = expr colcom stmt COMMENT?
           (IND{=} 'elif' expr colcom stmt)*
           (IND{=} 'else' colcom stmt)?
ifStmt = 'if' condStmt
whenStmt = 'when' condStmt
whileStmt = 'while' expr colcom stmt
ofBranch = 'of' exprList colcom stmt
ofBranches = ofBranch (IND{=} ofBranch)*
                      (IND{=} 'elif' expr colcom stmt)*
                      (IND{=} 'else' colcom stmt)?
caseStmt = 'case' expr ':'? COMMENT?
            (IND{&gt;} ofBranches DED
            | IND{=} ofBranches)
tryStmt = 'try' colcom stmt &amp;(IND{=}? 'except'|'finally')
           (IND{=}? 'except' exprList colcom stmt)*
           (IND{=}? 'finally' colcom stmt)?
tryExpr = 'try' colcom stmt &amp;(optInd 'except'|'finally')
           (optInd 'except' exprList colcom stmt)*
           (optInd 'finally' colcom stmt)?
exceptBlock = 'except' colcom stmt
forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt
blockStmt = 'block' symbol? colcom stmt
staticStmt = 'static' colcom stmt
deferStmt = 'defer' colcom stmt
asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLE_STR_LIT)
genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
genericParamList = '[' optInd
  genericParam ^* (comma/semicolon) optPar ']'
pattern = '{' stmt '}'
indAndComment = (IND{&gt;} COMMENT)? | COMMENT?
routine = optInd identVis pattern? genericParamList?
  paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(p) = COMMENT? p / (IND{&gt;} (p / COMMENT)^+IND{=} DED)
constant = identWithPragma (colon typedesc)? '=' optInd expr indAndComment
enum = 'enum' optInd (symbol optInd ('=' optInd expr COMMENT?)? comma?)+
objectWhen = 'when' expr colcom objectPart COMMENT?
            ('elif' expr colcom objectPart COMMENT?)*
            ('else' colcom objectPart COMMENT?)?
objectBranch = 'of' exprList colcom objectPart
objectBranches = objectBranch (IND{=} objectBranch)*
                      (IND{=} 'elif' expr colcom objectPart)*
                      (IND{=} 'else' colcom objectPart)?
objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
            (IND{&gt;} objectBranches DED
            | IND{=} objectBranches)
objectPart = IND{&gt;} objectPart^+IND{=} DED
           / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
object = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart
typeClassParam = ('var')? symbol
typeClass = typeClassParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
              &amp;IND{&gt;} stmt
typeDef = identWithPragma genericParamList? '=' optInd typeDefAux
            indAndComment?
varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr
variable = (varTuple / identColonEquals) indAndComment
bindStmt = 'bind' optInd qualifiedIdent ^+ comma
mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma
pragmaStmt = pragma (':' COMMENT? stmt)?
simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
           | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
           | includeStmt | commentStmt) / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
                    | tryStmt | forStmt
                    | blockStmt | staticStmt | deferStmt | asmStmt
                    | 'proc' routine
                    | 'method' routine
                    | 'iterator' routine
                    | 'macro' routine
                    | 'template' routine
                    | 'converter' routine
                    | 'type' section(typeDef)
                    | 'const' section(constant)
                    | ('let' | 'var') section(variable)
                    | bindStmt | mixinStmt)
                    / simpleStmt
stmt = (IND{&gt;} complexOrSimpleStmt^+(IND{=} / ';') DED)
     / simpleStmt ^+ ';'
</pre>
<h1><a class="toc-backref" id="types" href="#types">Types(类型)</a></h1>
<p>Nim语言是静态类型的，所有的表达式的类型在编译期都会明确下来。</p>
<p>下面是一些主要的类型:</p>
<ul class="simple"><li>ordinal types(序数类型) (包括整数、布尔、字符、枚举(也就包括了 子区间)</li>
<li>floating point types(浮点数)</li>
<li>string type(字符串)</li>
<li>structured types(结构)</li>
<li>reference (pointer) type(引用指针)</li>
<li>procedural type(过程)</li>
<li>generic type(范型)</li>
</ul>
<h2><a class="toc-backref" id="types-ordinal-types" href="#types-ordinal-types">Ordinal types
(序数类型)</a></h2>
<p>序数类型有如下的一些特性：</p>
<ul class="simple">
<li>可数和有序。支持 <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">ord</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt> 过程</li>
<li>有最小值和最大值。越界会抛出一个检查的运行期错误或编译时的静态错误。</li>
</ul>
<p>整数、布尔、字符、枚举(也就包括了 子区间)都是序数类型。<br/>
为了实现的简单化，整数中的<tt class="docutils literal"><span class="pre">uint</span></tt> 和 <tt class="docutils literal"><span class="pre">uint64</span></tt> 不是序数类型</p>

<h2><a class="toc-backref" id="types-pre-defined-integer-types" href="#types-pre-defined-integer-types">Pre-defined integer types(预定义的整数类型)</a></h2>
<p>如下的整数类型被预定义好了：</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">int</span></tt></dt>
<dd>* 通用的有符号整数<br/>
* 字节长度平台相关且与指针相同<br/>
* 默认没有任何符号后缀的整数文本就是int类型。</dd>
<dt>intXX</dt>
<dd>* XX位的有符号整数(如: int16 就是16位长的整数)。<br/>
* 当前支持 <tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt>, <tt class="docutils literal"><span class="pre">int32</span></tt>, <tt class="docutils literal"><span class="pre">int64</span></tt><br/>
* 有'iXX后缀的文本就是指定的XX位的有符号整数(如:  123'i8 就是一个8位的值为123的整数)。</dd>
<dt><tt class="docutils literal"><span class="pre">uint</span></tt></dt>
<dd>* 通用的无符号整数<br/>
 * 字节长度平台相关且与指针相同<br/>
 *  有<tt class="docutils literal"><span class="pre">'u</span></tt>后缀的文本就是无符号的整数</dd>
<dt>uintXX</dt>
<dd>* XX位的有符号整数(如: uint16 就是16位长的无符号整数)<br/>
* 当前支持 <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint16</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, <tt class="docutils literal"><span class="pre">uint64</span></tt><br/>
* 有'uXX后缀的文本就是指定的XX位的无符号整数(如:  254'u8 就是一个8位的值为254的无符号整数)<br/>
* 无符号数的操作都会回头的，不会导致溢出错误</dd>
</dl>
<p>有符号数可以通过在相应的操作符后增加 <tt class="docutils literal"><span class="pre">%</span></tt> 表示将此有符号数按照无符号数对待:</p>
<table border="1" class="docutils"><tr><th>操作</th><th>说明</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">a +% b</span></tt></td><td>无符号加</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a -% b</span></tt></td><td>无符号减</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a *% b</span></tt></td><td>无符号乘</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a /% b</span></tt></td><td>无符号除</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a %% b</span></tt></td><td>无符号余</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;% b</span></tt></td><td> <tt class="docutils literal"><span class="pre">a</span></tt>、<tt class="docutils literal"><span class="pre">b</span></tt> 看作无符号数进行比较</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;=% b</span></tt></td><td> <tt class="docutils literal"><span class="pre">a</span></tt> 、<tt class="docutils literal"><span class="pre">b</span></tt> 看作无符号数进行比较</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ze(a)</span></tt></td><td>extends the bits of <tt class="docutils literal"><span class="pre">a</span></tt> with zeros until it has the width of the <tt class="docutils literal"><span class="pre">int</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU8(a)</span></tt></td><td>treats <tt class="docutils literal"><span class="pre">a</span></tt> as unsigned and converts it to an unsigned integer of 8 bits (but still the <tt class="docutils literal"><span class="pre">int8</span></tt> type)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU16(a)</span></tt></td><td>treats <tt class="docutils literal"><span class="pre">a</span></tt> as unsigned and converts it to an unsigned integer of 16 bits (but still the <tt class="docutils literal"><span class="pre">int16</span></tt> type)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU32(a)</span></tt></td><td>treats <tt class="docutils literal"><span class="pre">a</span></tt> as unsigned and converts it to an unsigned integer of 32 bits (but still the <tt class="docutils literal"><span class="pre">int32</span></tt> type)</td></tr>
</table>
<p>表达式中不同类型的整数之间<span id="automatic-type-conversion_1">自动类型转换</span>：小的类型转换为大的类型</p>
<pre><span class="Keyword">var</span> <span class="Identifier">myInt16</span> <span class="Operator">=</span> <span class="DecNumber">5</span><span class="Identifier">i16</span>
<span class="Keyword">var</span> <span class="Identifier">myInt</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">34</span>     <span class="Comment"># of type ``int16``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="Identifier">myInt</span>  <span class="Comment"># of type ``int``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">2</span><span class="Identifier">i32</span>   <span class="Comment"># of type ``int32``</span></pre>
<p>但是如果<tt class="docutils literal"><span class="pre">int</span></tt>的文本值在小的整数类型的范围内，并且转换为小类型比其他的隐含转换更简单的话，那么将会被转化为小的整数类型。因此 <tt class="docutils literal"><span class="pre">myInt16 + 34</span></tt> 的结果是 <tt class="docutils literal"><span class="pre">int16</span></tt> 类型。</p>
<p>更多的转换信息可见 <a class="reference external" href="#convertible-relation">Convertible relation</a></p>
<h2><a class="toc-backref" id="types-subrange-types" href="#types-subrange-types">Subrange types(子区间类型)</a></h2>
<p>子区间类型就是一个序数类型(母类型)<br/>中的某一段值。定义一个子区间类型需要定义这个类型的最小和最大值：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Subrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span></pre>
  <p><tt class="docutils literal"><span class="pre">Subrange</span></tt> 是一个整数的子区间，范围为 0到5。<br/>
  将不在此范围(0-5)的值赋给<tt class="docutils literal"><span class="pre">Subrange</span></tt>将导致一个运行期检查错误(或静态错误如能检测出)。<br/>
  母类型和子区间类型之间相互赋值是允许的。</p>
<p>子区间类型的字节长度和母类型相同</p>
<p>如下的操作符第一个参数是子区间、第二个参数是整数的话：<br/> <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">min</span></tt>, <tt class="docutils literal"><span class="pre">max</span></tt>, <tt class="docutils literal"><span class="pre">succ</span></tt>, <tt class="docutils literal"><span class="pre">pred</span></tt>, <tt class="docutils literal"><span class="pre">mod</span></tt>, <tt class="docutils literal"><span class="pre">div</span></tt>, <tt class="docutils literal"><span class="pre">%%</span></tt>, <tt class="docutils literal"><span class="pre">and</span></tt> (bitwise <tt class="docutils literal"><span class="pre">and</span></tt>) 则表达式返回的结果依旧是子区间(操作符被重载了)</p>
<p>位操作 <tt class="docutils literal"><span class="pre">and</span></tt>的一个参数是常量的话，那么整个位操作的返回类型为子区间</p>
<p>这样下面的代码就是可以说明的了：</p>
<pre><span class="Keyword">case</span> <span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Keyword">and</span> <span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="DecNumber">7</span>
<span class="Keyword">of</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;A&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;B&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">9</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;C&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">10</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;D&quot;</span>
<span class="Comment"># 备注: 不需要 ``else``了， (x and 3) + 7 的类型是 range[7..10]</span></pre>
<h2><a class="toc-backref" id="types-pre-defined-floating-point-types" href="#types-pre-defined-floating-point-types">Pre-defined floating point types(预定义浮点类型)</a></h2>
<p>如下的浮点类型被预定义好了：</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">float</span></tt></dt>
<dd>* 通用的浮点类型<br/>
* 字节长度平台相关 (编译器选择处理器最快的浮点类型)</dd>
<dt>floatXX</dt>
<dd>* XX位的浮点数(如: float64 是64位宽的浮点数)<br/>
* 当前只支持 <tt class="docutils literal"><span class="pre">float32</span></tt> 和 <tt class="docutils literal"><span class="pre">float64</span></tt>
* 有'fXX后缀的文本就是指定的XX位的浮点数</dd>
</dl>
<p>表达式中不同类型的浮点数会自动进行类型转换，转换规则见后续 <a class="reference external" href="#convertible-relation">转换方法</a>。 <br/>
浮点数的算数计算遵循IEEE标准。 <br/>
整数和浮点数之间不会互相自动转换。</p>
<p>IEEE标准定义了5种浮点异常：</p>
<ul class="simple"><li>Invalid(非法): 数学上的非法操作。如: 0.0/0.0, sqrt(-1.0), and log(-37.8).</li>
<li>Division by zero(0除): 如 1.0/0.0.</li>
<li>Overflow(上溢): 操作的结果超出了区间范围　如: MAXDOUBLE+0.0000000000001e308.</li>
<li>Underflow(下溢):</li>
<li>Inexact(不精准): 产生了一个不能准备表达出的值。比如无限循环小数 2.0 / 3.0, log(1.1) 以及输入0.1等</li>
</ul>
<p>IEEE异常可以在运行期被忽略或则转换为Nim的异常：<br/>
<span id="floatinvalidoperror_1">FloatInvalidOpError</span>, <span id="floatdivbyzeroerror_1">FloatDivByZeroError</span>, <span id="floatoverflowerror_1">FloatOverflowError</span>, <span id="floatunderflowerror_1">FloatUnderflowError</span>, 和 <span id="floatinexacterror_1">FloatInexactError</span>.<br/>这些异常都继承与 <span id="floatingpointerror_1">FloatingPointError</span></p>
<p>Nim 使用编译指示 <span id="nanchecks_1">NaNChecks</span> 和 <span id="infchecks_1">InfChecks</span> 来控制 IEEE 的异常是被忽略还是转换为Nim的异常：</p>

<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">NanChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">InfChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="FloatNumber">1.0</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># 抛出异常 FloatInvalidOpError</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># 抛出异常 FloatOverflowError</span></pre>
<p>当前实现中 <tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt> and <tt class="docutils literal"><span class="pre">FloatInexactError</span></tt> 是永远不会被抛出的。<br/>
<tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt>被<tt class="docutils literal"><span class="pre">FloatOverflowError</span></tt>代替了。<br/>
可以用 编译指示 <span id="floatchecks_1">floatChecks</span>  来直接代替 <tt class="docutils literal"><span class="pre">NaNChecks</span></tt> 和 <tt class="docutils literal"><span class="pre">InfChecks</span></tt> 这两个指示(就是这2个指示的缩写组合)。.<br/>
默认<tt class="docutils literal"><span class="pre">floatChecks</span></tt>是关闭的</p>

<p>编译指示<tt class="docutils literal"><span class="pre">floatChecks</span></tt>只影响浮点数的这些操作符： <tt class="docutils literal"><span class="pre">+</span></tt> <tt class="docutils literal"><span class="pre">-</span></tt><tt class="docutils literal"><span class="pre">*</span></tt><tt class="docutils literal"><span class="pre">/</span></tt></p>
<p>在编译期，实现上总是使用尽可能大的精度来评估浮点数的值。<br/>
那么<tt class="docutils literal"><span class="pre">0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64</span></tt>  的结果将是true</p>

<h2><a class="toc-backref" id="types-boolean-type" href="#types-boolean-type">Boolean type(布尔类型)</a></h2>
<p>Nim中的布尔类型为 <span id="bool_1">bool</span>，有两个预定义的值 <tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt>。<br/>
while, if, elif, when 语句中的条件必须是bool类型</p>
<p><pre>
ord(false) = 0 
ord(true) = 1</pre>
</p>
<p>bool类型支持操作：<tt class="docutils literal"><span class="pre">not, and, or, xor, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></tt>。<br/>
 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> 操作符执行短路评估，如：</p>
<pre><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment">#  如果p == nil那么p.name 不会被评估</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre>
  <p>布尔类型的字节长度是1个字节</p>

<h2><a class="toc-backref" id="types-character-type" href="#types-character-type">Character type(字符类型)</a></h2>
<p>Nim中的字符类型为 <tt class="docutils literal"><span class="pre">char</span></tt>，字节长度为１个字节。因此有可能不能完整的表示一个UTF-8字符。<br/>
Unicode 字符可用<cite>Rune</cite>类型，它能描述任何一个Unicode字符。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 在 <a class="reference external" href="unicode.html">unicode</a>模块中定义<br/>
迭代器 <tt class="docutils literal"><span class="pre">runes</span></tt> 可用来迭代Unicode字符串</p>

<h2><a class="toc-backref" id="types-enumeration-types" href="#types-enumeration-types">Enumeration types(枚举类型)</a></h2>
<p>枚举类型就是定一个新的类型，类型的值都是指定的且有序的。如：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span></pre>
<p>下面的是他们的序号了:)<pre>
ord(north) == 0
ord(east) == 1
ord(south) == 2
ord(west) == 3</pre>
</p>
<p>因此 north &lt; east &lt; south &lt; west，即枚举类型可以比较的。</p>
<p>为了跟好的和其他语言衔接，枚举类型中的字段可以被赋一个明确的序数值。<br/>多个序数值必须是升序排列的。 没有被明确赋值的字段的值是前一个的值+1</p>
<p>明确的有序的枚举类型的值可以有<em>洞</em>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">TokenType</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="DecNumber">89</span> <span class="Comment"># holes are valid</span></pre>
    <p>但是枚举不能用来数组索引，而且过程 <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt>, <tt class="docutils literal"><span class="pre">succ</span></tt> 和 <tt class="docutils literal"><span class="pre">pred</span></tt> 也不适用。</p>
<p>操作符 <tt class="docutils literal"><span class="pre">$</span></tt> 适用于枚举类型。枚举字段的$操作输出的文本结果可以被明确指定：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;my value A&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
    <span class="Identifier">valueB</span> <span class="Operator">=</span> <span class="StringLit">&quot;value B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valueC</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span>
    <span class="Identifier">valueD</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre>
    <p>如上所示，用元组可以给字段设定特定的序号和字符串值，当然也能只指定其中一项。</p>
<p>给枚举类型增加编译指示 <tt class="docutils literal"><span class="pre">pure</span></tt> 这样它的字段将不会加到当前的空间中。要读写这个字段必须通过 <tt class="docutils literal"><span class="pre">MyEnum.value</span></tt>这样的方式进行:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span><span class="Punctuation">,</span> <span class="Identifier">valueB</span><span class="Punctuation">,</span> <span class="Identifier">valueC</span><span class="Punctuation">,</span> <span class="Identifier">valueD</span>

<span class="Identifier">echo</span> <span class="Identifier">valueA</span> <span class="Comment"># 错误: 未知的标识符</span>
<span class="Identifier">echo</span> <span class="Identifier">MyEnum</span><span class="Operator">.</span><span class="Identifier">valueA</span> <span class="Comment"># 成功</span></pre>

<h2><a class="toc-backref" id="types-string-type" href="#types-string-type">String type(字符串类型)</a></h2>
<p>所有的字符串文本都是 <tt class="docutils literal"><span class="pre">string</span></tt>类型。
中字符串和字符序列非常类似的。<br/>
但是Nim中字符串是以0结尾，并且有一个长度字段。<br/>
内置过程 <tt class="docutils literal"><span class="pre">len</span></tt> 可以得到字符串的长度(不包括结尾０)。<br/>
字符串的赋值总是拷贝方式，可用操作符 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 将两个字符串连接起来。</p>
<p>字符串按照字母序进行比较，因此所有的比较操作符都是可用的。<br/>字符串的下标方式与数组类似 (从0开始)。<br/>
和数组不同的是，字符串可以用在case语句中。</p>
<pre><span class="Keyword">case</span> <span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-v&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optVerbose</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-h&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;-?&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optHelp</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;invalid command line option!</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span></pre>

<h2><a class="toc-backref" id="types-cstring-type" href="#types-cstring-type">cstring type(cstring类型)</a></h2>
<p><tt class="docutils literal"><span class="pre">cstring</span></tt> 类型表示的是一个指向以0结尾的字符数字的指针，这样就兼容了Ansi C中的 <tt class="docutils literal"><span class="pre">char*</span></tt>类型了。<br/>
下标操作 <tt class="docutils literal"><span class="pre">s[i]</span></tt> 就是获取<tt class="docutils literal"><span class="pre">s</span></tt>的第i个<em>字符</em>。但在进行下标操作的时候是不进行边界检查的(即不保证下标操作都是安全的)。</p>
<p>如果 Nim 的 string类型被传给  C风格的过程，此string会隐含的转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 类型：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Punctuation">,</span>
                                  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;This works %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;as expected&quot;</span><span class="Punctuation">)</span></pre>

<p>尽管这个转换是隐形的，但是并不是<em>安全</em>的： GC并没有考虑 <tt class="docutils literal"><span class="pre">cstring</span></tt> 可能会收集这个cstring对应的string的内存，虽然这种情况实际发生的概率很低。<br/>
可用内置过程 <tt class="docutils literal"><span class="pre">GC_ref</span></tt> 和 <tt class="docutils literal"><span class="pre">GC_unref</span></tt> 将对应的string数据一直保存，避免GC收集掉。</p>

<p> <cite>$</cite> 过程可以将 cstrings 转换为一个 string：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">str</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello!&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">cstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Operator">=</span> <span class="Identifier">str</span>
<span class="Keyword">var</span> <span class="Identifier">newstr</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">cstr</span></pre>

<h2><a class="toc-backref" id="types-structured-types" href="#types-structured-types">Structured types(结构类型)</a></h2>
<p>数组、序列、元组、对象和集合都属于结构类型</p>
<h2><a class="toc-backref" id="types-array-and-sequence-types" href="#types-array-and-sequence-types">Array and sequence types(数组和序列类型)</a></h2>
<p>数组是一个均质类型，数组中的每个元素都是相同的类型。编译期数组总得有个确定的长度 (除了开放数组)。<br/>
数组能用任意的序数类型作为下标。<em>开放数组</em>参数 <tt class="docutils literal"><span class="pre">A</span></tt> 的下标只能是整数从 0  到 <tt class="docutils literal"><span class="pre">len(A)-1</span></tt>。<br/>
数组可以通过 <tt class="docutils literal"><span class="pre">[]</span></tt>来构造。</p>
<p>序列和数组类似，但长度可以动态变化的，用一个可增长的动态数组来实现。 <br/>
序列<tt class="docutils literal"><span class="pre">S</span></tt>的下标总是从  0  到 <tt class="docutils literal"><span class="pre">len(S)-1</span></tt>，同时进行边界检查了的。<br/>
序列可以在数组构造符 <tt class="docutils literal"><span class="pre">[]</span></tt> 前加上一个操作符  <tt class="docutils literal"><span class="pre">@</span></tt>来构造，另一个方法是调用内置过程 <tt class="docutils literal"><span class="pre">newSeq</span></tt></p>
<p>序列可以传递给需要 <em>open array(开放数组)</em>类型的过程参数.</p>
<p>如：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 数组下标从0到5</span>
  <span class="Identifier">IntSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 定义一个整数序列类型</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">IntSeq</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>  <span class="Comment"># 用[]构造 数组</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># @将数组变为一个序列(数组内容填充到序列中)</span></pre>
<p>内置过程 <tt class="docutils literal"><span class="pre">low()</span></tt>得到数组或序列的最小下标值，<tt class="docutils literal"><span class="pre">high()</span></tt> 过程得到最大下标值，<tt class="docutils literal"><span class="pre">len()</span></tt>得到长度。<br/>
对于序列或则开放数组来说，过程<tt class="docutils literal"><span class="pre">low()</span></tt> 总是返回0(第一个合法的下标值)<br/>
<tt class="docutils literal"><span class="pre">add()</span></tt> 过程或 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 操作符可将一个元素添加到序列中，删除并得到序列的最后一个元素可用过程 <tt class="docutils literal"><span class="pre">pop()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">x[i]</span></tt> 可读写<tt class="docutils literal"><span class="pre">x</span></tt>中的第i个元素</p>
<p>数组总是进行边界检查的(编译期和运行期)。可以加上编译指示或则在编译时加上 <tt class="docutils literal"><span class="pre">--boundChecks:off</span></tt> 编译命令关闭这个检查。</p>

<h2><a class="toc-backref" id="types-open-arrays" href="#types-open-arrays">Open arrays(开放数组)</a></h2>
<p>通常固定尺寸的数组总是不那么灵活的，过程应当能够处理不同尺寸的数组。<br/>
<span id="openarray_1">openarray开放数组</span> 类型就作这个用途，而且只能作为参数使用。<br/>
开放数组的下标永远是 <tt class="docutils literal"><span class="pre">int</span></tt> 类型，并从０开始。 <br/>
过程 <tt class="docutils literal"><span class="pre">len</span></tt>, <tt class="docutils literal"><span class="pre">low</span></tt> 和 <tt class="docutils literal"><span class="pre">high</span></tt> 也对开放数组适用。<br/>
任何数组只要元素类型是兼容的都可以传递给开放数组的参数，下标类型无所谓。另外数组序列也是可以传递的。</p>
<p>开放数组不支持嵌套，多维开放数组是不支持的，没必要而且效率也不高。</p>
<h2><a class="toc-backref" id="types-varargs" href="#types-varargs">Varargs(可变参数)</a></h2>
<p><tt class="docutils literal"><span class="pre">varargs</span></tt> 可变参数是一个开放数组参数的应用，允许传任意多的参数到过程中。<br/>
编译器隐含的将这个参数列表转变为一个数组：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># 上句会转换为：</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
<p>这个转换只发生在相应的参数是在过程参数列表中的最后一个才进行。<br/>
而且在转换的时候还能够进行类型转换：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># 上句转换为：</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
<p>上例中 <tt class="docutils literal"><span class="pre">$</span></tt> 在传给<tt class="docutils literal"><span class="pre">a</span></tt>的每个的变量上都应用了。 (注：<tt class="docutils literal"><span class="pre">$</span></tt> 应用到字符串上就是个空操作)</p>
<p>注意显式的构造一个数组传递给 <tt class="docutils literal"><span class="pre">varargs</span></tt> 参数，并不是将这个数组当成一个变量值，而是会将其直接展开：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">takeV</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">echo len(a)</span>

<span class="Identifier">takeV</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># takeV's T is &quot;int&quot;, 不是&quot;int数组&quot; 输出结果 3</span></pre>
<p><tt class="docutils literal"><span class="pre">varargs[expr]</span></tt> 是特殊处理的: <br/>它匹配任意的类型，但 <em>总是</em> 隐式的构造了一个数组。这样上面的例子中输出的将是1(当前实现有bug?)  <br/>
如此内置过程 <tt class="docutils literal"><span class="pre">echo</span></tt> proc 就能得到它期望的结果了:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">echo</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">...</span><span class="Punctuation">}</span>

<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
<span class="Comment"># 输出 &quot;@[1, 2, 3]&quot; 而不是 &quot;123&quot;</span></pre>

<h2><a class="toc-backref" id="types-tuples-and-object-types" href="#types-tuples-and-object-types">Tuples and object types(元组和对象)</a></h2>
<p>元组使用 <tt class="docutils literal"><span class="pre">()</span></tt> 来构造,其内字段的顺序必须符合定义时的顺序。 不同的元组只有字段的名称、类型以及顺序都相同时才认为它们是 <em>相等</em>的。</p>
<p>元组的赋值是值模式。对象的赋值是将拷贝其中的每个元素。当前不允许重载对象的赋值操作。</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 定义一个person元组:</span>
                                         <span class="Comment"># 由 name 和 age 构成</span>
<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># 同上作用，可读性差了:</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span></pre>
<p>字段的对齐实现方向是跟好的性能，兼容C编译器的做法(So你懂的，最好不要产生空洞 base一个字长为好)。</p>
<p>为了和 <tt class="docutils literal"><span class="pre">object</span></tt> 定义方式保存一致，在<tt class="docutils literal"><span class="pre">type</span></tt> 区块定义(元组可以直接在var中定义)的元组也可以用缩进的方式来定义，就不需要 <tt class="docutils literal"><span class="pre">[]</span></tt>了:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>   <span class="Comment"># 定义一个 person 元组</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">natural</span> </pre>
<p>对象比元组提供了更多的特性（继承和信息隐藏）。使用 <tt class="docutils literal"><span class="pre">of</span></tt> 操作符在运行期对象也能获知他们的类型</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inheritable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>   <span class="Comment"># 加 * 意味着 `name` 可以被其他的模块访问</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 没有 * 意味着这个字段是隐藏的</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># Student 是一个有 id 字段的 Person</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># true</span></pre>
<p>对象中加<tt class="docutils literal"><span class="pre">*</span></tt>的字段才能被其他的模块所访问。与元组不同，不同的对象类型是一定不相等的。<br/>
没有祖先的对象隐含的就是 <tt class="docutils literal"><span class="pre">final</span></tt>(不能被继承了) 的。<br/>
可用编译指示 <tt class="docutils literal"><span class="pre">inheritable</span></tt>  来创建一个可继承的对象，它的根不是来自 <tt class="docutils literal"><span class="pre">system.RootObj</span></tt></p>

<h2><a class="toc-backref" id="types-object-construction" href="#types-object-construction">Object construction(对象构造)</a></h2>
<p>对象构造表达式语法： <tt class="docutils literal"><span class="pre">T(fieldA: valueA, fieldB: valueB, ...)</span></tt><br/>
<tt class="docutils literal"><span class="pre">T</span></tt> 是某个 <tt class="docutils literal"><span class="pre">object</span></tt> 或 <tt class="docutils literal"><span class="pre">ref object</span></tt> 类型:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre>
<p>对于 <tt class="docutils literal"><span class="pre">ref object</span></tt> 类型来说，过程 <tt class="docutils literal"><span class="pre">system.new</span></tt> 会隐性的被调用</p>

<h2><a class="toc-backref" id="types-object-variants" href="#types-object-variants">Object variants(对象变量)</a></h2>
<p>运用对象继承模式在那些只需要简单的变量类型就太不灵活笨重了绝杀啊。</p>
<p>如:</p>
<pre><span class="Comment"># 例子演示Nim中的抽象语法树是如何模型化的</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># 枚举 节点类型</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># 带整数值的叶节点</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># 带浮点数的叶节点</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># 带字符串的叶节点</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># 加法</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># 减法</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># if语句</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># `kind` 字段就是个分辨器</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>

<span class="Comment"># 创建一个新的object：</span>
<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkIf</span><span class="Punctuation">,</span> <span class="Identifier">condition</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">)</span>
<span class="Comment"># 访问 n.thenPart 是合法的，因为上面创建的是 `nkIf` 分支，相应case下面的字段都存在的:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">thenPart</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">2.0</span><span class="Punctuation">)</span>

<span class="Comment"># 下面的语句将引发 `FieldError` 异常，因为:</span>
<span class="Comment"># n.kind的值不是 ``nkString``，只有nkString中才有strVal字段:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Comment"># 非法: 将抛出异常assignment to discriminant changes object branch:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkInt</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># 合法: 不改变对应的object的分支情况：</span>
<span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span></pre>
<p>例子中 <tt class="docutils literal"><span class="pre">kind</span></tt> 字段被称为 <span id="discriminator_1">discriminator(分辨器)</span>: kind如果被赋值，新值不能引起分支的改变。<br/>
如果需要改变分支，必须使用 <tt class="docutils literal"><span class="pre">system.reset</span></tt> 过程</p>
<h2><a class="toc-backref" id="types-set-type" href="#types-set-type">Set type(集合)</a></h2>
<p>集合的基础类型只能是序数类型，因为集合是用位向量来实现的。因此，其内部元素必须是有数的。</p>
<p>集合构造器: <tt class="docutils literal"><span class="pre">{}</span></tt>，这就是一个空集合，空集合兼容任何其他的集合类型。<br/>
构造器也能包含元素或则元素范围:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># 构造器中含有:</span>
                         <span class="Comment"># 字母， 'a' 到 'z'</span>
                         <span class="Comment"># 数字， '0' 到 '9'</span></pre>
<p>集合支持如下操作:</p>
<table border="1" class="docutils"><tbody><tr><th>操作</th><th>说明</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">A + B</span></tt></td><td>两个集合的并 of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A * B</span></tt></td><td>两个集合的交</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A - B</span></tt></td><td>两个集合的不同 (Ａ中存在，B中不存在的)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A == B</span></tt></td><td>两个集合是否相等</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt;= B</span></tt></td><td>子集关系(A 是 B 的子集或则等于 B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt; B</span></tt></td><td>真子集关系(A 是 B 的真子集)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e in A</span></tt></td><td>集合成员 (A中含有元素 e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e notin A</span></tt></td><td>A 中不含有元素 e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">contains(A, e)</span></tt></td><td>A 中含有元素 e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">card(A)</span></tt></td><td>A集合的势 (A中元素的数目)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">incl(A, elem)</span></tt></td><td>与 <tt class="docutils literal"><span class="pre">A = A + {elem}</span></tt>相同。在 A 中增加一个元素elem</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">excl(A, elem)</span></tt></td><td>与 <tt class="docutils literal"><span class="pre">A = A - {elem}</span></tt>相同。在 A 中减少一个元素elem</td></tr>
</tbody></table>

<h2><a class="toc-backref" id="types-reference-and-pointer-types" href="#types-reference-and-pointer-types">Reference and pointer types(引用和指针类型)</a></h2>
<p>引用 与其他语言中的指针类似，一种引入多对一的关系的途径。也就是说多个不同的引用能够指向同一块内存位置，并修改对应的内容。</p>
<p>Nim 区分 <span id="traced_1">traced(追踪)</span> 和 <span id="untraced_1">untraced(不追踪)</span> 的引用，不追踪的引用也被称为 <em>pointers(指针)</em>。<br/>
追踪的引用指向一个在GC堆上的对象；指针指向一个手动分配的对象或则某些已经在内存中被分配好的对象，
因此指针是 <em>unsafe(不安全)</em>的。 <br/>
但是对于某些低级操作(比如访问硬件) 指针是不可避免也是必须的。</p>
<p>追踪的引用用关键字 <strong>ref</strong> ，指针用关键字 <strong>ptr</strong> </p>

<p>空的[] 用来 derefer(提领) 一个引用，也就是得到这个引用指向的内容。<br/>
<tt class="docutils literal"><span class="pre">addr</span></tt> 过程返回某个变量的指针。</p>
<p><tt class="docutils literal"><span class="pre">.</span></tt> (访问一个 元组或对象的字段) 和 <tt class="docutils literal"><span class="pre">[]</span></tt> (数组/字符串/序列的操作符) 都是隐含的执行了被引用类型的提领操作：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># 不需要写成 n[].data，相反 n[].data 是极度不鼓励的写法！(为啥呢?)</span></pre><p>当前Nim实现中如果加上编译指示 <tt class="docutils literal"><span class="pre">{.experimental.}</span></tt>，则方法调用中的第一个参数将会自动执行derefer(提领)操作:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">depth</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">NodeObj</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">depth</span>
<span class="Comment"># 不需要写成 n[].depth </span></pre>
<p>为了简化结果类型检查，循环元组是不允许的:</p>
<pre><span class="Comment"># invalid recursion</span>
<span class="Keyword">type</span> <span class="Identifier">MyTuple</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">MyTuple</span><span class="Punctuation">]</span></pre>
<p>类似 <tt class="docutils literal"><span class="pre">T = ref T</span></tt> 是非法的类型定义.</p>
<p>作为一个扩展，<tt class="docutils literal"><span class="pre">对象</span></tt> 类型可以是匿名的，如果这个对象在一个type区块申明且是通过 <tt class="docutils literal"><span class="pre">ref object</span></tt> 或<tt class="docutils literal"><span class="pre">ptr object</span></tt> 来定义的。但一个对象只需要引用的语义时，这个特性就有用了(避免定义对象了，２合一，直接定义对象的引用类型):</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre>
   <p>内置过程 <tt class="docutils literal"><span class="pre">new</span></tt> 用来创建一个新的被追踪对象，同时设定了引用指向了这个对象。<br>过程<tt class="docutils literal"><span class="pre">alloc</span></tt>、 <tt class="docutils literal"><span class="pre">dealloc</span></tt> 和 <tt class="docutils literal"><span class="pre">realloc</span></tt> 用来分配不被追踪的对象(适用于指针)，
更多信息请参看<a class="reference external" href="system.html">system</a> 模块中相应说明。</p>
<p>空引用(未指向任何东西)的默认值为 <tt class="docutils literal"><span class="pre">nil</span></tt></p>
<p>当一个不追踪的对象中包含了被追踪的(如: 被追踪的引用、字符串或序列、有哪些类型是被自动GC的？)时必须非常小心。
为了将内存彻底释放，必须在手动释放未最终的内存前调用内置过程<tt class="docutils literal"><span class="pre">GCunref</span></tt> 来实现相应的被追踪的内存</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Data</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">]</span>

<span class="Comment"># 在堆上为 Data 分配内存:</span>
<span class="Keyword">var</span> <span class="Identifier">d</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">Data</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">alloc0</span><span class="Punctuation">(</span><span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">Data</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Comment"># 在被垃圾收集管理的堆上创建一个字符串：</span>
<span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Comment"># 告诉GC,这个字符串不再需要了</span>
<span class="Identifier">GCunref</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Comment"># 释放Data:</span>
<span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span></pre>
<p>如果不调用 <tt class="docutils literal"><span class="pre">GCunref</span></tt>过程，那么 <tt class="docutils literal"><span class="pre">d.s</span></tt> 字符串对应的内存将永远不会被释放。<br/>
例中有2个重要的过程：<br/>
 <tt class="docutils literal"><span class="pre">sizeof</span></tt> 过程返回一个类型或值所需的内存字节大小 。<br/>
 <tt class="docutils literal"><span class="pre">cast</span></tt> 操作后将强迫类型系统: 编译器被迫将 <tt class="docutils literal"><span class="pre">alloc0</span></tt> 过程返回的无类型指针看成是 <tt class="docutils literal"><span class="pre">ptr Data</span></tt>类型。<br/>
 Cast尽量只在不可避免的时候使用，打破了类型安全性，可能引起奇怪的bug以至崩溃。</p>
<p><strong>注意</strong>:  这个例子碰巧能正常运行，只是因为内存被初始化为0了(<tt class="docutils literal"><span class="pre">alloc0</span></tt> 代替了 <tt class="docutils literal"><span class="pre">alloc</span></tt> 过程): <tt class="docutils literal"><span class="pre">d.s</span></tt> 因此就被初始化为 <tt class="docutils literal"><span class="pre">nil</span></tt> 了，这样字符串赋值就能运行了。<br/>
当你需要在一个未被追踪的内存上混合GC的时候必须知道足够的底层细节才行，三思。</p>
<h2><a class="toc-backref" id="types-not-nil-annotation" href="#types-not-nil-annotation">Not nil annotation(Not nil申明)</a></h2>
<p><tt class="docutils literal"><span class="pre">nil</span></tt> 对应任意类型来说都是一个合法的值。
可以用<tt class="docutils literal"><span class="pre">not nil</span></tt> 来申明不接受nil作为合法的值：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">PObject</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">TObj</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>
  <span class="Identifier">TProc</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;not nil&quot;</span>

<span class="Comment"># 下面这句报错</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Keyword">nil</span><span class="Punctuation">)</span>

<span class="Comment"># 也报错。默认值是nil</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="types-memory-regions" href="#types-memory-regions">Memory regions(内存领域)</a></h2>
<p><tt class="docutils literal"><span class="pre">ref</span></tt> 和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 类型还可以有一个可选的 <tt class="docutils literal"><span class="pre">region(领域)</span></tt> 申明。领域必须是对象类型。</p>
<p>领域是很长有用的，在开发OS内核时用来隔离用户空间和内核空间(这只是个例子别想多了):</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Kernel</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">Userspace</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Comment"># 申明 a 为一个指向Stat的指针，但是领域是在Kernel</span>
<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Kernel</span> <span class="Keyword">ptr</span> <span class="Identifier">Stat</span>
<span class="Comment"># 申明 b 为一个指向Stat的指针，但是领域是在Userspace</span>
<span class="Keyword">var</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Userspace</span> <span class="Keyword">ptr</span> <span class="Identifier">Stat</span>

<span class="Comment"># 下面的语句，编译器将报错，这两个是兼容的:</span>
<span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span></pre>
<p>上面的例子充分的说明了 <tt class="docutils literal"><span class="pre">ptr</span></tt> 也可以作为二元操作符， <tt class="docutils literal"><span class="pre">region ptr T</span></tt> 就 <tt class="docutils literal"><span class="pre">ptr[region, T]</span></tt>的一个快捷方式</p>
<p><tt class="docutils literal"><span class="pre">ptr T</span></tt> 是任意 <tt class="docutils literal"><span class="pre">ptr[R, T]</span></tt>的子类型，无论 <tt class="docutils literal"><span class="pre">R</span></tt>是何种类型。</p>
<p>Furthermore the subtype relation of the region object types is lifted to the pointer types: If <tt class="docutils literal"><span class="pre">A &lt;: B</span></tt> then <tt class="docutils literal"><span class="pre">ptr[A, T] &lt;: ptr[B, T]</span></tt>. This can be used to model subregions of memory. As a special typing rule <tt class="docutils literal"><span class="pre">ptr[R, T]</span></tt> is not compatible to <tt class="docutils literal"><span class="pre">pointer</span></tt> to prevent the following from compiling:</p>
<pre><span class="Comment"># from system</span>
<span class="Keyword">proc</span> <span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span><span class="Punctuation">)</span>

<span class="Comment"># wrap some scripting language</span>
<span class="Keyword">type</span>
  <span class="Identifier">PythonsHeap</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">PyObjectHeader</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">rc</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span>
  <span class="Identifier">PyObject</span> <span class="Operator">=</span> <span class="Keyword">ptr</span><span class="Punctuation">[</span><span class="Identifier">PythonsHeap</span><span class="Punctuation">,</span> <span class="Identifier">PyObjectHeader</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">createPyObject</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PyObject</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;...&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">destroyPyObject</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PyObject</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;...&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">createPyObject</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Comment"># type error here, how convenient:</span>
<span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">foo</span><span class="Punctuation">)</span></pre><p>Future directions:</p>
<ul class="simple"><li>Memory regions might become available for  <tt class="docutils literal"><span class="pre">string</span></tt> and <tt class="docutils literal"><span class="pre">seq</span></tt> too.</li>
<li>Builtin regions like <tt class="docutils literal"><span class="pre">private</span></tt>, <tt class="docutils literal"><span class="pre">global</span></tt> and <tt class="docutils literal"><span class="pre">local</span></tt> will prove very useful for the upcoming OpenCL target.</li>
<li>Builtin &quot;regions&quot; can model <tt class="docutils literal"><span class="pre">lent</span></tt> and <tt class="docutils literal"><span class="pre">unique</span></tt> pointers.</li>
<li>An assignment operator can be attached to a region so that proper write barriers can be generated. This would imply that the GC can be implemented completely in user-space.</li>
</ul>

<h2><a class="toc-backref" id="types-procedural-type" href="#types-procedural-type">Procedural type(过程类型)</a></h2>
<p>过程类型在内部实现就是一个指向过程的指针， <tt class="docutils literal"><span class="pre">nil</span></tt> 因此也就可以赋值给任意过程类型。<br/>
Nim使用过程类型来实现函数编程</p>

<p>如:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">printItem</span><span class="Punctuation">)</span>  <span class="Comment"># 编译失败(调用约定不同，分别是默认的和cdecl)</span></pre><pre><span class="Keyword">type</span>
  <span class="Identifier">OnMouseMove</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">onMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 默认的调用约定(nimcall)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;x: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="StringLit">&quot; y: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span>

<span class="Comment"># 期望的是closure调用约定的</span>
<span class="Keyword">proc</span> <span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseMoveEvent</span><span class="Punctuation">:</span> <span class="Identifier">OnMouseMove</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 'onMouseMove' 是默认的调用约定(nimcall)，兼容'closure'的</span>
<span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">onMouseMove</span><span class="Punctuation">)</span></pre>
<p>过程类型的兼容性的特别处：只有是相同的调用约定才有可能是兼容的(还需要调用参数的类型、顺序)。 <br/>
例外：调用约定为 <tt class="docutils literal"><span class="pre">nimcall</span></tt> 的过程类型可以传递给期望约定为 <tt class="docutils literal"><span class="pre">closure</span></tt>的。</p>
<p>Nim 支持如下的调用约定:</p>
<dl class="docutils"><dt><span id="nimcall_1">nimcall</span></dt>
<dd>Nim调用时的默认调用约定，和 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 一样，但是只有C才支持 <tt class="docutils literal"><span class="pre">fastcall</span></tt></dd>
<dt><span id="closure_1">closure</span></dt>
<dd><strong>过程类型</strong>的默认调用约定(是过程类型，不是过程)。<br/>
说明这个过程有一个隐藏的隐含参数(环境变量群)。<br/>
本约定的过程变量占用两个机器字长(两指针)：一指向过程，另一指向隐含传递的环境变量群</dd>
<dt><span id="stdcall_1">stdcall</span></dt>
<dd>MS定义的，nim生成的c代码中的过程申明中加上了 <tt class="docutils literal"><span class="pre">__stdcall</span></tt> 关键字(MS真心不得人心啊)</dd>
<dt><span id="cdecl_1">cdecl</span></dt>
<dd>C编译器的调用约定。 windows下生成的c代码中的过程申明加上了 <tt class="docutils literal"><span class="pre">__cdecl</span></tt> 关键字(又是MS)</dd>
<dt><span id="safecall_1">safecall</span></dt>
<dd>又是MS创造。nim生成的c代码中的过程申明中加上了 <tt class="docutils literal"><span class="pre">__safecall</span></tt> 关键字。<br/>
<em>safe</em> 的意思是调用时所有的硬件寄存器应该被压入到硬件栈中. </dd>
<dt><span id="inline_1">inline</span></dt>
<dd>建议性的作用。建议展开相应的代码，而不是生成一次调用过程。<br/>
实现时会在c的相应的函数申明加上 <tt class="docutils literal"><span class="pre">__inline</span></tt>。<br/>
但这只是给C编译器的建议，C编译器有自己的判断。</dd>
<dt><span id="fastcall_1">fastcall</span></dt>
<dd>为了快，不同的C编译器有不同的解释。因此只是在C代码中加上 <tt class="docutils literal"><span class="pre">__fastcall</span></tt></dd>
<dt><span id="syscall_1">syscall</span></dt>
<dd>就是C中的 <tt class="docutils literal"><span class="pre">__syscall</span></tt> ，用于中断(类似Dos Int 21)</dd>
<dt><span id="noconv_1">noconv</span></dt>
<dd>不增加任何的调用约定，只用C编译器默认的调用约定方式。<br/>
因为Nim的默认调用是用 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 来加速，如你不希望用任何约定，可用这个约定(绕)</dd>
</dl>
<p>大部分调用约定只是给windows 32位平台的(MS又立功)</p>
<p>能将一个过程赋值给一个过程变量必须满足下面至少一条:</p>
<ol class="simple">
<li>过程在当前模块中</li>
<li>过程带 <tt class="docutils literal"><span class="pre">procvar</span></tt> 编译指示 (见 <a class="reference external" href="#procvar-pragma">procvar pragma</a>).</li>
<li>过程的调用约定不是 <tt class="docutils literal"><span class="pre">nimcall</span></tt></li>
<li>过程是匿名的</li>
</ol>
<p>The rules' purpose is to prevent the case that extending a non-<tt class="docutils literal"><span class="pre">procvar</span></tt> procedure with default parameters breaks client code.</p>
<p>The default calling convention is <tt class="docutils literal"><span class="pre">nimcall</span></tt>, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt>, otherwise it has the calling convention <tt class="docutils literal"><span class="pre">nimcall</span></tt>.</p>

<h2><a class="toc-backref" id="types-distinct-type" href="#types-distinct-type">Distinct type(Distinct类型)</a></h2>
<p><tt class="docutils literal"><span class="pre">distinct</span></tt> 类型是从基础类型中继承来的新类型，但是不兼容基础类型。 <br/>就是为了避免在基础类型和子类型之间的隐含转换关系)，显式的转换是可以的。</p>

<h3><a class="toc-backref" id="distinct-type-modelling-currencies" href="#distinct-type-modelling-currencies">Modelling currencies(货币的例子)</a></h3>
<p>显然不同的货币是不能直接计算的，Distinct类型就是一个绝佳的建立模型工具：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Dollar</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>
  <span class="Identifier">Euro</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Euro</span>

<span class="Identifier">echo</span> <span class="Identifier">d</span> <span class="Operator">+</span> <span class="DecNumber">12</span>
<span class="Comment"># 错误: 不能将整数和 ``Dollar`` 类型直接相加</span></pre>
<p>不幸用<tt class="docutils literal"><span class="pre">d + 12.Dollar</span></tt>也是不行的, 因为 <tt class="docutils literal"><span class="pre">Dollar</span></tt>之间没有定义<tt class="docutils literal"><span class="pre">+</span></tt> 操作，但是<tt class="docutils literal"><span class="pre">d.int + 12</span></tt>是可行的。<br/>
这里我们定义一个dollars的 <tt class="docutils literal"><span class="pre">+</span></tt> 操作(还有int + Dollar等等...):</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre>
  <p>继续定义需要的相互乘法、除法等:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">y</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">...</span></pre>
<p>要定义的如此多，简单且繁杂。崩溃了。<br/>
但是 救星编译指示 <span id="borrow_1">borrow</span> 来解决这个问题：</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<p> <tt class="docutils literal"><span class="pre">borrow</span></tt> 编译指示让编译器按照distinct类型的基础类型来实现相应的过程，这样就不要产生代码了(记得么显式的转换是允许的)</p>
<p>但是即使这样也繁杂的，因为货币种类可多了，每个都这么来一遍也要暴走的。<br/>
此时用 <a class="reference external" href="#templates">templates</a>可破</p>

<pre><span class="Keyword">template</span> <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  
  <span class="Comment"># unary operators:</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;=</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Identifier">typ</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">base</span>
  <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>
  <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">)</span>
  <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>

<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Euro</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span></pre>
<p>borrow 编译指示也可以在申明distinct类型时直接指定需要borrow的操作:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  
  <span class="Identifier">Bar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">Foo</span>

<span class="Keyword">var</span> <span class="Identifier">bb</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Bar</span>
<span class="Identifier">new</span> <span class="Identifier">bb</span>
<span class="Comment"># field access now valid</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">90</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span></pre>
<p>当前只支持.操作(了胜于无)</p>

<h3><a class="toc-backref" id="distinct-type-avoiding-sql-injection-attacks" href="#distinct-type-avoiding-sql-injection-attacks">Avoiding SQL injection attacks(避免SQL注入攻击)</a></h3>
<p>没意思的，只是将SQL string语句安全化下。</p>

<h2><a class="toc-backref" id="types-void-type" href="#types-void-type">Void type(void类型)</a></h2>
<p><tt class="docutils literal"><span class="pre">void</span></tt> 类型说明类型的不需要。<br/>
参数为void类型的此参数被当成不存在的。过程返回值为void的表示过程没有返回值：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">nothing</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">void</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;ha&quot;</span>

<span class="Identifier">nothing</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># 输出 &quot;ha&quot;</span></pre>

<p><tt class="docutils literal"><span class="pre">void</span></tt>类型在范型代码也有用哦：</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">T</span> <span class="Keyword">is</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">intProc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">emptyProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">intProc</span><span class="Punctuation">,</span> <span class="DecNumber">12</span><span class="Punctuation">)</span>
<span class="Identifier">callProc</span><span class="Punctuation">(</span><span class="Identifier">intProc</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Comment"># 会被自动推导出来，不写[int]也行</span>
<span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">void</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">emptyProc</span><span class="Punctuation">)</span></pre>
<p>然而 <tt class="docutils literal"><span class="pre">void</span></tt> 类型在范型代码中不能被自动推导出:</p>
<pre><span class="Identifier">callProc</span><span class="Punctuation">(</span><span class="Identifier">emptyProc</span><span class="Punctuation">)</span>
<span class="Comment"># Error: type mismatch: got (proc ())</span>
<span class="Comment"># but expected one of:</span>
<span class="Comment"># callProc(p: proc (T), x: T)</span></pre>
<p><tt class="docutils literal"><span class="pre">void</span></tt> 类型只能用在参数和返回值上</p>

<h1><a class="toc-backref" id="type-relations" href="#type-relations">Type relations(类型关系)</a></h1>
<p>下面定义了几个类型的关系，在类型检查时编译器按照这个关系进行检查。</p>

<h2><a class="toc-backref" id="type-relations-type-equality" href="#type-relations-type-equality">Type equality(类型相等)</a></h2>
<p>Nim中大多数类似是用结构类型是否相等来判断，但 对象 枚举 和 distinct类型是根据类型名字是否相同来判断。<br/>
 具体的是下面的算法用来判断是否类型相等:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">,</span>
                   <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">PType</span> <span class="Operator">*</span> <span class="Identifier">PType</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># leaf type: kinds identical; nothing more to check</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">,</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>

<span class="Keyword">proc</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">PType</span> <span class="Operator">*</span> <span class="Identifier">PType</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span></pre>
  <p>因为可以有自定义的类型(有循环引用的情况)，因此上面的算法需要一个集合 <tt class="docutils literal"><span class="pre">s</span></tt> 来检测这种情况</p>

<h2><a class="toc-backref" id="type-relations-type-equality-modulo-type-distinction" href="#type-relations-type-equality-modulo-type-distinction">Type equality modulo type distinction(不考虑distinct的类型相等)</a></h2>
<p>下面的算法在不考虑distinct类型时判断是否相等决定。为了简化伪码，集合 <tt class="docutils literal"><span class="pre">s</span></tt> 省略了:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># leaf type: kinds identical; nothing more to check</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>
  <span class="Keyword">elif</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">elif</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>

<h2><a class="toc-backref" id="type-relations-subtype-relation" href="#type-relations-subtype-relation">Subtype relation(子类型关系)</a></h2>
<p>如果对象 <tt class="docutils literal"><span class="pre">a</span></tt> 继承于 <tt class="docutils literal"><span class="pre">b</span></tt>, 那么<tt class="docutils literal"><span class="pre">a</span></tt> 就是 <tt class="docutils literal"><span class="pre">b</span></tt>的子类型。判断算法扩展到 <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">ptr</span></tt>:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">:</span>
      <span class="Keyword">var</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Keyword">while</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">aa</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">aa</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="type-relations-convertible-relation" href="#type-relations-convertible-relation">Convertible relation(可转换关系)</a></h2>
<p>如果下面的过程返回的是true,那么<tt class="docutils literal"><span class="pre">a</span></tt> 是可以 <strong>隐式</strong> 的转换到类型 <tt class="docutils literal"><span class="pre">b</span></tt>的:</p>
<pre><span class="Comment"># XXX range types?</span>
<span class="Keyword">proc</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
  <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">:</span>     <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int8</span><span class="Punctuation">,</span> <span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">uint</span><span class="Punctuation">,</span> <span class="Identifier">uint8</span><span class="Punctuation">,</span> <span class="Identifier">uint16</span><span class="Punctuation">,</span>
                             <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int8</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int16</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int32</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint8</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint16</span><span class="Punctuation">,</span> <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint16</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint32</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float32</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float64</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">seq</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
  <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span> <span class="Operator">==</span> <span class="Identifier">char</span> <span class="Keyword">and</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">cstring</span>
  <span class="Keyword">of</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">pointer</span>
  <span class="Keyword">of</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span></pre>
<p>如果下面的算法返回true,那么类型 <tt class="docutils literal"><span class="pre">a</span></tt> 是可以 <strong>显式</strong> 的转换到类型 <tt class="docutils literal"><span class="pre">b</span></tt>的:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isOrdinal</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">isExplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">if</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span></pre>

 <p>可转换关系也可以自定义一个 <span id="converter_1">转换过程converter</span> 进行</p>
<pre><span class="Keyword">converter</span> <span class="Identifier">toInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">chr</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="CharLit">'a'</span>

<span class="Comment"># 隐式转换</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span>
<span class="Comment"># 显式转换了,调用自定义的toInt转换器</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Operator">.</span><span class="Identifier">toInt</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span></pre><p>The type conversion <tt class="docutils literal"><span class="pre">T(a)</span></tt> is an L-value if <tt class="docutils literal"><span class="pre">a</span></tt> is an L-value(不明白，左值可以赋值了么?How) and <tt class="docutils literal"><span class="pre">typeEqualsOrDistinct(T, type(a))</span></tt> holds.</p>

<h2><a class="toc-backref" id="type-relations-assignment-compatibility" href="#type-relations-assignment-compatibility">Assignment compatibility(赋值的兼容性)</a></h2>
<p>表达式 <tt class="docutils literal"><span class="pre">b</span></tt> 能赋给表达式 <tt class="docutils literal"><span class="pre">a</span></tt>(即 b = a) 的条件是，<tt class="docutils literal"><span class="pre">a</span></tt> 是 <cite>左值</cite> 而且 <tt class="docutils literal"><span class="pre">isImplicitlyConvertible(b.typ, a.typ)</span></tt> 是可行的</p>

<h1><a class="toc-backref" id="overloading-resolution" href="#overloading-resolution">Overloading resolution(重载裁决)</a></h1>
<p>在调用 <tt class="docutils literal"><span class="pre">p(args)</span></tt> 时，编译器将选择最佳的过程 <tt class="docutils literal"><span class="pre">p</span></tt>。如果匹配程度最优的过程存在多个则报错。</p>
<p>实参中的每个都需要进行匹配，并且匹配程度区分出了多个层次。<br/>
假定 <tt class="docutils literal"><span class="pre">f</span></tt> 是过程的形参的类型，<tt class="docutils literal"><span class="pre">a</span></tt> 是调用时实参的类型</p>
<ol class="simple"><li>Exact match(精确匹配): <tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">f</span></tt> 同类型</li>
<li>Literal match(文本匹配):<br/>
* <tt class="docutils literal"><span class="pre">a</span></tt> 是一个整数的文本值,且值为 <tt class="docutils literal"><span class="pre">v</span></tt> 同时 <tt class="docutils literal"><span class="pre">f</span></tt> 是有符号或则无符号整数类型 并且<tt class="docutils literal"><span class="pre">v</span></tt> 在<tt class="docutils literal"><span class="pre">f</span></tt>的有效值范围内。 <br/>
 * <tt class="docutils literal"><span class="pre">a</span></tt> 是一个浮点数的文本值,且值为<tt class="docutils literal"><span class="pre">v</span></tt> 同时 <tt class="docutils literal"><span class="pre">f</span></tt> 是浮点类型 并且 <tt class="docutils literal"><span class="pre">v</span></tt> 在 <tt class="docutils literal"><span class="pre">f</span></tt>的有效值范围内。</li>
<li>Generic match(范型匹配): <tt class="docutils literal"><span class="pre">f</span></tt> 是范型  <tt class="docutils literal"><span class="pre">a</span></tt> 来匹配, 如 <tt class="docutils literal"><span class="pre">a</span></tt> 是 <tt class="docutils literal"><span class="pre">int</span></tt> ， <tt class="docutils literal"><span class="pre">f</span></tt> 是范型类型 (如 <tt class="docutils literal"><span class="pre">[T]</span></tt> or <tt class="docutils literal"><span class="pre">[T: int|char]</span></tt></li>
<li>Subrange or subtype match(子区间或子类型匹配): <tt class="docutils literal"><span class="pre">a</span></tt> is a <tt class="docutils literal"><span class="pre">range[T]</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt> matches <tt class="docutils literal"><span class="pre">f</span></tt> exactly. Or: <tt class="docutils literal"><span class="pre">a</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">f</span></tt>.</li>
<li>Integral conversion match: <tt class="docutils literal"><span class="pre">a</span></tt> 能转到为 <tt class="docutils literal"><span class="pre">f</span></tt> 且 <tt class="docutils literal"><span class="pre">f</span></tt> 和 <tt class="docutils literal"><span class="pre">a</span></tt> 是整数或浮点类型。</li>
<li>Conversion match(转换匹配): <tt class="docutils literal"><span class="pre">a</span></tt> 能转化为 <tt class="docutils literal"><span class="pre">f</span></tt>, 可能是通过用户自定义的一个 <tt class="docutils literal"><span class="pre">converter</span></tt></li>
</ol>
<p>上述的匹配优先级从上至下依次递减：精确匹配最优先。<br/>
<tt class="docutils literal"><span class="pre">count(p, m)</span></tt> 返回调用p适合目录m的数量(0或1)。如果下面的算法返回true,说明调用 <tt class="docutils literal"><span class="pre">p</span></tt> 比 <tt class="docutils literal"><span class="pre">q</span></tt>更适合:<pre>
for each matching category m in [&quot;exact match&quot;, &quot;literal match&quot;,
                                &quot;generic match&quot;, &quot;subtype match&quot;,
                                &quot;integral match&quot;, &quot;conversion match&quot;]:
  if count(p, m) &gt; count(q, m): return true
  elif count(p, m) == count(q, m):
    discard &quot;continue with next category m&quot;
  else:
    return false
return &quot;ambiguous&quot;</pre>
</p>
<p>一些例子:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int16</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int16&quot;</span>

<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int16</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int16&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span></pre>
<p>如果算法返回 &quot;ambiguous&quot; 接下来执行去模糊的操作:<br/>
如果调用实参 <tt class="docutils literal"><span class="pre">a</span></tt> 通过子类型转换都匹配了<tt class="docutils literal"><span class="pre">p</span></tt>的类型<tt class="docutils literal"><span class="pre">f</span></tt> 和<tt class="docutils literal"><span class="pre">q</span></tt>的类型 <tt class="docutils literal"><span class="pre">g</span></tt> , 此时需要考虑继承的深度(越子的子类型优先):</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">A</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">B</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">A</span>
  <span class="Identifier">C</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">B</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;A&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;B&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">C</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Comment"># 没问题，调用 'B', 而不是 'A'，因为B是A的子类型</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span>

<span class="Comment">#pp(1)</span>
<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;A B&quot;</span>
<span class="Comment">#pp(2)</span>
<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;B A&quot;</span>

<span class="Comment"># 这个时候晕了,第一个参数优选2,第二个参数预先1:</span>
<span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span></pre>
<p>对范型匹配来说，越具体的匹配类型优先:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref ref T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">int</span>
<span class="Comment"># gen1: 明显不对, gen2: T=int gen3: T=ref int；因此选更具体的gen2</span>
<span class="Identifier">gen</span><span class="Punctuation">(</span><span class="Identifier">ri</span><span class="Punctuation">)</span> <span class="Comment"># &quot;ref T&quot;</span>
</pre>

<h2><a class="toc-backref" id="overloading-resolution-overloading-based-on-var-t" href="#overloading-resolution-overloading-based-on-var-t">Overloading based on 'var T'</a></h2>
<p>如果形参 <tt class="docutils literal"><span class="pre">f</span></tt> 是 <tt class="docutils literal"><span class="pre">var T</span></tt> 那么<tt class="docutils literal"><span class="pre">var T</span></tt> 优先于 <tt class="docutils literal"><span class="pre">T</span></tt> 的<br/>
<pre>
proc test(a : var int) = echo "var int"
proc test(a : int) = echo "int"
var a = 0
test(10) #int
test(a)  #var int
</pre>
</p>

<h2><a class="toc-backref" id="overloading-resolution-automatic-dereferencing" href="#overloading-resolution-automatic-dereferencing">Automatic dereferencing(没意思)</a></h2><p><a class="reference external" href="experimental pragma">experimental mode</a> 激活才有用</p>

<h2><a class="toc-backref" id="overloading-resolution-lazy-type-resolution-for-expr" href="#overloading-resolution-lazy-type-resolution-for-expr">Lazy type resolution for expr(expr的延迟类型裁决)</a></h2>
<p>简单一句话: template或则macro都是在具体化的时候才进行相应的表达式裁决。<br/>因此下面的程序是没问题的，因为template/macro的body就是一个discard。</p>
<pre><span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span></pre>
<p>参数<tt class="docutils literal"><span class="pre">expr</span></tt>能匹配任何调用参数的。</p>
<p>但是，得当心。一旦重载需要裁决时，就需要看这个具体的expr的内容了：</p>
<pre><span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">rem</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Comment"># template没问题</span>
<span class="Comment"># 但[T]需要裁决unresolvedExpression(undeclaredIdentifier)的返回值的</span>
<span class="Comment"># 因此就触发错误了.</span>
<span class="Comment"># undeclared identifier: 'unresolvedExpression'</span>
<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span>
</pre>
<p>只有<tt class="docutils literal"><span class="pre">expr</span></tt>是延迟裁决的，<tt class="docutils literal"><span class="pre">stmt</span></tt> 和 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 不是的。</p>

<h2><a class="toc-backref" id="overloading-resolution-varargs-matching" href="#overloading-resolution-varargs-matching">Varargs matching</a></h2><p>见 <a class="reference external" href="#varargs">Varargs</a>. </p>

<h1><a class="toc-backref" id="statements-and-expressions" href="#statements-and-expressions">Statements and expressions(语句和表达式)</a></h1>
<p>Nim中：语句没有值，表达式有值。但是有些表达式也是语句。</p>
<p>语句分为 <span id="simple-statements_1">简单语句</span> 和 <span id="complex-statements_1">复杂语句</span>。<br/>
 * 简单语句中不包含其他语句，如赋值、调用或 <tt class="docutils literal"><span class="pre">return</span></tt> 语句<br/>
* 复杂语句中可以包含其他的语句</p>
<h2><a class="toc-backref" id="statements-and-expressions-statement-list-expression" href="#statements-and-expressions-statement-list-expression">Statement list expression(语句列表表达式)</a></h2>
<p>语句列表表达式看上去是这样的 <tt class="docutils literal"><span class="pre">(stmt1; stmt2; ...; ex)</span></tt>。<br/>
它的类型是最后的<tt class="docutils literal"><span class="pre">ex(表达式)</span></tt>的类型，其他的stmt语句必须是<tt class="docutils literal"><span class="pre">void</span></tt>类型的(可以用 <tt class="docutils literal"><span class="pre">discard</span></tt> 来达成)<br/>
它也不会引入一个新的空间
<pre>
proc haha(s:string) = echo s
var a = (haha("bj");var c=12;11)
echo c  #输出12,c还是在现在的这个空间中
</pre></p>
<h2><a class="toc-backref" id="statements-and-expressions-discard-statement" href="#statements-and-expressions-discard-statement">Discard statement(Discard语句)</a></h2>
<p>例如:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 放弃 `p` 的返回值</span></pre>
<p><tt class="docutils literal"><span class="pre">discard</span></tt> 语句会评估它的表达式(for side-effects)并且抛弃这个表达式的值</p>
<p>不使用discard语句而忽略过程的返回值，编译时将报错</p>
<p>如果过程或迭代器申明时已经增加了编译指示<span id="discardable_1">discardable</span> 那么它的返回值是可以隐式的被忽略的</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 合法了</span></pre>
<p>空的 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句为一个空语句，常用来占位(类似python中的pass) :)</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre>
<h2><a class="toc-backref" id="statements-and-expressions-var-statement" href="#statements-and-expressions-var-statement">Var statement(var语句)</a></h2>
<p>Var 语句申明且初始化局部或全局变量。可用逗号分隔同时申明多个同类型的变量:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre>
  <p>如果变量在申明的时候有一个明确的初始值，那么类型可以省略: 它的类型等于初始表达式的类型。<br/>
  如果没有初始化的表达式，那么变量都初始化为一个默认的值。 <br/>
  不同的类型的有不同的初始值，这些初始值在二进制层面都是0 :)</p>
<table border="1" class="docutils"><tr><th>类型</th><th>默认值</th></tr>
<tr><td>整型</td><td>0</td></tr>
<tr><td>浮点</td><td>0.0</td></tr>
<tr><td>字符</td><td>'\0'</td></tr>
<tr><td>布尔</td><td>false</td></tr>
<tr><td>引用或指针</td><td>nil</td></tr>
<tr><td>过程类型</td><td>nil</td></tr>
<tr><td>序列</td><td>nil (<em>不是</em> <tt class="docutils literal"><span class="pre">@[]</span></tt>)</td></tr>
<tr><td>字符串</td><td>nil (<em>不是</em> &quot;&quot;)</td></tr>
<tr><td>tuple[x: A, y: B, ...]</td><td>(default(A), default(B), ...) (对象也类似)</td></tr>
<tr><td>array[0..., T]</td><td>[default(T), ...]</td></tr>
<tr><td>range[T]</td><td>default(T); !可能在range的范围外 (var a: range[2..5];a的默认值是0)!</td></tr>
<tr><td>T = enum</td><td>cast[T](0); !可能是一个非法的值!</td></tr>
</table>
<p>为了性能高那么点，可以用编译指示<span id="noinit_1">noinit</span> 来禁用掉隐含的初始化过程:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noInit</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1023</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span></pre>
  <p>如果一个过程也用编译指示 <tt class="docutils literal"><span class="pre">noinit</span></tt> 说明它的隐含变量 <tt class="docutils literal"><span class="pre">result</span></tt> 没有进行隐含的初始化:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">returnUndefinedValue</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noinit</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre>
<p>这个隐含的初始化过程也可以使用编译指示 <span id="requiresinit_1">requiresInit</span> 来禁用，此时编译器需要这个变量的明确初始化过程了。<br/>
但是它是通过 <span id="control-flow-analysis_1">流程分析</span> 来保证这个变量被初始化：</p>
<pre>
type
  MyObject = object {.requiresInit.}
  AObject = object 
proc p() =
  var x : MyObject
  var y : AObject
  echo y  <span class="Comment">#合法,输出()</span>
  <span class="Comment">#Warning: Cannot prove that 'x' is initialized. </span>
  <span class="Comment">#This will become a compile time error in the future. [ProveInit]</span>
  echo x  <span class="Comment">#非法,x没有被初始化,现在的Nim实现中只是警告.</span>
p()
</pre>
<h2><a class="toc-backref" id="statements-and-expressions-let-statement" href="#statements-and-expressions-let-statement">let statement(let语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">let</span></tt>　语句和var语句类似，但是必须有个明确的初始化过程。同时这个变量不是左值，因此不能传递给过程中的<tt class="docutils literal"><span class="pre">var</span></tt>参数。<br/>
同时这个变量也不能赋新的值。</p>
<h2><a class="toc-backref" id="statements-and-expressions-tuple-unpacking" href="#statements-and-expressions-tuple-unpacking">Tuple unpacking(元组解箱)</a></h2>
<p>元组解箱只能在 <tt class="docutils literal"><span class="pre">var</span></tt> 或 <tt class="docutils literal"><span class="pre">let</span></tt> 语句中。<tt class="docutils literal"><span class="pre">_</span></tt> 可以用来忽略元组中的部分项:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>

<h2><a class="toc-backref" id="statements-and-expressions-const-section" href="#statements-and-expressions-const-section">Const section</a></h2>
<p><span id="constants_1">Constants(常量)</span> 的值不能改变。编译器必须能在编译期确定常量的值。</p>
<p>Nim有一个复杂的编译期评估器，因此在const表达式中可以用没有side-effect影响的过程来赋值：</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span>
<span class="Keyword">const</span>
  <span class="Identifier">constEval</span> <span class="Operator">=</span> <span class="Identifier">contains</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">)</span> <span class="Comment"># 在编译期计算!</span></pre>
  <p>能编译期计算的场景如下:</p>
<ol class="simple">
<li>立即数文本可以</li>
<li>类型转换可以</li>
<li>没有side-effects(见<a class="reference external" href="#nosideeffect-pragma">noSideEffect编译指示</a>)影响的过程<tt class="docutils literal"><span class="pre">p(X)</span></tt>，且参数 <tt class="docutils literal"><span class="pre">X</span></tt> 在编译期也能计算出来</li>
</ol>
<p>常量值不能是 <tt class="docutils literal"><span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">var</span></tt> 或 <tt class="docutils literal"><span class="pre">object</span></tt>类型，也不能包含这些类型(常量可以是结构啊这样结构中也不能包含这些类型)。</p>

<h2><a class="toc-backref" id="statements-and-expressions-static-statement-expression" href="#statements-and-expressions-static-statement-expression">Static statement/expression(Static语句/表达式)</a></h2>
<p>static语句/表达式用来强制在编译期进行评估，即使这个代码有side effects:</p>
<pre><span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;echo at compile time&quot;</span></pre><p>如果编译器不能在编译期将正确评估，将抛出一个static错误。</p>
<p>当前实现中编译期评估有些限制：代码中包含 <tt class="docutils literal"><span class="pre">cast</span></tt> 或调用了外部函数接口的不能评估。<br/>
后续版本可能在编译期时支持 FFI。</p>

<h2><a class="toc-backref" id="statements-and-expressions-if-statement" href="#statements-and-expressions-if-statement">If statement(If语句)</a></h2>
<p>如：</p>
<pre><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>

<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;Andreas&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;What a nice name!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Don't you have a name?&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Boring name...&quot;</span><span class="Punctuation">)</span></pre>
  <p> <tt class="docutils literal"><span class="pre">if</span></tt> 语句是一种简单的流程分支语句：<br/>
  如果关键字 <tt class="docutils literal"><span class="pre">if</span></tt>后的表达式评估结果为 true 那么 <tt class="docutils literal"><span class="pre">:</span></tt> 后的语句将被执行。<br/>
  否则 <tt class="docutils literal"><span class="pre">elif</span></tt> 接着评估(如果有 <tt class="docutils literal"><span class="pre">elif</span></tt> 分支)，同样如果这个elif评估结果为true,则<tt class="docutils literal"><span class="pre">:</span></tt> 后的语句将被执行。<br/>
  如此一直持续到最后一个 <tt class="docutils literal"><span class="pre">elif</span></tt>。<br/>
  如果全部条件都评估失败，则 <tt class="docutils literal"><span class="pre">else</span></tt> 部分将执行，如果没有 <tt class="docutils literal"><span class="pre">else</span></tt> 部分，将接着执行 <tt class="docutils literal"><span class="pre">if</span></tt> 语句后的其他语句。</p>
<p><tt class="docutils literal"><span class="pre">if</span></tt> 语句有一个精巧的空间，新空间从<tt class="docutils literal"><span class="pre">if</span></tt>/<tt class="docutils literal"><span class="pre">elif</span></tt> 条件开始，相应的内容结束:</p>
<pre><span class="Keyword">if</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;(\w+)=\w+&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;key &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="StringLit">&quot; value &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">elif</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;new m in this scope&quot;</span> <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Comment"># 'm' not declared here</span></pre>
  <p>例子中空间作用范围由 <tt class="docutils literal"><span class="pre">{| |}</span></tt>包裹起来的。{| |}只是说明，不是真的需要写的.</p>

<h2><a class="toc-backref" id="statements-and-expressions-case-statement" href="#statements-and-expressions-case-statement">Case statement(Case语句)</a></h2>
<p>如:</p>
<pre><span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;permission denied&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;please yourself&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;unknown command&quot;</span><span class="Punctuation">)</span>

<span class="Comment"># of分支也可以缩进，case后面的冒号是可选的</span>
<span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;permission denied&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;please yourself&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;unknown command&quot;</span><span class="Punctuation">)</span></pre>
  <p> <tt class="docutils literal"><span class="pre">case</span></tt> 后的表达式将被评估，接下去的of语句的<em>slicelist</em>覆盖了这个表达式的值的话，这个对应的of语句将被执行。<br/>
  如果这个值不在任何一个of的<em>slicelist</em>中，那么<tt class="docutils literal"><span class="pre">else</span></tt> 部分将执行。<br/>
  如此时不存在 <tt class="docutils literal"><span class="pre">else</span></tt> 部分那么一个将抛出一个<em>静态</em>(不是动态的请注意!)错误。<br/>
  为了尽可能的减少静态错误，最少加上一个<tt class="docutils literal"><span class="pre">else</span></tt>部分及时内部只是一个<tt class="docutils literal"><span class="pre">discard</span></tt>语句。</p>
<p>对于case的表达式类型不是序数类型的，<tt class="docutils literal"><span class="pre">else</span></tt> 部分是必须要的</p>
<p>特例：<tt class="docutils literal"><span class="pre">of</span></tt>分支中的表达式可以是一个set或数组构造器，他们会被扩展为各自包含的元素的列表:</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">SymChars</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span>

<span class="Comment"># 等于下面的结果:</span>
<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span></pre>

<h2><a class="toc-backref" id="statements-and-expressions-when-statement" href="#statements-and-expressions-when-statement">When statement(When语句)</a></h2><p>如:</p>
<pre><span class="Keyword">when</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on a 16 bit system!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on a 32 bit system!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on a 64 bit system!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot happen!&quot;</span><span class="Punctuation">)</span></pre>
  <p><tt class="docutils literal"><span class="pre">when</span></tt> 语句完全和 <tt class="docutils literal"><span class="pre">if</span></tt> 语句一样，除了(你懂的):</p>
<ul class="simple"><li>每个条件表达式必须是bool类型的const表达式</li>
<li>每个分支语句不会创建一个新的空间(if语句有).</li>
<li>分支表达式评估为true的才会被编译，false的根本就不看</li>
</ul>
<p><tt class="docutils literal"><span class="pre">when</span></tt> 语句实现了条件编译。<br/>
一个语法糖, 在<tt class="docutils literal"><span class="pre">object</span></tt>定义中 <tt class="docutils literal"><span class="pre">when</span></tt> 也是可用的。</p>
<pre>
type
  A = object of RootObj
    one : int
    when sizeof(int) == 2:
      two : int
    elif sizeof(int) == 4:
      four : int
    elif sizeof(int) == 8:
      eight : int

var a : A = A(eight : 121)
echo a.four #编译错误
</pre>

<h2><a class="toc-backref" id="statements-and-expressions-return-statement" href="#statements-and-expressions-return-statement">Return statement(Return语句)</a></h2><p>如:</p>
<pre><span class="Keyword">return</span> <span class="DecNumber">40</span><span class="Operator">+</span><span class="DecNumber">2</span></pre>
<p><tt class="docutils literal"><span class="pre">return</span></tt> 语句结束当前过程的执行，只运行在过程中执行。如果后面跟着一个 <tt class="docutils literal"><span class="pre">expr</span></tt>，这是个语法糖，等于下面的:</p>
<pre><span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">expr</span>
<span class="Keyword">return</span> <span class="Identifier">result</span></pre>
<p><tt class="docutils literal"><span class="pre">return</span></tt>后面没有表达式是<tt class="docutils literal"><span class="pre">return result</span></tt>的一个缩写方式(如果这个过程有返回值)。<br/>
<span id="result_1">result</span> 变量会被编译器自动的申明，和其他变量一样, <tt class="docutils literal"><span class="pre">result</span></tt> 被初始化为 zero值(二进制的0):</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">returnZero</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 暗示返回0</span></pre>

<h2><a class="toc-backref" id="statements-and-expressions-yield-statement" href="#statements-and-expressions-yield-statement">Yield statement(Yield语句)</a></h2>
<p>如:</p>
<pre><span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre>
<p>yield只能在迭代器中使用。在迭代器中用<tt class="docutils literal"><span class="pre">yield</span></tt> 语句来代替以前过程中的 <tt class="docutils literal"><span class="pre">return</span></tt>语句。yield执行后 
返回到调用这个迭代器的地方。<br/>
Yield不会终结迭代过程，如果下一次迭代继续，将跳回到yield后。<br/>
详情见 (<a class="reference external" href="#iterators-and-the-for-statement">Iterators and the for statement(迭代器和for语句)</a>)</p>

<h2><a class="toc-backref" id="statements-and-expressions-block-statement" href="#statements-and-expressions-block-statement">Block statement(Block语句)</a></h2><p>例:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">j</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="DecNumber">7</span><span class="Punctuation">:</span>
        <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">true</span>
        <span class="Keyword">break</span> <span class="Identifier">myblock</span> <span class="Comment"># 离开这个block,本例中就跳出了一个双重for循环</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">found</span><span class="Punctuation">)</span></pre>
<p>block语句意味这将一堆语句归组到一个命名的 <tt class="docutils literal"><span class="pre">block</span></tt>。在这个block中<tt class="docutils literal"><span class="pre">break</span></tt> 语句可以立即跳出这个block。<br/><tt class="docutils literal"><span class="pre">break</span></tt> 语句后面可以跟随一个block的名字，以跳出此block</p>

<h2><a class="toc-backref" id="statements-and-expressions-break-statement" href="#statements-and-expressions-break-statement">Break statement(Break语句)</a></h2><p>如:</p>
<pre><span class="Keyword">break</span></pre>
<p><tt class="docutils literal"><span class="pre">break</span></tt> 语句用来立即跳出一个block。如果后面跟了一个 <tt class="docutils literal"><span class="pre">符号</span></tt>， 那么就是跳出这个符号对应的block。如果未跟随，则跳出最内层的一个区块。</p>

<h2><a class="toc-backref" id="statements-and-expressions-while-statement" href="#statements-and-expressions-while-statement">While statement(while语句)</a></h2><p>如:</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Please tell me your password: </span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">pw</span> <span class="Operator">!=</span> <span class="StringLit">&quot;12345&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Wrong password! Next try: </span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre>
  <p> <tt class="docutils literal"><span class="pre">while</span></tt> 语句将一直执行直到 <tt class="docutils literal"><span class="pre">表达式</span></tt> 为false。<br/>
  <tt class="docutils literal"><span class="pre">while</span></tt> 语句创建了一个 <cite>隐含的block<cite>,因此 <tt class="docutils literal"><span class="pre">break</span></tt> 语句可以跳出这个循环</p>

<h2><a class="toc-backref" id="statements-and-expressions-continue-statement" href="#statements-and-expressions-continue-statement">Continue statement(Continue语句)</a></h2>
<p><tt class="docutils literal"><span class="pre">continue</span></tt> 语句将立即进行循环中的下一轮迭代，只能用在循环中。<br/>
continue语句其实是一个内嵌block的语法糖:</p>
<pre><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Identifier">stmt1</span>
  <span class="Keyword">continue</span>
  <span class="Identifier">stmt2</span></pre><p>等同于:</p>
<pre><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Keyword">block</span> <span class="Identifier">myBlockName</span><span class="Punctuation">:</span>
    <span class="Identifier">stmt1</span>
    <span class="Keyword">break</span> <span class="Identifier">myBlockName</span>
    <span class="Identifier">stmt2</span></pre>
<h2><a class="toc-backref" id="statements-and-expressions-assembler-statement" href="#statements-and-expressions-assembler-statement">Assembler statement(Assembler汇编语句)</a></h2>
<p>Nim支持通过用不安全的<tt class="docutils literal"><span class="pre">asm</span></tt>来直接的嵌入汇编代码。<br/>
汇编代码中如需引用Nim中的标识符，则需要用<tt class="docutils literal"><span class="pre">'`'</span></tt>将这个标识符标识出来：</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># a in eax, and b in edx</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
      mov eax, `a`
      add eax, `b`
      jno theEnd
      call `raiseOverflow`
    theEnd:
  &quot;&quot;&quot;</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<p>如果用GNU assembler，将会自动的插入引号和换行:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    addl %%ecx, %%eax
    jno 1
    call `raiseOverflow`
    1:
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre><p>就不需要下面这种麻烦的写法了:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    &quot;addl %%ecx, %%eax\n&quot;
    &quot;jno 1\n&quot;
    &quot;call `raiseOverflow`\n&quot;
    &quot;1: \n&quot;
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre>
<h2><a class="toc-backref" id="statements-and-expressions-using-statement" href="#statements-and-expressions-using-statement">Using statement(Using语句)--实验品，不看了</a></h2>
<p><strong>警告</strong>: <tt class="docutils literal"><span class="pre">using</span></tt> 语句还在实验中，因此必须要显示的使用编译指示 <span id="experimental_1">experimental</span>  或　编译时的命令行选项来激活!</p>
<p>The using statement provides syntactic convenience for procs that heavily use a single contextual parameter. When applied to a variable or a constant, it will instruct Nim to automatically consider the used symbol as a hidden leading parameter for any procedure calls, following the using statement in the current scope. Thus, it behaves much like the hidden <cite>this</cite> parameter available in some object-oriented programming languages.</p>
<pre><span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">socket</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">using</span> <span class="Identifier">s</span>

<span class="Identifier">connect</span><span class="Punctuation">(</span><span class="Identifier">host</span><span class="Punctuation">,</span> <span class="Identifier">port</span><span class="Punctuation">)</span>
<span class="Identifier">send</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span>

<span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">line</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">timeout</span><span class="Punctuation">)</span>
  <span class="Operator">...</span></pre><p>When applied to a callable symbol, it brings the designated symbol in the current scope. Thus, it can be used to disambiguate between imported symbols from different modules having the same name.</p>
<pre><span class="Keyword">import</span> <span class="Identifier">windows</span><span class="Punctuation">,</span> <span class="Identifier">sdl</span>
<span class="Keyword">using</span> <span class="Identifier">sdl</span><span class="Operator">.</span><span class="Identifier">SetTimer</span></pre><p>Note that <tt class="docutils literal"><span class="pre">using</span></tt> only <em>adds</em> to the current context, it doesn't remove or replace, <strong>neither</strong> does it create a new scope. What this means is that if one applies this to multiple variables the compiler will find conflicts in what variable to use:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;kill it&quot;</span>
<span class="Keyword">using</span> <span class="Identifier">a</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot; with fire&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">using</span> <span class="Identifier">b</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot; with water&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span></pre><p>When the compiler reaches the second <tt class="docutils literal"><span class="pre">add</span></tt> call, both <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> could be used with the proc, so one gets <tt class="docutils literal"><span class="pre">Error: expression '(a|b)' has no type (or is ambiguous)</span></tt>. To solve this one would need to nest <tt class="docutils literal"><span class="pre">using</span></tt> with a <tt class="docutils literal"><span class="pre">block</span></tt> statement so as to control the reach of the <tt class="docutils literal"><span class="pre">using</span></tt> statement.</p>

<h2><a class="toc-backref" id="statements-and-expressions-if-expression" href="#statements-and-expressions-if-expression">If expression(If表达式)</a></h2>
<p><cite>if 表达式</cite> 看上去和 If语句 非常类似，但是这个是表达式不是语句！</p>
<pre><span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&gt;</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="DecNumber">9</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="DecNumber">10</span></pre>
<p>作为表达式，if表达式总是要返回一个值的，因此 <tt class="docutils literal"><span class="pre">else</span></tt> 部分是必须的，<tt class="docutils literal"><span class="pre">elif</span></tt> 也是允许的哈。</p>

<h2><a class="toc-backref" id="statements-and-expressions-when-expression" href="#statements-and-expressions-when-expression">When expression(When表达式)</a></h2>
<p>和 <cite>if 表达式</cite>类似,不过是when语句的改变</p>

<h2><a class="toc-backref" id="statements-and-expressions-case-expression" href="#statements-and-expressions-case-expression">Case expression(Case表达式)</a></h2>
<p><cite>case 表达式</cite> 也一样，和case语句非常类似:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">favoriteFood</span> <span class="Operator">=</span> <span class="Keyword">case</span> <span class="Identifier">animal</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;dog&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;bones&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;cat&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;mice&quot;</span>
  <span class="Keyword">elif</span> <span class="Identifier">animal</span><span class="Operator">.</span><span class="RawData">endsWith&quot;whale&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;plankton&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm not sure what to serve, but everybody loves ice cream&quot;</span>
    <span class="StringLit">&quot;ice cream&quot;</span></pre>
    <p>如上例所示，case表达式也有 side effects。<br/>
    当一个分支中存在多条语句时，最后一个表达式的值将是返回的值</p>

<h2><a class="toc-backref" id="statements-and-expressions-table-constructor" href="#statements-and-expressions-table-constructor">Table constructor(Table构造器)</a></h2>
<p>Table构造器是数组构造器的一个语法糖:</p>
<pre><span class="Punctuation">{</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">}</span>

<span class="Comment"># 等同于:</span>
<span class="Punctuation">[</span><span class="Punctuation">(</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">]</span></pre>
<p>空的table可用 <tt class="docutils literal"><span class="pre">{:}</span></tt> (注意空集合是 <tt class="docutils literal"><span class="pre">{}</span></tt>)，这也是另外一个描述空数组的方式，而通常都是直接 <tt class="docutils literal"><span class="pre">[]</span></tt>表示是一个空数组</p>

<h2><a class="toc-backref" id="statements-and-expressions-type-conversions" href="#statements-and-expressions-type-conversions">Type conversions(类型转换)</a></h2>
<p>语法上来说 <cite>类型转换</cite> 像极了过程调用，只是用类型名替换了过程名。<br/>
类型转换通常情况下总是安全的，如果失败的话将会抛出异常(如果这个失败在编译器不能确定的话)</p>
<p>Nim中还是建议使用普通的过程来进行类型转换。如：<tt class="docutils literal"><span class="pre">$</span></tt>　、 <tt class="docutils literal"><span class="pre">toFloat</span></tt> 以及 <tt class="docutils literal"><span class="pre">toInt</span></tt></p>

<h2><a class="toc-backref" id="statements-and-expressions-type-casts" href="#statements-and-expressions-type-casts">Type casts</a></h2>
<p>如:</p>
<pre><span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>#将x转换为int类型</pre>
<p>Type casts是一个"粗鲁"的转换方式。<br/>
他将按照相应类型的位模式(bit)进行转换，这个转换是不安全的。底层编程中会经常被使用</p>

<h2><a class="toc-backref" id="statements-and-expressions-the-addr-operator" href="#statements-and-expressions-the-addr-operator">The addr operator(addr操作符)</a></h2>
<p><tt class="docutils literal"><span class="pre">addr</span></tt> 操作符返回一个左值(l-value)的地址。<br/>
如果这个左值的类型是 <tt class="docutils literal"><span class="pre">T</span></tt> 那么 <cite>addr</cite> 操作符返回的地址类型就是 <tt class="docutils literal"><span class="pre">ptr T</span></tt>。<br/>
返回的地址总是不追踪的引用。<br/>
返回分配在stack栈上的对象的地址是<strong>不安全</strong>的，因为指针可能比对象存活期更长，这将导致引用一个不存在的对象。</p>
<pre><span class="Comment">#let中 t1不是变量，可以认为是一个半const常量</span>
<span class="Keyword">let</span> <span class="Identifier">t1</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello&quot;</span>
<span class="Keyword">var</span>
  <span class="Identifier">t2</span> <span class="Operator">=</span> <span class="Identifier">t1</span>
  <span class="Identifier">t3</span> <span class="Punctuation">:</span> <span class="Identifier">pointer</span> <span class="Operator">=</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; ref 0x7fff6b71b670 --&gt; 0x10bb81050&quot;Hello&quot;</span>
<span class="Identifier">echo</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">t3</span><span class="Punctuation">)</span><span class="Punctuation">[</span><span class="Punctuation">]</span>
<span class="Comment"># --&gt; Hello</span>
<span class="Comment"># 下面的一句不能编译:</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t1</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
</pre>
<h1><a class="toc-backref" id="procedures" href="#procedures">Procedures(过程)</a></h1>
<p>在大多数编程语言称 <span id="methods_1">方法</span> 或 <span id="functions_1">函数</span> 在Nim中称为 <span id="procedures_1">过程</span>。<br/><strong>过程就是将一个代码块赋值到一个标识符上。</strong><br/>
 过程能够循环调用自己。</p>
<p>如果一个过程申明没有内容，那么这就是个 <span id="forward_1">forward(前向)</span> 申明。<br/>
如果这个过程有返回值，那么过程体内可以都读写一个隐含申明的变量 <span id="result_2">result</span>，这个就是返回值。 <br/>
过程能被重载<br/>
重载裁决算法选择最适合调用参数的过程，如:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="Comment"># 适合字符的toLower过程</span>
  <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'A'</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">c</span>

<span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># 适用字符串的toLower的过程</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newString</span><span class="Punctuation">(</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># 调用字符的 toLower过程; 不是循环调用!</span></pre>
<p>过程的调用可以有多种不同的方法:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Comment"># call with positional arguments # parameter bindings:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span>  <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=true)</span>
<span class="Comment"># call with named and positional arguments:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abd&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">)</span>    <span class="Comment"># (x=0, y=1, s=&quot;abd&quot;, c='\t', b=false)</span>
<span class="Comment"># call with named arguments (order is not relevant):</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Operator">=</span><span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">)</span>         <span class="Comment"># (x=0, y=1, s=&quot;&quot;, c='\t', b=false)</span>
<span class="Comment"># call as a command statement: no () needed:</span>
<span class="Identifier">callme</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span></pre>
<p>过程不能修改它传入的参数，除非这个参数的类型被申明为 <cite>var</cite>类型</p>
<p><span id="operators_1">操作符</span>就是一用特别的符号作为标识符的过程:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span><span class="Comment"># 将整数转为字符串，这是一个前缀操作符</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">intToStr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<p>一个参数的操作符是前缀操作符，两个参数的是中缀操作符。</p>
<p>操作符可以 `<cite>opr</cite>` 这样调用 (因此操作符可以有超过２个的参数): </p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 乘和加</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">*</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span>

<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="procedures-export-marker" href="#procedures-export-marker">Export marker(输出标记)</a></h2>
<p>如果一个符号后面跟着 <span id="asterisk_1">*</span>，表示这个模块中的这个符号是输出的:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">exportedEcho</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">s</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStringOfCap</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">a</span>

<span class="Keyword">var</span> <span class="Identifier">exportedVar</span><span class="Operator">*:</span> <span class="Identifier">int</span>
<span class="Keyword">const</span> <span class="Identifier">exportedConst</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">78</span>
<span class="Keyword">type</span>
  <span class="Identifier">ExportedType</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">exportedField</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre>
<h2><a class="toc-backref" id="procedures-method-call-syntax" href="#procedures-method-call-syntax">Method call syntax(方法调用语法)</a></h2>
<p>面向对象编程来说，<tt class="docutils literal"><span class="pre">obj.method(args)</span></tt> 就是调用方法 <tt class="docutils literal"><span class="pre">method(obj, args)</span></tt>。<br/>
如果调用是没有参数的，那么括号也可以省略掉: <tt class="docutils literal"><span class="pre">obj.len</span></tt> (等于 <tt class="docutils literal"><span class="pre">len(obj)</span></tt>)</p>
<p>方法调用语法不是只适用于对象的，也能够应用到任何过程的第一个参数上:</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span> <span class="Comment"># 就是 echo(len(&quot;abc&quot;))</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 等于 writeln(stdout, &quot;Hallo&quot;)</span></pre>
<p>方法调用的另外一种方法后缀调用方式。见: <a class="reference external" href="#limitations-of-the-method-call-syntax">Limitations of the method call syntax</a>.</p>

<h2><a class="toc-backref" id="procedures-properties" href="#procedures-properties">Properties(属性)</a></h2>
<p>Nim不需要属性的 <em>get方法</em>: 直接用 <em>方法调用语法</em> 就足够了。但是设置一个值不同，是需要一个特定的方法的:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">FHost</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 此字段，模块外面是不能读写的</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## 地址的设置</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## 地址的读取</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span>

<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">new</span> <span class="Identifier">s</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># 等同于 `host=`(s, 34)</span></pre>
<h2><a class="toc-backref" id="procedures-command-invocation-syntax" href="#procedures-command-invocation-syntax">Command invocation syntax(命令式调用语法)</a></h2>
<p>命令式调用最多只接受１个参数。<br/>
这个限制意味着 <tt class="docutils literal"><span class="pre">echo f 1, f 2</span></tt> 被解释为 <tt class="docutils literal"><span class="pre">echo(f(1), f(2))</span></tt> 而不是 <tt class="docutils literal"><span class="pre">echo(f(1, f(2)))</span></tt>。<br/>
命令式调用语法也能应用于多个参数的过程，如下例子所示:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">singlearg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">20</span><span class="Operator">*</span><span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">singlearg</span> <span class="DecNumber">2</span>  <span class="Comment"># 输出 &quot;1 40&quot; 等同 echo optarg(1,0),singlearg(2)</span>

<span class="Keyword">let</span> <span class="Identifier">fail</span> <span class="Operator">=</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>   <span class="Comment"># 编译错误，赋值语法不对</span>
<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span><span class="Punctuation">)</span>  
<span class="Keyword">let</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">optarg</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>    <span class="Comment"># 同上结果，省略了括号.分解如下：</span>
<span class="Comment"># optarg 8 => optarg(8,0) Command Call语法 </span>
<span class="Comment"># 1.optarg x => optarg(1,x) Method Call语法</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="Identifier">y</span></pre>
<p>命令式调用语法不能将复杂表达式作为参数。如: (<a class="reference external" href="#anonymous-procs">匿名过程</a>), <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">case</span></tt> 和 <tt class="docutils literal"><span class="pre">try</span></tt></p>

<h2><a class="toc-backref" id="procedures-closures" href="#procedures-closures">Closures(闭包)</a></h2>
<p>一通定义说明，没意思。Procedures can appear at the top level in a module as well as inside other scopes, in which case they are called nested procs. A nested proc can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.</p>

<h2><a class="toc-backref" id="procedures-anonymous-procs" href="#procedures-anonymous-procs">Anonymous Procs(匿名过程)</a></h2>
<p>过程在省略过程名时就是匿名过程，匿名过程也是表达式</p>
<pre><span class="Keyword">var</span> <span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;Frankfurt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Tokyo&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">]</span>

<span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre>

<h2><a class="toc-backref" id="procedures-do-notation" href="#procedures-do-notation">Do notation(Do符号)</a></h2>
<p><strong>注意:</strong> <tt class="docutils literal"><span class="pre">do</span></tt> 的特性Nim中还未明确下来的，有可能修改。</p>
<p>作为一个特别的方便用法，过程中的过程表达式(如同匿名过程)可以用关键字 <tt class="docutils literal"><span class="pre">do</span></tt> 来直接申明:</p>
<pre><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Identifier">cities</span><span class="Punctuation">)</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">int</span><span class="Punctuation">:</span>
  <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
<span class="Comment"># 省略括号，用方法调用语法就妥了:</span>
<span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">map</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span><span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
  <span class="StringLit">&quot;City of &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">x</span></pre>
  <p>也能在一个调用中引用多个<tt class="docutils literal"><span class="pre">do</span></tt> 块:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">performWithUndo</span><span class="Punctuation">(</span><span class="Identifier">task</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">undo</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Identifier">performWithUndo</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># multiple-line block of code</span>
  <span class="Comment"># to perform the task</span>
<span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># code to undo it</span></pre>
<h2><a class="toc-backref" id="procedures-nonoverloadable-builtins" href="#procedures-nonoverloadable-builtins">Nonoverloadable builtins(不能重载的内置函数)</a></h2>
<p>下列内置过程不能被重载:<pre>
declared, defined, definedInScope, compiles, low, high, sizeOf,
is, of, shallowCopy, getAst, astToStr, spawn, procCall</pre>
</p>
<p>他们的行为看上去更像是关键字，然而和关键字的差异在于，他们可以在<tt class="docutils literal"><span class="pre">system</span></tt>中被重新定义，这样可以覆盖掉默认的行为了。<br/>
下面的过程也不能运用在点语法 <tt class="docutils literal"><span class="pre">x.f</span></tt>中，因为 <tt class="docutils literal"><span class="pre">x</span></tt> 在传递给 <tt class="docutils literal"><span class="pre">f</span></tt>之前不能进行类型检查:<pre>
declared, defined, definedInScope, compiles, getAst, astToStr</pre>
</p>

<h2><a class="toc-backref" id="procedures-var-parameters" href="#procedures-var-parameters">Var parameters(Var参数)</a></h2>
<p>这类参数前面多了个 <tt class="docutils literal"><span class="pre">var</span></tt> 关键字:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre>
<p>例中 <tt class="docutils literal"><span class="pre">res</span></tt> 和 <tt class="docutils literal"><span class="pre">remainder</span></tt> 是 <cite>var参</cite><br/>
Var参在过程中被修改后，过程的调用者也能看到这个变化，因此传递给Var参的值必须是左值。 <br/>
Var参数是用隐藏的指针来实现的，因此上面的例子等价于:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre>
<p>例中的 var参数或指针都是为了提供２个返回值才使用上的。直接返回一个元组会更清晰:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">res</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">remainder</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre>
<p>使用 <span id="tuple-unpacking_1">元组拆箱</span>:</p>
<pre><span class="Keyword">var</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># tuple unpacking</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre>

<h2><a class="toc-backref" id="procedures-var-return-type" href="#procedures-var-return-type">Var return type（Var返回类型)</a></h2>
<p>过程，转换器，和迭代器可以返回一个 <tt class="docutils literal"><span class="pre">var</span></tt>类型，表示返回的值是一个左值（调用者就可以修改这个返回值了):</p>
<pre><span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Identifier">WriteAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span>

<span class="Identifier">WriteAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="DecNumber">6</span>
<span class="Identifier">assert</span> <span class="Identifier">g</span> <span class="Operator">==</span> <span class="DecNumber">6</span></pre>
<p>如果很明显的返回了一个局部变量，并超出他的生存期的，将会抛出一个编译期错误:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">WriteAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span> <span class="Comment"># Error!</span></pre>
  <p>对迭代器来说, 返回的元组中的一项的类型也可以是 <tt class="docutils literal"><span class="pre">var</span></tt> 类型:</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">mpairs</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre>
    <p>标准库中，返回 <tt class="docutils literal"><span class="pre">var</span></tt> 类型的调用名称都是以 <tt class="docutils literal"><span class="pre">m</span></tt> 开始</p>

<h2><a class="toc-backref" id="procedures-overloading-of-the-subscript-operator" href="#procedures-overloading-of-the-subscript-operator">Overloading of the subscript operator(下标操作符重载)</a></h2>
<p>适用于数组、开放数组、序列的下标操作符 <tt class="docutils literal"><span class="pre">[]</span></tt> 都是可以被重载的</p>

<h1><a class="toc-backref" id="multi-methods" href="#multi-methods">Multi-methods(多重方法)</a></h1>
<p>过程总是用静态分发，但是多重方法用动态分发</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Expression</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## 表达式的抽象基类</span>
  <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 基础方法 :)</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">return</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># watch out: relies on dynamic binding</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">b</span>

echo eval(newPlus(newPlus(newLit(1), newLit(2)), newLit(4)))</pre>
<p>例中 <tt class="docutils literal"><span class="pre">newLit</span></tt> 和 <tt class="docutils literal"><span class="pre">newPlus</span></tt> 是过程因此使用静态绑定，<tt class="docutils literal"><span class="pre">eval</span></tt> 是方法因此采用动态绑定</p>
<p>方法分发根据参数的类型来进行:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;2&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span>
<span class="Identifier">new</span> <span class="Identifier">a</span>
<span class="Identifier">new</span> <span class="Identifier">b</span>
<span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Comment"># 输出: 2</span></pre>
<p>方法的分发不能有歧义: collide 2 优先于 collide 1，因为参数裁决是从左到右。<br/>
例中 <tt class="docutils literal"><span class="pre">Unit, Thing</span></tt> 是优先于 <tt class="docutils literal"><span class="pre">Thing, Unit</span></tt></p>
<p><strong>性能提示</strong>: Nim 不支持虚方法表(如C++中的)，但是生成分发树。<br/>
This avoids the expensive indirect branch for method calls and enables inlining. <br/>
然而编译期判定或死代码消除不能够应用在方法上。</p>

<h1><a class="toc-backref" id="iterators-and-the-for-statement" href="#iterators-and-the-for-statement">Iterators and the for statement(迭代和for语句)</a></h1>
<p><span id="for_1">for</span> 语句是一个抽象的机制，用来迭代容器中的每个元素。<br/>
这个机制依靠一个 <span id="iterator_1">迭代器</span> 来实现。<br/>
和 <tt class="docutils literal"><span class="pre">while</span></tt> 语句类似, <tt class="docutils literal"><span class="pre">for</span></tt> 语句也开了一个 <span id="implicit-block_1">隐含block</span>, 因此也可以用 <tt class="docutils literal"><span class="pre">break</span></tt> 语句跳出。</p>
<p><tt class="docutils literal"><span class="pre">for</span></tt> 循环中申明一个迭代变量，知道循环体接受前一直有效。迭代变量的类型从迭代器的返回类型中推导而来。</p>
<pre>
<span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Identifier">[ch : char,pos : int]</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">(a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">],i)</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">ch,i</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello world&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># `ch` 是迭代器变量</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">ch</span><span class="Punctuation">)</span></pre>
<p>编译器会生成如下的代码:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">(ch,j)</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">ch</span><span class="Punctuation">)</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span></pre>

<h2><a class="toc-backref" id="iterators-and-the-for-statement-implict-items-pairs-invocations" href="#iterators-and-the-for-statement-implict-items-pairs-invocations">Implict items/pairs invocations(隐藏的items/pairs约定)</a></h2>
<p>当 for循环中的表达式 <tt class="docutils literal"><span class="pre">e</span></tt> 不是一个迭代子时:<br/>
1. 只定义了一个迭代变量，那么这个表达式被重写为 <tt class="docutils literal"><span class="pre">items(e)</span></tt>即 <tt class="docutils literal"><span class="pre">items</span></tt> 迭代器被隐含的调用:</p>
<pre><span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span></pre>
<p>2. 定义了两个迭代变量，则 <tt class="docutils literal"><span class="pre">pairs</span></tt> 迭代器被隐含的调用</p>
<p>迭代转换器 <tt class="docutils literal"><span class="pre">items</span></tt>/<tt class="docutils literal"><span class="pre">pairs</span></tt> 将在重写后执行，因此重载 <tt class="docutils literal"><span class="pre">items</span></tt>/<tt class="docutils literal"><span class="pre">pairs</span></tt> 就可以发挥作用了</p>

<h2><a class="toc-backref" id="iterators-and-the-for-statement-first-class-iterators" href="#iterators-and-the-for-statement-first-class-iterators">First class iterators(第一个类迭代器)</a></h2>
<p>Nim中有两种 iterator: <em>inline</em> 和 <em>closure</em>。<br/>
<span id="inline-iterator_1">inline iterator</span> 在编译的时候总是将代码插入到调用的地方，而非一个调用指令，因此会显著的增加代码大小。作为二等公民，在被当成参数使用时只能传递给其他的inlineing代码构造(如模板、宏以及其他的inline iterator)</p>
<p>相反 <span id="closure-iterator_1">closure iterator</span> 可应用的范围更多:</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">count0</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="DecNumber">0</span>

<span class="Keyword">iterator</span> <span class="Identifier">count2</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>
  <span class="Identifier">inc</span> <span class="Identifier">x</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">iter</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">iter</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span>

<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count0</span><span class="Punctuation">)</span>
<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count2</span><span class="Punctuation">)</span></pre>
<p>Closure iterators 与 inline iterators相比，更严苛于:</p>
<ol class="simple">
<li>closure iterator中的<tt class="docutils literal"><span class="pre">yield</span></tt> 不能在 <tt class="docutils literal"><span class="pre">try</span></tt> 语句中</li>
<li>到现在为止，closure iterator不能在编译期间被评估</li>
<li>在closure iterator中可以使用 <tt class="docutils literal"><span class="pre">return</span></tt>(尽量少用)</li>
<li>inline 和 closure iterator都不能自我循环</li>
</ol>
<p>没有明确标记为 <tt class="docutils literal"><span class="pre">{.closure.}</span></tt> 或 <tt class="docutils literal"><span class="pre">{.inline.}</span></tt> 的iterator默认都是 inline 的, 将来也许会改变</p>
<p><tt class="docutils literal"><span class="pre">iterator</span></tt> 类型总是隐含的以 <tt class="docutils literal"><span class="pre">closure</span></tt> 方式调用的，下面的例子实现了一个 <span id="collaborative-tasking_1">协作任务</span> 系统:</p>
<pre><span class="Comment"># 简单任务:</span>
<span class="Keyword">type</span>
  <span class="Identifier">Task</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">a1</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: C&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: D&quot;</span>

<span class="Keyword">iterator</span> <span class="Identifier">a2</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: C&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">Task</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ticker</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">ticker</span> <span class="Keyword">mod</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span>
    <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span>
    <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">)</span>
    <span class="Identifier">inc</span> <span class="Identifier">ticker</span>
<span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">a1</span><span class="Punctuation">,</span> <span class="Identifier">a2</span><span class="Punctuation">)</span></pre>
<p>内置过程 <tt class="docutils literal"><span class="pre">system.finished</span></tt> 用来检查一个 iterator 是否已经完成了它的迭代操作； 对一个已经完成了的iterator进行调用不会引起异常的发生。</p>
<p>备注 <tt class="docutils literal"><span class="pre">system.finished</span></tt> 经常被错误使用，因为它只有在一个iterator <b>完成后</b> 才返回 <tt class="docutils literal"><span class="pre">true</span></tt> :</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">x</span>
    <span class="Identifier">inc</span> <span class="Identifier">x</span>
  <span class="Keyword">echo</span> <span class="Identifier">"Finished"</span>
  <span class="Keyword">result</span> <span class="Identifier">=100</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># instantiate the iterator</span>
<span class="Keyword">while</span> <span class="Keyword">not</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Comment"># Produces</span>
<span class="DecNumber">1</span>
<span class="DecNumber">2</span>
<span class="DecNumber">3</span>
<span class="DecNumber">Finished</span>
<span class="DecNumber">100 #因为closure可以return的</span></pre>

<p>Closure iterators 是 <em>resumable functions</em>，因此每次调用的时候都必须提供这个调用的参数(如果调用参数改变了，Closure内部也会发生相应变化)。<br/>
可以用一个iterator的工厂过程来省去每次都需要提供调用参数的麻烦:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
    <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">x</span>
      <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">let</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">f</span> <span class="Keyword">in</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">f</span></pre>
<h1><a class="toc-backref" id="converters" href="#converters">Converters(转换器)</a></h1>
<p>转换器和普通的过程一样，只是它还能够增强隐式的类型转换(see <a class="reference external" href="#convertible-relation">Convertible relation</a>):</p>
<pre><span class="Comment"># bad style ahead: Nim is not C.</span>
<span class="Comment"># toBool转换器的名字可以任意的哈</span>
<span class="Keyword">converter</span> <span class="Identifier">toBool</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="DecNumber">0</span>

<span class="Keyword">if</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;compiles&quot;</span></pre>
  <p>转换器也能显式的调用，这样可读性更好。<br/>
  注意，隐藏的转换链是不支持的：<br/> 一个转换器Cab支持从类型A转换到B,另外一个Cbc支持从类型B转换到C,但是隐含的从Ａ到C是不支持的。<br/>(显式的是支持的，直接调用Cab(A) 能转到到C,简单Cab(A) 返回的是B,B隐含到C)</p>

<h1><a class="toc-backref" id="type-sections" href="#type-sections">Type sections(Type区域 类型定义)</a></h1>
<p>如:</p>
<pre><span class="Keyword">type</span> <span class="Comment"># example demonstrating mutually recursive types</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span> <span class="Comment"># a traced pointer to a NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># left and right subtrees</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># leaves contain a reference to a Sym</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># a symbol</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># the symbol's name</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># the line the symbol was declared in</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>      <span class="Comment"># the symbol's abstract syntax tree</span></pre>
    <p>type区域用关键字 <tt class="docutils literal"><span class="pre">type</span></tt> 定义。 <br/>
    可以包括多个类型定义，每个类型必须有个名字。<br/>
    类型定义可以互相引用甚至互相循环引用。<br/>
    互相循环应用只能在同一个 <tt class="docutils literal"><span class="pre">type</span></tt> 区域中。<br/>
    普通类型，如 <tt class="docutils literal"><span class="pre">objects</span></tt> 或 <tt class="docutils literal"><span class="pre">enums</span></tt> 只能在 <tt class="docutils literal"><span class="pre">type</span></tt> 中定义(tuple可以直接在var中定义)</p>

<h1><a class="toc-backref" id="exception-handling" href="#exception-handling">Exception handling(异常处理)</a></h1>
<h2><a class="toc-backref" id="exception-handling-try-statement" href="#exception-handling-try-statement">Try statement(Try语句)</a></h2><p>如:</p>
<pre><span class="Comment"># read the first two lines of a text file that should contain numbers</span>
<span class="Comment"># and tries to add them</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;sum: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;overflow!&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;could not convert string to integer&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;IO error!&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Unknown exception!&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="exception-handling-try-expression" href="#exception-handling-try-expression">Try expression(Try表达式)</a></h2>
<p><tt class="docutils literal"><span class="pre">Try</span></tt> 也能作为一个表达式<br/>
<tt class="docutils literal"><span class="pre">try</span></tt> 分支的返回类型必须和 <tt class="docutils literal"><span class="pre">except</span></tt> 的返回类型是兼容的(表达式必须是一个确定的类型吧,静态语言)<br/>
但是 <tt class="docutils literal"><span class="pre">finally</span></tt> 分支总是 <tt class="docutils literal"><span class="pre">void</span></tt>:</p>
<pre><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span>
        <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span>
        <span class="Keyword">finally</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;hi&quot;</span></pre>
<p>为了避免语法分析的困扰，如果 <tt class="docutils literal"><span class="pre">try</span></tt> 跟随在 <tt class="docutils literal"><span class="pre">(</span></tt> 后面，那么这个try表达式必须写在一行内:</p>
<pre><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span> <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="exception-handling-except-clauses" href="#exception-handling-except-clauses">Except clauses(Except分支)</a></h2>
<p>在 <tt class="docutils literal"><span class="pre">except</span></tt> 分支中，可以用 <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> 过程来得到抛出的异常:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 现在可以用 &quot;e&quot;</span></pre>
<p>注意 <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> 过程总是返回一个 <tt class="docutils literal"><span class="pre">ref Exception</span></tt> 类型。 如果需要这个具体抛出的异常类型 (上例中的 <tt class="docutils literal"><span class="pre">IOError</span></tt>)，那么必须将它明确的转化:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">ref</span> <span class="Identifier">IOError</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># &quot;e&quot; 现在是精确的类型了 </span></pre>

  <p>然而基本上不会这么用，大多数都是直接从异常 <tt class="docutils literal"><span class="pre">e</span></tt>中获取具体的错误信息。<br/>
  此情形下可以直接用 <tt class="docutils literal"><span class="pre">getCurrentExceptionMsg</span></tt>过程来获取:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I/O error: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="exception-handling-defer-statement" href="#exception-handling-defer-statement">Defer statement(Defer语句)</a></h2>
<p> <tt class="docutils literal"><span class="pre">defer</span></tt>语句可用来取代 <tt class="docutils literal"><span class="pre">try finally</span></tt> 语句。</p>
<p>同Block中的跟随在 <tt class="docutils literal"><span class="pre">defer</span></tt> 后都语句都可以认为是在一个隐含的 try block中:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">defer</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span></pre>
<p>被重写为:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span>
<span class="Keyword">finally</span><span class="Punctuation">:</span>
  <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre>
  <p>不支持在最高层空间使用 <tt class="docutils literal"><span class="pre">defer</span></tt> 语句，因为不能确定哪些语句要被包括在内。</p>

<h2><a class="toc-backref" id="exception-handling-raise-statement" href="#exception-handling-raise-statement">Raise statement(Raise语句)</a></h2>
<p>如:</p>
<pre><span class="Keyword">raise</span> <span class="Identifier">newEOS</span><span class="Punctuation">(</span><span class="StringLit">&quot;operating system failed&quot;</span><span class="Punctuation">)</span></pre>
<p>除了内置的操作符如数组索引，内存分配等等，抛出异常的唯一途径就是用 <tt class="docutils literal"><span class="pre">raise</span></tt> 语句</p>
<p>如果就是一个raise，那么将当前的异常<span id="re-raised_1">重新抛出</span>。如果当前没有异常可以重新抛出，那么将引发 <span id="reraiseerror_1">ReraiseError</span> 异常。<br/>
除非安装了raise钩子，raise语句总是能抛出一个异常的。</p>

<h2><a class="toc-backref" id="exception-handling-exception-hierarchy" href="#exception-handling-exception-hierarchy">Exception hierarchy(异常体系)</a></h2>
<p>异常树定义在 <a class="reference external" href="system.html">system</a> 模块中:</p>
<ul class="simple"><li><a class="reference external" href="system.html#Exception">Exception</a><ul class="simple"><li><a class="reference external" href="system.html#AccessViolationError">AccessViolationError</a></li>
<li><a class="reference external" href="system.html#ArithmeticError">ArithmeticError</a><ul class="simple"><li><a class="reference external" href="system.html#DivByZeroError">DivByZeroError</a></li>
<li><a class="reference external" href="system.html#OverflowError">OverflowError</a></li>
</ul>
</li>
<li><a class="reference external" href="system.html#AssertionError">AssertionError</a></li>
<li><a class="reference external" href="system.html#DeadThreadError">DeadThreadError</a></li>
<li><a class="reference external" href="system.html#FloatingPointError">FloatingPointError</a><ul class="simple"><li><a class="reference external" href="system.html#FloatDivByZeroError">FloatDivByZeroError</a></li>
<li><a class="reference external" href="system.html#FloatInexactError">FloatInexactError</a></li>
<li><a class="reference external" href="system.html#FloatInvalidOpError">FloatInvalidOpError</a></li>
<li><a class="reference external" href="system.html#FloatOverflowError">FloatOverflowError</a></li>
<li><a class="reference external" href="system.html#FloatUnderflowError">FloatUnderflowError</a></li>
</ul>
</li>
<li><a class="reference external" href="system.html#InvalidFieldError">FieldError</a></li>
<li><a class="reference external" href="system.html#InvalidIndexError">IndexError</a></li>
<li><a class="reference external" href="system.html#ObjectAssignmentError">ObjectAssignmentError</a></li>
<li><a class="reference external" href="system.html#ObjectConversionError">ObjectConversionError</a></li>
<li><a class="reference external" href="system.html#ValueError">ValueError</a><ul class="simple"><li><a class="reference external" href="system.html#KeyError">KeyError</a></li>
</ul>
</li>
<li><a class="reference external" href="system.html#ReraiseError">ReraiseError</a></li>
<li><a class="reference external" href="system.html#RangeError">RangeError</a></li>
<li><a class="reference external" href="system.html#OutOfMemoryError">OutOfMemoryError</a></li>
<li><a class="reference external" href="system.html#ResourceExhaustedError">ResourceExhaustedError</a></li>
<li><a class="reference external" href="system.html#StackOverflowError">StackOverflowError</a></li>
<li><a class="reference external" href="system.html#SystemError">SystemError</a><ul class="simple"><li><a class="reference external" href="system.html#IOError">IOError</a></li>
<li><a class="reference external" href="system.html#OSError">OSError</a><ul class="simple"><li><a class="reference external" href="system.html#LibraryError">LibraryError</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li> 
</ul>

<h1><a class="toc-backref" id="effect-system" href="#effect-system">Effect system(Effect系统)</a></h1>
<h2><a class="toc-backref" id="effect-system-exception-tracking" href="#effect-system-exception-tracking">Exception tracking(异常追踪)</a></h2>
<p>Nim中支持异常追踪。<br/>
用 <span id="raises_1">raises</span> 指示用来定义 proc/iterator/method/converter(过程/迭代器/方法/转换器)中允许抛出的异常类型。编译器将会检测这个说明:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">OSError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre>
 <p>空的 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表 (<tt class="docutils literal"><span class="pre">raises: []</span></tt>) 则说明不会抛出任何异常:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">unsafeCall</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre>
 <p><tt class="docutils literal"><span class="pre">raises</span></tt> 列表也能在类型申明的时候使用，这会影响类型的兼容性：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Callback</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Callback</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">p</span> <span class="Comment"># 类型错误，不兼容的</span></pre>
<p>For a routine <tt class="docutils literal"><span class="pre">p</span></tt> the compiler uses inference rules to determine the set of possibly raised exceptions; the algorithm operates on <tt class="docutils literal"><span class="pre">p</span></tt>'s call graph:</p>
<ol class="simple"><li>Every indirect call via some proc type <tt class="docutils literal"><span class="pre">T</span></tt> is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> (the base type of the exception hierarchy) and thus any exception unless <tt class="docutils literal"><span class="pre">T</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list. However if the call is of the form <tt class="docutils literal"><span class="pre">f(...)</span></tt> where <tt class="docutils literal"><span class="pre">f</span></tt> is a parameter of the currently analysed routine it is ignored. The call is optimistically assumed to have no effect. Rule 2 compensates for this case.</li>
<li>Every expression of some proc type wihtin a call that is not a call itself (and not nil) is assumed to be called indirectly somehow and thus its raises list is added to <tt class="docutils literal"><span class="pre">p</span></tt>'s raises list.</li>
<li>Every call to a proc <tt class="docutils literal"><span class="pre">q</span></tt> which has an unknown body (due to a forward declaration or an <tt class="docutils literal"><span class="pre">importc</span></tt> pragma) is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> unless <tt class="docutils literal"><span class="pre">q</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>对于方法 <tt class="docutils literal"><span class="pre">m</span></tt> 的调用假定总会抛出异常 <tt class="docutils literal"><span class="pre">system.Exception</span></tt>，除非 <tt class="docutils literal"><span class="pre">m</span></tt> 有明确指定的 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表</li>
<li>For every other call the analysis can determine an exact <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>为了确定 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表，<tt class="docutils literal"><span class="pre">p</span></tt>中的<tt class="docutils literal"><span class="pre">raise</span></tt> 和 <tt class="docutils literal"><span class="pre">try</span></tt>语句也将被考虑</li>
</ol>
<p>Rules 1-2 ensure the following works:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># unknown call that might raise anything, but valid:</span>
  <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">doRaise</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">use</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># doesn't compile! Can raise IOError!</span>
  <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">doRaise</span><span class="Punctuation">)</span></pre><p>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</p>

<h2><a class="toc-backref" id="effect-system-tag-tracking" href="#effect-system-tag-tracking">Tag tracking</a></h2>
<p>异常追踪只是 Nim的 <span id="effect-system_1">effect系统</span>中的一部分。用户自定义的 <em>tag</em> 也是类似的:</p>
<pre><span class="Keyword">type</span> <span class="Identifier">IO</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## input/output effect</span>
<span class="Keyword">proc</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">no_IO_please</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 编译器将阻止这个编译:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
  <p>tag必须是类型的名字，和<tt class="docutils literal"><span class="pre">raises</span></tt>一样<tt class="docutils literal"><span class="pre">tags</span></tt> 列表也能附加到过程类型定义上，也同样影响类型的兼容性</p>
<p>Tag追踪的推导方式和异常追踪一样。</p>

<h2><a class="toc-backref" id="effect-system-read-write-tracking" href="#effect-system-read-write-tracking">Read/Write tracking</a></h2><p><strong>注意</strong>: 还未实现!</p>
<p>The inference for read/write tracking is analogous to the inference for exception tracking.</p>

<h2><a class="toc-backref" id="effect-system-effects-pragma" href="#effect-system-effects-pragma">Effects pragma</a></h2>
<p> <tt class="docutils literal"><span class="pre">effects</span></tt> 指示符用来帮助开发人员进行effect分析。此语句将在编译期间输出这条语句处的全部effect:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">effects</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre>
    <p>编译器将输出一条提示信息：将抛出<tt class="docutils literal"><span class="pre">IOError</span></tt> 。 <tt class="docutils literal"><span class="pre">OSError</span></tt> 将不会被列出，因为<tt class="docutils literal"><span class="pre">effects</span></tt> 语句不在OSError对应的分支上。</p>

<h1><a class="toc-backref" id="generics" href="#generics">Generics(范型)</a></h1>
<p>范型意味着Nim可以参数化过程、迭代器以及类型定义。采用中括号[]来引入类型参数或实例化一个范型。</p>
<p>如下例:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>    <span class="Comment"># BinaryTreeObj is a generic type with</span>
                               <span class="Comment"># with generic param ``T``</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>      <span class="Comment"># left and right subtrees; may be nil</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                    <span class="Comment"># the data stored in a node</span>
  <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Comment"># a shorthand for notational convenience</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Comment"># constructor for a node</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">data</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span> <span class="Comment"># compare the data items; uses</span>
                                   <span class="Comment"># the generic ``cmp`` proc that works for</span>
                                   <span class="Comment"># any type that has a ``==`` and ``&lt;``</span>
                                   <span class="Comment"># operator</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">iterator</span> <span class="Identifier">inorder</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># inorder traversal of a binary tree</span>
  <span class="Comment"># recursive iterators are not yet implemented, so this does not work in</span>
  <span class="Comment"># the current compiler!</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Keyword">yield</span> <span class="Identifier">inorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">le</span><span class="Punctuation">)</span>
  <span class="Keyword">yield</span> <span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">data</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Keyword">yield</span> <span class="Identifier">inorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>  <span class="Comment"># instantiate a BinaryTree with the type string</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hallo&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># instantiates generic procs ``newNode`` and</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># ``add``</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">inorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">str</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="generics-is-operator" href="#generics-is-operator">Is operator(is操作符)</a></h2>
<p><tt class="docutils literal"><span class="pre">is</span></tt> 操作符在编译期检查类型的匹配性，因此在范型代码中常用来确定是否为某类型:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">keys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">]</span>
    <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Value</span><span class="Punctuation">]</span>
    <span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">Key</span> <span class="Keyword">is</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># nil value for strings used for optimization</span>
      <span class="Identifier">deletedKeys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="generics-type-operator" href="#generics-type-operator">Type operator(type操作符)</a></h2>
<p><tt class="docutils literal"><span class="pre">type</span></tt>操作符(在很多语言中是 <span id="typeof_1">typeof</span>) 能用来确定表达式的类型:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">type</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># y的类型是 int</span></pre>
<p>如果有一个调用<tt class="docutils literal"><span class="pre">c(X)</span></tt> (<tt class="docutils literal"><span class="pre">X</span></tt>表示可能的参数列表),如果c是重载的(比如有过程/迭代器/转换器等)那么此时<tt class="docutils literal"><span class="pre">c</span></tt> 优选采用的是迭代器:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Comment"># strutils 包含了 ``split`` 的过程和迭代器版本</span>
<span class="Comment"># 迭代器预先，因此 ``y``的类型是 ``string``:</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">type</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="generics-type-classes" href="#generics-type-classes">Type Classes</a></h2>
<p>Type class是个特殊的伪类型，that can be used to match against types in the context of overload resolution 或 <tt class="docutils literal"><span class="pre">is</span></tt> 操作符<br/>
Nim支持如下的内置type classes:</p>
<table border="1" class="docutils"><tr><th>type class</th><th>matches</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">object</span></tt></td><td>any object type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">tuple</span></tt></td><td>any tuple type</td></tr>
<tr><td></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">enum</span></tt></td><td>any enumeration</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">proc</span></tt></td><td>any proc type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ref</span></tt></td><td>any <tt class="docutils literal"><span class="pre">ref</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ptr</span></tt></td><td>any <tt class="docutils literal"><span class="pre">ptr</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">var</span></tt></td><td>any <tt class="docutils literal"><span class="pre">var</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">distinct</span></tt></td><td>any distinct type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">array</span></tt></td><td>any array type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">set</span></tt></td><td>any set type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">seq</span></tt></td><td>any seq type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">auto</span></tt></td><td>any type</td></tr>
</table>
<p>因此，每个范型将自动的创建一个同名的type class用来匹配此范型的各种实例。</p>
<p>Type classes能用标准的布尔操作组合形成更复杂的type classes:</p>
<pre><span class="Comment"># 创建一个匹配全部元组和对象的type class</span>
<span class="Keyword">type</span> <span class="Identifier">RecordType</span> <span class="Operator">=</span> <span class="Keyword">tuple</span> <span class="Keyword">or</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">printFields</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">:</span> <span class="Identifier">RecordType</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">fieldPairs</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">value</span></pre>
    <p>以此种方式运用type class的过程可以被认为是一种 <span id="implicitly-generic_1">隐性范型</span>了。<br/>每个不同的唯一类型组合将实例化过程一次。</p>
<p>Nim也支持在范型定义时，特化指定的类型作为参数（<span id="type-constraints_1">类型约束</span>):</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">onlyIntOrString</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Operator">|</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="DecNumber">450</span><span class="Punctuation">,</span> <span class="DecNumber">616</span><span class="Punctuation">)</span> <span class="Comment"># 合法</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="FloatNumber">5.0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.0</span><span class="Punctuation">)</span> <span class="Comment"># 类型错误</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="StringLit">&quot;xy&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">50</span><span class="Punctuation">)</span> <span class="Comment"># 非法，因为 'T' 只能是一个指定的类型</span></pre>
<p>By default, during overload resolution each named type class will bind to exactly one concrete type. Here is an example taken directly from the system module to illustrate this:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Comment">## `x`  `y` 必须是相同的tuple类型</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">fields</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>

<span class="Keyword">proc</span> <span class="Punctuation">`<span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
<span class="Comment">## 现在`x`  `y` 就不需要是相同的tuple类型了</span>
<span class="Comment"># 后面fields依旧会报错，但至少可以编译过去了</span></pre><p>Alternatively, the <tt class="docutils literal"><span class="pre">distinct</span></tt> type modifier can be applied to the type class to allow each param matching the type class to bind to a different type.</p>
<p>如果过程的参数没有指定一个类型，那么Nim默认使用 <tt class="docutils literal"><span class="pre">distinct auto</span></tt> type class (也就是 <tt class="docutils literal"><span class="pre">any</span></tt>):</p>
<pre><span class="Comment"># a b可以使用任意组合的类型了</span>
<span class="Keyword">proc</span> <span class="Identifier">concat</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">b</span></pre>
<p>如果需要应用范型中匹配的类型，可以直接的用.语法来获取:</p>
<pre><span class="Keyword">type</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">Rows</span><span class="Punctuation">,</span> <span class="Identifier">Columns</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Operator">...</span>
<span class="Comment"># 就这么引用Matrix.T </span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">,</span> <span class="Identifier">row</span><span class="Punctuation">,</span> <span class="Identifier">col</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">col</span> <span class="Operator">*</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">Columns</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">row</span><span class="Punctuation">]</span></pre><p>Alternatively, the <cite>type</cite> operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</p>
<p>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</p>
<pre><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Keyword">ref</span> <span class="Keyword">object</span><span class="Punctuation">]</span>  <span class="Comment"># Any sequence storing references to any object type</span>

<span class="Keyword">type</span> <span class="Identifier">T1</span> <span class="Operator">=</span> <span class="Identifier">auto</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">T1</span><span class="Punctuation">)</span>
  <span class="Comment"># seq[T1] is the same as just `seq`, but T1 will be allowed to bind</span>
  <span class="Comment"># to a single type, while the signature is being matched</span>

<span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">Ordinal</span><span class="Punctuation">]</span> <span class="Comment"># Any Matrix instantiation using integer values</span></pre><p>As seen in the previous example, in such instantiations, it's not necessary to supply all type parameters of the generic type, because any missing ones will be inferred to have the equivalent of the <cite>any</cite> type class and thus they will match anything without discrimination.</p>

<h2><a class="toc-backref" id="generics-concepts" href="#generics-concepts">Concepts</a></h2><p><strong>注意</strong>: Concepts依旧在开发中，我就删除了</p>

<h2><a class="toc-backref" id="generics-symbol-lookup-in-generics" href="#generics-symbol-lookup-in-generics">Symbol lookup in generics(范型中的符号查找)</a></h2>
<p>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</p>
<p>Open symbols are looked up in two different contexts: Both the context at definition and the context at instantiation are considered:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Index</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Index</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span> <span class="Comment"># works!</span></pre><p>In the example the generic <tt class="docutils literal"><span class="pre">==</span></tt> for tuples (as defined in the system module) uses the <tt class="docutils literal"><span class="pre">==</span></tt> operators of the tuple's components. However, the <tt class="docutils literal"><span class="pre">==</span></tt> for the <tt class="docutils literal"><span class="pre">Index</span></tt> type is defined <em>after</em> the <tt class="docutils literal"><span class="pre">==</span></tt> for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.</p>
<p>A symbol can be forced to be open by a <span id="mixin_1">mixin</span> declaration:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">create</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># there is no overloaded 'init' here, so we need to state that it's an</span>
  <span class="Comment"># open symbol explicitly:</span>
  <span class="Keyword">mixin</span> <span class="Identifier">init</span>
  <span class="Identifier">new</span> <span class="Identifier">result</span>
  <span class="Identifier">init</span> <span class="Identifier">result</span></pre>
<h2><a class="toc-backref" id="generics-bind-statement" href="#generics-bind-statement">Bind statement</a></h2><p>The <tt class="docutils literal"><span class="pre">bind</span></tt> statement is the counterpart to the <tt class="docutils literal"><span class="pre">mixin</span></tt> statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">lastId</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>But a <tt class="docutils literal"><span class="pre">bind</span></tt> is rarely useful because symbol binding from the definition scope is the default. </p>

<h1><a class="toc-backref" id="templates" href="#templates">Templates</a></h1><p>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</p>
<p>The syntax to <em>invoke</em> a template is the same as calling a procedure.</p>
<p>Example:</p>
<pre><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Comment"># this definition exists in the System module</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># the compiler rewrites that to: assert(not (5 == 6))</span></pre><p>The <tt class="docutils literal"><span class="pre">!=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt> operators are in fact templates:</p>
<p><tt class="docutils literal"><span class="pre">a &gt; b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">b &lt; a</span></tt>.<br /><tt class="docutils literal"><span class="pre">a in b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">contains(b, a)</span></tt>.<br /><tt class="docutils literal"><span class="pre">notin</span></tt> and <tt class="docutils literal"><span class="pre">isnot</span></tt> have the obvious meanings.<br /></p><p>The &quot;types&quot; of templates can be the symbols <tt class="docutils literal"><span class="pre">expr</span></tt> (stands for <em>expression</em>), <tt class="docutils literal"><span class="pre">stmt</span></tt> (stands for <em>statement</em>) or <tt class="docutils literal"><span class="pre">typedesc</span></tt> (stands for <em>type description</em>). These are &quot;meta types&quot;, they can only be used in certain contexts. Real types can be used too; this implies that expressions are expected.</p>

<h2><a class="toc-backref" id="templates-ordinary-vs-immediate-templates" href="#templates-ordinary-vs-immediate-templates">Ordinary vs immediate templates</a></h2><p>There are two different kinds of templates: immediate templates and ordinary templates. Ordinary templates take part in overloading resolution. As such their arguments need to be type checked before the template is invoked. So ordinary templates cannot receive undeclared identifiers:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: unknown identifier: 'x'</span></pre><p>An <tt class="docutils literal"><span class="pre">immediate</span></tt> template does not participate in overload resolution and so its arguments are not checked for semantics before invocation. So they can receive undeclared identifiers:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># valid</span></pre>
<h2><a class="toc-backref" id="templates-passing-a-code-block-to-a-template" href="#templates-passing-a-code-block-to-a-template">Passing a code block to a template</a></h2><p>If there is a <tt class="docutils literal"><span class="pre">stmt</span></tt> parameter it should be the last in the template declaration, because statements are passed to a template via a special <tt class="docutils literal"><span class="pre">:</span></tt> syntax:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">actions</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>In the example the two <tt class="docutils literal"><span class="pre">writeln</span></tt> statements are bound to the <tt class="docutils literal"><span class="pre">actions</span></tt> parameter.</p>

<h2><a class="toc-backref" id="templates-symbol-binding-in-templates" href="#templates-symbol-binding-in-templates">Symbol binding in templates</a></h2><p>A template is a <span id="hygienic_1">hygienic</span> macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># Works as 'lastId' has been bound in 'genId's defining scope</span></pre><p>As in generics symbol binding can be influenced via <tt class="docutils literal"><span class="pre">mixin</span></tt> or <tt class="docutils literal"><span class="pre">bind</span></tt> statements.</p>

<h2><a class="toc-backref" id="templates-identifier-construction" href="#templates-identifier-construction">Identifier construction</a></h2><p>In templates identifiers can be constructed with the backticks notation:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">typ</span>
    <span class="Punctuation">`</span><span class="Identifier">P</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span>

<span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">myint</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PMyInt</span></pre><p>In the example <tt class="docutils literal"><span class="pre">name</span></tt> is instantiated with <tt class="docutils literal"><span class="pre">myint</span></tt>, so `T name` becomes <tt class="docutils literal"><span class="pre">Tmyint</span></tt>.</p>

<h2><a class="toc-backref" id="templates-lookup-rules-for-template-parameters" href="#templates-lookup-rules-for-template-parameters">Lookup rules for template parameters</a></h2><p>A parameter <tt class="docutils literal"><span class="pre">p</span></tt> in a template is even substituted in the expression <tt class="docutils literal"><span class="pre">x.p</span></tt>. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</p>
<pre><span class="Comment"># module 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># produces: 'levA levA'</span></pre><p>But the global symbol can properly be captured by a <tt class="docutils literal"><span class="pre">bind</span></tt> statement:</p>
<pre><span class="Comment"># module 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># produces: 'levA levB'</span></pre>
<h2><a class="toc-backref" id="templates-hygiene-in-templates" href="#templates-hygiene-in-templates">Hygiene in templates</a></h2><p>Per default templates are <span id="hygienic_2">hygienic</span>: Local identifiers declared in a template cannot be accessed in the instantiation context:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">newException</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">exceptn</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">message</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Keyword">var</span>
    <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">exceptn</span>  <span class="Comment"># e is implicitly gensym'ed here</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
  <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">message</span>
  <span class="Identifier">e</span>

<span class="Comment"># so this works:</span>
<span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="StringLit">&quot;message&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EIO</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></pre><p>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the <span id="inject_1">inject</span> and <span id="gensym_1">gensym</span> pragmas: gensym'ed symbols are not exposed but inject'ed are.</p>
<p>The default for symbols of entity <tt class="docutils literal"><span class="pre">type</span></tt>, <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">let</span></tt> and <tt class="docutils literal"><span class="pre">const</span></tt> is <tt class="docutils literal"><span class="pre">gensym</span></tt> and for <tt class="docutils literal"><span class="pre">proc</span></tt>, <tt class="docutils literal"><span class="pre">iterator</span></tt>, <tt class="docutils literal"><span class="pre">converter</span></tt>, <tt class="docutils literal"><span class="pre">template</span></tt>, <tt class="docutils literal"><span class="pre">macro</span></tt> is <tt class="docutils literal"><span class="pre">inject</span></tt>. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>  <span class="Comment"># since 'f' is a template param, it's injected implicitly</span>
    <span class="Operator">...</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">inject</span></tt> and <tt class="docutils literal"><span class="pre">gensym</span></tt> pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span> <span class="Identifier">myInject</span><span class="Punctuation">:</span> <span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">myInject</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># does NOT work</span></pre><p>To get rid of hygiene in templates, one can use the <span id="dirty_1">dirty</span> pragma for a template. <tt class="docutils literal"><span class="pre">inject</span></tt> and <tt class="docutils literal"><span class="pre">gensym</span></tt> have no effect in <tt class="docutils literal"><span class="pre">dirty</span></tt> templates.</p>

<h2><a class="toc-backref" id="templates-limitations-of-the-method-call-syntax" href="#templates-limitations-of-the-method-call-syntax">Limitations of the method call syntax</a></h2><p>The expression <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">x.f</span></tt> needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to <tt class="docutils literal"><span class="pre">f(x)</span></tt>. Therefore the dot syntax has some limiations when it is used to invoke templates/macros:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareVar</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">const</span> <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Comment"># Doesn't compile:</span>
<span class="Identifier">unknownIdentifier</span><span class="Operator">.</span><span class="Identifier">declareVar</span></pre><p>Another common example is this:</p>
<pre><span class="Keyword">from</span> <span class="Identifier">sequtils</span> <span class="Keyword">import</span> <span class="Identifier">toSeq</span>

<span class="Keyword">iterator</span> <span class="Identifier">something</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;Hello&quot;</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;World&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">info</span> <span class="Operator">=</span> <span class="Identifier">toSeq</span><span class="Punctuation">(</span><span class="Identifier">something</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>The problem here is that the compiler already decided that <tt class="docutils literal"><span class="pre">something()</span></tt> as an iterator is not callable in this context before <tt class="docutils literal"><span class="pre">toSeq</span></tt> gets its chance to convert it into a sequence.</p>

<h1><a class="toc-backref" id="macros" href="#macros">Macros</a></h1><p>A macro is a special kind of low level template. Macros can be used to implement <span id="domain-specific-languages_1">domain specific languages</span>. Like templates, macros come in the 2 flavors <em>immediate</em> and <em>ordinary</em>.</p>
<p>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</p>
<p>To write macros, one needs to know how the Nim concrete syntax is converted to an abstract syntax tree.</p>
<p>There are two ways to invoke a macro:</p>
<ol class="simple"><li>invoking a macro like a procedure call (<cite>expression macros</cite>)</li>
<li>invoking a macro with the special <tt class="docutils literal"><span class="pre">macrostmt</span></tt> syntax (<cite>statement macros</cite>)</li>
</ol>

<h2><a class="toc-backref" id="macros-expression-macros" href="#macros-expression-macros">Expression Macros</a></h2><p>The following example implements a powerful <tt class="docutils literal"><span class="pre">debug</span></tt> command that accepts a variable number of arguments:</p>
<pre><span class="Comment"># to work with Nim syntax trees, we need an API that is defined in the</span>
<span class="Comment"># ``macros`` module:</span>
<span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># `n` is a Nim AST that contains the whole macro invocation</span>
  <span class="Comment"># this macro returns a list of statements:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Comment"># iterate over any argument that is passed to this macro:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Comment"># add a call to the statement list that writes the expression;</span>
    <span class="Comment"># `toStrLit` converts an AST to its string representation:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes &quot;: &quot;</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes the expressions value:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;writeln&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The macro call expands to:</p>
<pre><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>Arguments that are passed to a <tt class="docutils literal"><span class="pre">varargs</span></tt> parameter are wrapped in an array constructor expression. This is why <tt class="docutils literal"><span class="pre">debug</span></tt> iterates over all of <tt class="docutils literal"><span class="pre">n</span></tt>'s children.</p>

<h2><a class="toc-backref" id="macros-bindsym" href="#macros-bindsym">BindSym</a></h2><p>The above <tt class="docutils literal"><span class="pre">debug</span></tt> macro relies on the fact that <tt class="docutils literal"><span class="pre">write</span></tt>, <tt class="docutils literal"><span class="pre">writeln</span></tt> and <tt class="docutils literal"><span class="pre">stdout</span></tt> are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka <span id="symbols_1">symbols</span>) instead of using unbound identifiers. The <tt class="docutils literal"><span class="pre">bindSym</span></tt> builtin can be used for that:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Comment"># we can bind symbols in scope via 'bindSym':</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;writeln&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The macro call expands to:</p>
<pre><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>However, the symbols <tt class="docutils literal"><span class="pre">write</span></tt>, <tt class="docutils literal"><span class="pre">writeln</span></tt> and <tt class="docutils literal"><span class="pre">stdout</span></tt> are already bound and are not looked up again. As the example shows, <tt class="docutils literal"><span class="pre">bindSym</span></tt> does work with overloaded symbols implicitly.</p>

<h2><a class="toc-backref" id="macros-statement-macros" href="#macros-statement-macros">Statement Macros</a></h2><p>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</p>
<p>The following example outlines a macro that generates a lexical analyzer from regular expressions:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">case_token</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># creates a lexical analyzer from regular expressions</span>
  <span class="Comment"># ... (implementation is an exercise for the reader :-)</span>
  <span class="Keyword">discard</span>

<span class="Identifier">case_token</span><span class="Punctuation">:</span> <span class="Comment"># this colon tells the parser it is a macro statement</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[A-Za-z_]+[A-Za-z_0-9]*&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkIdentifier</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;0-9+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkInteger</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[\+\-\*\?]+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkOperator</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkUnknown</span></pre><p><strong>Style note</strong>: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</p>
<ol class="simple"><li>Use an ordinary proc/iterator, if possible.</li>
<li>Else: Use a generic proc/iterator, if possible.</li>
<li>Else: Use a template, if possible.</li>
<li>Else: Use a macro.</li>
</ol>

<h2><a class="toc-backref" id="macros-macros-as-pragmas" href="#macros-macros-as-pragmas">Macros as pragmas</a></h2><p>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">m</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>This is a simple syntactic transformation into:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">m</span><span class="Punctuation">:</span>
  <span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre>
<h1><a class="toc-backref" id="special-types" href="#special-types">Special Types(特殊类型)</a></h1>
<h2><a class="toc-backref" id="special-types-static-t" href="#special-types-static-t">static[T]</a></h2><p><strong>注</strong>: static[T] 依旧在开发中，那也就不客气了</p>
<h2><a class="toc-backref" id="special-types-typedesc" href="#special-types-typedesc">typedesc</a></h2><p><cite>typedesc</cite> is a special type allowing one to treat types as compile-time values (i.e. if types are compile-time values and all values have a type, then typedesc must be their type).</p>
<p>When used as a regular proc param, typedesc acts as a type class. The proc will be instantiated for each unique type parameter and one can refer to the instantiation type using the param name:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;allocating &quot;</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">name</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Operator">.</span><span class="Identifier">new</span>
<span class="Keyword">var</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>When multiple typedesc params are present, they act like a distinct type class (i.e. they will bind freely to different types). To force a bind-once behavior one can use a named alias or an explicit <cite>typedesc</cite> generic param:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">acceptOnlyTypePairs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">U</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">;</span> <span class="Identifier">C</span><span class="Punctuation">,</span> <span class="Identifier">D</span><span class="Punctuation">:</span> <span class="Identifier">U</span><span class="Punctuation">)</span></pre><p>Once bound, typedesc params can appear in the rest of the proc signature:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareVariableWithType</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Identifier">declareVariableWithType</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="DecNumber">42</span></pre><p>When used with macros and .compileTime. procs on the other hand, the compiler does not need to instantiate the code multiple times, because types then can be manipulated using the unified internal symbol representation. In such context typedesc acts as any other type. One can create variables, store typedesc values inside containers and so on. For example, here is how one can create a type-safe wrapper for the unsafe <cite>printf</cite> function from C:</p>
<pre><span class="Keyword">macro</span> <span class="Identifier">safePrintF</span><span class="Punctuation">(</span><span class="Identifier">formatString</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">for</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Identifier">formatChars</span><span class="Punctuation">(</span><span class="Identifier">formatString</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">expectedType</span> <span class="Operator">=</span> <span class="Keyword">case</span> <span class="Identifier">c</span>
      <span class="Keyword">of</span> <span class="CharLit">'c'</span><span class="Punctuation">:</span> <span class="Identifier">char</span>
      <span class="Keyword">of</span> <span class="CharLit">'d'</span><span class="Punctuation">,</span> <span class="CharLit">'i'</span><span class="Punctuation">,</span> <span class="CharLit">'x'</span><span class="Punctuation">,</span> <span class="CharLit">'X'</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
      <span class="Keyword">of</span> <span class="CharLit">'f'</span><span class="Punctuation">,</span> <span class="CharLit">'e'</span><span class="Punctuation">,</span> <span class="CharLit">'E'</span><span class="Punctuation">,</span> <span class="CharLit">'g'</span><span class="Punctuation">,</span> <span class="CharLit">'G'</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
      <span class="Keyword">of</span> <span class="CharLit">'s'</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
      <span class="Keyword">of</span> <span class="CharLit">'p'</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">EOutOfRange</span>
    
    <span class="Keyword">var</span> <span class="Identifier">actualType</span> <span class="Operator">=</span> <span class="Identifier">args</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">getType</span>
    <span class="Identifier">inc</span> <span class="Identifier">i</span>
    
    <span class="Keyword">if</span> <span class="Identifier">expectedType</span> <span class="Operator">==</span> <span class="Identifier">EOutOfRange</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span> <span class="Identifier">c</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot; is not a valid format character&quot;</span>
    <span class="Keyword">elif</span> <span class="Identifier">expectedType</span> <span class="Operator">!=</span> <span class="Identifier">actualType</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span> <span class="StringLit">&quot;type mismatch for argument &quot;</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="StringLit">&quot;. expected type: &quot;</span><span class="Punctuation">,</span>
            <span class="Identifier">expectedType</span><span class="Operator">.</span><span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;, actual type: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">actualType</span><span class="Operator">.</span><span class="Identifier">name</span>
  
  <span class="Comment"># keep the original callsite, but use cprintf instead</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">callsite</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="Operator">!</span><span class="StringLit">&quot;cprintf&quot;</span><span class="Punctuation">)</span></pre><p>Overload resolution can be further influenced by constraining the set of types that will match the typedesc param:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="Identifier">Inf</span>

<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">float</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">string</span><span class="Operator">.</span><span class="Identifier">maxval</span> <span class="Comment"># error, maxval is not implemented for string</span></pre><p>The constraint can be a concrete type or a type class.</p>

<h1><a class="toc-backref" id="special-operators" href="#special-operators">Special Operators(特殊操作符)</a></h1>
<h2><a class="toc-backref" id="special-operators-dot-operators" href="#special-operators-dot-operators">dot operators</a></h2><p>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</p>
<p>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is converted to an additional static string parameter:</p>
<pre><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Comment"># becomes `.`(a, &quot;b&quot;)</span>
<span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">)</span> <span class="Comment"># becomes `.`(a, &quot;b&quot;, c, d)</span></pre><p>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">js</span><span class="Punctuation">:</span> <span class="Identifier">PJsonNode</span><span class="Punctuation">,</span> <span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">JSON</span> <span class="Operator">=</span> <span class="Identifier">js</span><span class="Punctuation">[</span><span class="Identifier">field</span><span class="Punctuation">]</span>

<span class="Keyword">var</span> <span class="Identifier">js</span> <span class="Operator">=</span> <span class="Identifier">parseJson</span><span class="Punctuation">(</span><span class="StringLit">&quot;{ x: 1, y: 2}&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">js</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Comment"># outputs 1</span>
<span class="Identifier">echo</span> <span class="Identifier">js</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Comment"># outputs 2</span></pre><p>The following dot operators are available:</p>

<h2><a class="toc-backref" id="special-operators-operator" href="#special-operators-operator">operator <cite>.</cite></a></h2><p>This operator will be matched against both field accesses and method calls.</p>

<h2><a class="toc-backref" id="special-operators-operator" href="#special-operators-operator">operator <cite>.()</cite></a></h2><p>This operator will be matched exclusively against method calls. It has higher precedence than the <cite>.</cite> operator and this allows one to handle expressions like <cite>x.y</cite> and <cite>x.y()</cite> differently if one is interfacing with a scripting language for example.</p>

<h2><a class="toc-backref" id="special-operators-operator" href="#special-operators-operator">operator <cite>.=</cite></a></h2><p>This operator will be matched against assignments to missing fields.</p>
<pre><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">c</span> <span class="Comment"># becomes `.=`(a, &quot;b&quot;, c)</span></pre>
<h1><a class="toc-backref" id="type-bound-operations" href="#type-bound-operations">Type bound operations</a></h1><p>There are 3 operations that are bound to a type:</p>
<ol class="simple"><li>Assignment</li>
<li>Destruction</li>
<li>Deep copying for communication between threads</li>
</ol>
<p>These operations can be <em>overriden</em> instead of <em>overloaded</em>. This means the implementation is automatically lifted to structured types. For instance if type <tt class="docutils literal"><span class="pre">T</span></tt> has an overriden assignment operator <tt class="docutils literal"><span class="pre">=</span></tt> this operator is also used for assignments of the type <tt class="docutils literal"><span class="pre">seq[T]</span></tt>. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overriden <tt class="docutils literal"><span class="pre">deepCopy</span></tt> for <tt class="docutils literal"><span class="pre">ref T</span></tt> is really bound to <tt class="docutils literal"><span class="pre">T</span></tt> and not to <tt class="docutils literal"><span class="pre">ref T</span></tt>. This also means that one cannot override <tt class="docutils literal"><span class="pre">deepCopy</span></tt> for both <tt class="docutils literal"><span class="pre">ptr T</span></tt> and <tt class="docutils literal"><span class="pre">ref T</span></tt> at the same time; instead a helper distinct or object type has to be used for one pointer type.</p>

<h2><a class="toc-backref" id="type-bound-operations-operator" href="#type-bound-operations-operator">operator <cite>=</cite></a></h2><p>This operator is the assignment operator. Note that in the contexts <tt class="docutils literal"><span class="pre">result = expr</span></tt>, <tt class="docutils literal"><span class="pre">parameter = defaultValue</span></tt> or for parameter passing no assignment is performed. For a type <tt class="docutils literal"><span class="pre">T</span></tt> that has an overloaded assignment operator <tt class="docutils literal"><span class="pre">var v = T()</span></tt> is rewritten to <tt class="docutils literal"><span class="pre">var v: T; v = T()</span></tt>; in other words <tt class="docutils literal"><span class="pre">var</span></tt> and <tt class="docutils literal"><span class="pre">let</span></tt> contexts do count as assignments.</p>
<p>The assignment operator needs to be attached to an object or distinct type <tt class="docutils literal"><span class="pre">T</span></tt>. Its signature has to be <tt class="docutils literal"><span class="pre">(var T, T)</span></tt>. Example:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Concrete</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Concrete</span><span class="Punctuation">;</span> <span class="Identifier">src</span><span class="Punctuation">:</span> <span class="Identifier">Concrete</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">shallowCopy</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">src</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Identifier">shallowCopy</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">src</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Concrete '=' called&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">Concrete</span><span class="Punctuation">]</span>
<span class="Keyword">var</span> <span class="Identifier">cA</span><span class="Punctuation">,</span> <span class="Identifier">cB</span><span class="Punctuation">:</span> <span class="Identifier">Concrete</span>

<span class="Keyword">var</span> <span class="Identifier">cATup</span><span class="Punctuation">,</span> <span class="Identifier">cBTup</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">ha</span><span class="Punctuation">:</span> <span class="Identifier">Concrete</span><span class="Punctuation">]</span>

<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">y</span>
<span class="Identifier">cA</span> <span class="Operator">=</span> <span class="Identifier">cB</span>
<span class="Identifier">cATup</span> <span class="Operator">=</span> <span class="Identifier">cBTup</span></pre>
<h2><a class="toc-backref" id="type-bound-operations-destructors" href="#type-bound-operations-destructors">destructors</a></h2><p>A destructor must have a single parameter with a concrete type (the name of a generic type is allowed too). The name of the destructor has to be <tt class="docutils literal"><span class="pre">=destroy</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">=destroy(v)</span></tt> will be automatically invoked for every local stack variable <tt class="docutils literal"><span class="pre">v</span></tt> that goes out of scope.</p>
<p>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</p>
<p>A destructor is attached to the type it destructs; expressions of this type can then only be used in <em>destructible contexts</em> and as parameters:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">o</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">MyObj</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">dealloc</span> <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">p</span>

<span class="Keyword">proc</span> <span class="Identifier">open</span><span class="Punctuation">:</span> <span class="Identifier">MyObj</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">MyObj</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">alloc</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">work</span><span class="Punctuation">(</span><span class="Identifier">o</span><span class="Punctuation">:</span> <span class="Identifier">MyObj</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Comment"># No destructor invoked here for 'o' as 'o' is a parameter.</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># destructor automatically invoked at the end of the scope:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># valid: pass 'x' to some other proc:</span>
  <span class="Identifier">work</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
  
  <span class="Comment"># Error: usage of a type with a destructor in a non destructible context</span>
  <span class="Identifier">echo</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>A destructible context is currently only the following:</p>
<ol class="simple"><li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">var x = expr</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">let x = expr</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">return expr</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">result = expr</span></tt> where <tt class="docutils literal"><span class="pre">result</span></tt> is the special symbol introduced by the compiler.</li>
</ol>
<p>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</p>
<p>Be aware that destructors are not called for objects allocated with <tt class="docutils literal"><span class="pre">new</span></tt>. This may change in future versions of language, but for now the <span id="finalizer_1">finalizer</span> parameter to <tt class="docutils literal"><span class="pre">new</span></tt> has to be used.</p>
<p><strong>Note</strong>: Destructors are still experimental and the spec might change significantly in order to incorporate an escape analysis.</p>

<h2><a class="toc-backref" id="type-bound-operations-deepcopy" href="#type-bound-operations-deepcopy">deepCopy(深度拷贝)</a></h2>
<p>当数据传递给一个<tt class="docutils literal"><span class="pre">spawn</span></tt>的过程时，<tt class="docutils literal"><span class="pre">=deepCopy</span></tt> 将被默认调用以保证内存安全。<br/>
我们也能为<tt class="docutils literal"><span class="pre">T</span></tt>的 <tt class="docutils literal"><span class="pre">ref</span></tt> 或 <tt class="docutils literal"><span class="pre">ptr</span></tt>类型提供定制化的覆盖实现。</p>
<p>形式如下:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">deepCopy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span></pre>
<p>这个方法也能被需要支持共享内存时的大部分支持共享内存的数据结构(如:channel)用来自动内存管理时的线程安全需求。</p>
<p>内置过程 <tt class="docutils literal"><span class="pre">deepCopy</span></tt> 甚至能够复制闭包以及他们的环境情况，细节见 <a class="reference external" href="#spawn">spawn</a> 文档</p>

<h1><a class="toc-backref" id="term-rewriting-macros" href="#term-rewriting-macros">Term rewriting macros</a></h1><p>Term rewriting macros are macros or templates that have not only a <em>name</em> but also a <em>pattern</em> that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="DecNumber">2</span></pre><p>The compiler now rewrites <tt class="docutils literal"><span class="pre">x * 2</span></tt> as <tt class="docutils literal"><span class="pre">x + x</span></tt>. The code inside the curlies is the pattern to match against. The operators <tt class="docutils literal"><span class="pre">*</span></tt>,  <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt> have a special meaning in patterns if they are written in infix notation, so to match verbatim against <tt class="docutils literal"><span class="pre">*</span></tt> the ordinary function call syntax needs to be used.</p>
<p>Unfortunately optimizations are hard to get right and even the tiny example is <strong>wrong</strong>:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;side effect!&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">55</span>

<span class="Identifier">echo</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="DecNumber">2</span></pre><p>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">noSideEffect</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;side effect!&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">55</span>

<span class="Identifier">echo</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="DecNumber">2</span> <span class="Comment"># not optimized ;-)</span></pre><p>So what about <tt class="docutils literal"><span class="pre">2 * a</span></tt>? We should tell the compiler <tt class="docutils literal"><span class="pre">*</span></tt> is commutative. We cannot really do that however as the following code only swaps arguments blindly:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">mulIsCommutative</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">a</span></pre><p>What optimizers really need to do is a <em>canonicalization</em>:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">canonMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">a</span></pre><p>The <tt class="docutils literal"><span class="pre">int{lit}</span></tt> parameter pattern matches against an expression of type <tt class="docutils literal"><span class="pre">int</span></tt>, but only if it's a literal.</p>

<h2><a class="toc-backref" id="term-rewriting-macros-parameter-constraints" href="#term-rewriting-macros-parameter-constraints">Parameter constraints</a></h2><p>The <span id="parameter-constraint_1">parameter constraint</span> expression can use the operators <tt class="docutils literal"><span class="pre">|</span></tt> (or), <tt class="docutils literal"><span class="pre">&amp;</span></tt> (and) and <tt class="docutils literal"><span class="pre">~</span></tt> (not) and the following predicates:</p>
<table border="1" class="docutils"><tr><th>Predicate</th><th>Meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">atom</span></tt></td><td>The matching node has no children.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">lit</span></tt></td><td>The matching node is a literal like &quot;abc&quot;, 12.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">sym</span></tt></td><td>The matching node must be a symbol (a bound identifier).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ident</span></tt></td><td>The matching node must be an identifier (an unbound identifier).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">call</span></tt></td><td>The matching AST must be a call/apply expression.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">lvalue</span></tt></td><td>The matching AST must be an lvalue.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">sideeffect</span></tt></td><td>The matching AST must have a side effect.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">nosideeffect</span></tt></td><td>The matching AST must have no side effect.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">param</span></tt></td><td>A symbol which is a parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">genericparam</span></tt></td><td>A symbol which is a generic parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">module</span></tt></td><td>A symbol which is a module.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">type</span></tt></td><td>A symbol which is a type.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">var</span></tt></td><td>A symbol which is a variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">let</span></tt></td><td>A symbol which is a <tt class="docutils literal"><span class="pre">let</span></tt> variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">const</span></tt></td><td>A symbol which is a constant.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">result</span></tt></td><td>The special <tt class="docutils literal"><span class="pre">result</span></tt> variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">proc</span></tt></td><td>A symbol which is a proc.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">method</span></tt></td><td>A symbol which is a method.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">iterator</span></tt></td><td>A symbol which is an iterator.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">converter</span></tt></td><td>A symbol which is a converter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">macro</span></tt></td><td>A symbol which is a macro.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span></tt></td><td>A symbol which is a template.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">field</span></tt></td><td>A symbol which is a field in a tuple or an object.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">enumfield</span></tt></td><td>A symbol which is a field in an enumeration.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">forvar</span></tt></td><td>A for loop variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">label</span></tt></td><td>A label (used in <tt class="docutils literal"><span class="pre">block</span></tt> statements).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">nk*</span></tt></td><td>The matching AST must have the specified kind. (Example: <tt class="docutils literal"><span class="pre">nkIfStmt</span></tt> denotes an <tt class="docutils literal"><span class="pre">if</span></tt> statement.)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">alias</span></tt></td><td>States that the marked parameter needs to alias with <em>some</em> other parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">noalias</span></tt></td><td>States that <em>every</em> other parameter must not alias with the marked parameter.</td></tr>
</table><p>The <tt class="docutils literal"><span class="pre">alias</span></tt> and <tt class="docutils literal"><span class="pre">noalias</span></tt> predicates refer not only to the matching AST, but also to every other bound parameter; syntactially they need to occur after the ordinary AST predicates:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">ex</span><span class="Punctuation">{</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">noalias</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># this transformation is only valid if 'b' and 'c' do not alias 'a':</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span>
  <span class="Identifier">inc</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">c</span></pre>
<h2><a class="toc-backref" id="term-rewriting-macros-pattern-operators" href="#term-rewriting-macros-pattern-operators">Pattern operators</a></h2><p>The operators <tt class="docutils literal"><span class="pre">*</span></tt>,  <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt> have a special meaning in patterns if they are written in infix notation.</p>

<h3><a class="toc-backref" id="pattern-operators-the-operator" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">|</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">|</span></tt> operator if used as infix operator creates an ordered choice:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Comment"># outputs 3:</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre><p>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Comment"># outputs 1:</span>
<span class="Identifier">echo</span> <span class="DecNumber">1</span></pre><p>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the <tt class="docutils literal"><span class="pre">echo</span></tt> statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactived with the <tt class="docutils literal"><span class="pre">--patterns:off</span></tt> command line option or temporarily with the <tt class="docutils literal"><span class="pre">patterns</span></tt> pragma.</p>

<h3><a class="toc-backref" id="pattern-operators-the-operator" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">{}</span></tt> operator</a></h3><p>A pattern expression can be bound to a pattern parameter via the <tt class="docutils literal"><span class="pre">expr{param}</span></tt> notation:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Operator">|</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">x</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">+</span><span class="DecNumber">1</span>
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Comment"># outputs 2:</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre>
<h3><a class="toc-backref" id="pattern-operators-the-operator" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">~</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">~</span></tt> operator is the <strong>not</strong> operator in patterns:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Operator">~</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">y</span><span class="Punctuation">}</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Operator">~</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">z</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">y</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">z</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">and</span> <span class="Identifier">c</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre>
<h3><a class="toc-backref" id="pattern-operators-the-operator" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">*</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">*</span></tt> operator can <em>flatten</em> a nested binary expression like <tt class="docutils literal"><span class="pre">a &amp; b &amp; c</span></tt> to <tt class="docutils literal"><span class="pre">&amp;(a, b, c)</span></tt>:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">calls</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">inc</span> <span class="Identifier">calls</span>

<span class="Keyword">template</span> <span class="Identifier">optConc</span><span class="Punctuation">{</span> <span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Identifier">a</span> <span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Operator">&amp;&amp;</span><span class="Identifier">a</span>

<span class="Keyword">let</span> <span class="Identifier">space</span> <span class="Operator">=</span> <span class="StringLit">&quot; &quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;my&quot;</span> <span class="Operator">&amp;&amp;</span> <span class="Punctuation">(</span><span class="Identifier">space</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;awe&quot;</span> <span class="Operator">&amp;&amp;</span> <span class="StringLit">&quot;some &quot;</span> <span class="Punctuation">)</span> <span class="Operator">&amp;&amp;</span> <span class="StringLit">&quot;concat&quot;</span>

<span class="Comment"># check that it's been optimized properly:</span>
<span class="Identifier">doAssert</span> <span class="Identifier">calls</span> <span class="Operator">==</span> <span class="DecNumber">1</span></pre><p>The second operator of <cite>*</cite> must be a parameter; it is used to gather all the arguments. The expression <tt class="docutils literal"><span class="pre">&quot;my&quot; &amp;&amp; (space &amp; &quot;awe&quot; &amp;&amp; &quot;some &quot; ) &amp;&amp; &quot;concat&quot;</span></tt> is passed to <tt class="docutils literal"><span class="pre">optConc</span></tt> in <tt class="docutils literal"><span class="pre">a</span></tt> as a special list (of kind <tt class="docutils literal"><span class="pre">nkArgList</span></tt>) which is flattened into a call expression; thus the invocation of <tt class="docutils literal"><span class="pre">optConc</span></tt> produces:</p>
<pre><span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="StringLit">&quot;my&quot;</span><span class="Punctuation">,</span> <span class="Identifier">space</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;awe&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;some &quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;concat&quot;</span><span class="Punctuation">)</span></pre>
<h3><a class="toc-backref" id="pattern-operators-the-operator" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">**</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">**</span></tt> is much like the <tt class="docutils literal"><span class="pre">*</span></tt> operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">type</span>
  <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">dummy</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">dummy</span>
<span class="Keyword">proc</span> <span class="Identifier">mat21</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">dummy</span> <span class="Operator">=</span> <span class="DecNumber">21</span>

<span class="Keyword">macro</span> <span class="Identifier">optM</span><span class="Punctuation">{</span> <span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">)</span> <span class="Operator">**</span> <span class="Identifier">a</span> <span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">treeRepr</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;mat21&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span>

<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Operator">*</span> <span class="Identifier">z</span> <span class="Operator">-</span> <span class="Identifier">x</span></pre><p>This passes the expression <tt class="docutils literal"><span class="pre">x + y * z - x</span></tt> to the <tt class="docutils literal"><span class="pre">optM</span></tt> macro as an <tt class="docutils literal"><span class="pre">nnkArgList</span></tt> node containing:<pre>
Arglist
  Sym &quot;x&quot;
  Sym &quot;y&quot;
  Sym &quot;z&quot;
  Sym &quot;*&quot;
  Sym &quot;+&quot;
  Sym &quot;x&quot;
  Sym &quot;-&quot;</pre>
</p>
<p>(Which is the reverse polish notation of <tt class="docutils literal"><span class="pre">x + y * z - x</span></tt>.)</p>

<h2><a class="toc-backref" id="term-rewriting-macros-parameters" href="#term-rewriting-macros-parameters">Parameters</a></h2><p>Parameters in a pattern are type checked in the matching process. If a parameter is of the type <tt class="docutils literal"><span class="pre">varargs</span></tt> it is treated specially and it can match 0 or more arguments in the AST to be matched against:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optWrite</span><span class="Punctuation">{</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span>
  <span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">write</span><span class="Operator">|</span><span class="Identifier">writeln</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">w</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span>
<span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">w</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">w</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="term-rewriting-macros-example-partial-evaluation" href="#term-rewriting-macros-example-partial-evaluation">Example: Partial evaluation</a></h2><p>The following example shows how some simple partial evaluation can be implemented with term rewriting:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">-</span> <span class="Identifier">y</span>

<span class="Keyword">template</span> <span class="Identifier">optP1</span><span class="Punctuation">{</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">template</span> <span class="Identifier">optP2</span><span class="Punctuation">{</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">false</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">-</span> <span class="Identifier">y</span></pre>
<h2><a class="toc-backref" id="term-rewriting-macros-example-hoisting" href="#term-rewriting-macros-example-hoisting">Example: Hoisting</a></h2><p>The following example shows how some form of hoisting can be implemented:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">pegs</span>

<span class="Keyword">template</span> <span class="Identifier">optPeg</span><span class="Punctuation">{</span><span class="Identifier">peg</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Peg</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">gl</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Punctuation">,</span> <span class="Identifier">gensym</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">peg</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Identifier">gl</span>

<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="DecNumber">3</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">match</span><span class="Punctuation">(</span><span class="StringLit">&quot;(a b c)&quot;</span><span class="Punctuation">,</span> <span class="RawData">peg&quot;'(' @ ')'&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="Identifier">match</span><span class="Punctuation">(</span><span class="StringLit">&quot;W_HI_Le&quot;</span><span class="Punctuation">,</span> <span class="RawData">peg&quot;\y 'while'&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">optPeg</span></tt> template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global <tt class="docutils literal"><span class="pre">gl</span></tt> which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</p>

<h1><a class="toc-backref" id="ast-based-overloading" href="#ast-based-overloading">AST based overloading</a></h1><p>Parameter constraints can also be used for ordinary routine parameters; these constraints affect ordinary overloading resolution then:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Keyword">const</span><span class="Punctuation">`</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;string literal&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;no string literal&quot;</span>

<span class="Keyword">const</span>
  <span class="Identifier">constant</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Keyword">var</span>
  <span class="Identifier">variable</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>

<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="StringLit">&quot;literal&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">constant</span><span class="Punctuation">)</span>
<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">variable</span><span class="Punctuation">)</span></pre><p>However, the constraints <tt class="docutils literal"><span class="pre">alias</span></tt> and <tt class="docutils literal"><span class="pre">noalias</span></tt> are not available in ordinary routines.</p>

<h2><a class="toc-backref" id="ast-based-overloading-move-optimization" href="#ast-based-overloading-move-optimization">Move optimization</a></h2><p>The <tt class="docutils literal"><span class="pre">call</span></tt> constraint is particularly useful to implement a move optimization for types that have copying semantics:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Table</span><span class="Punctuation">,</span> <span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment">## puts a (key, value)-pair into `t`. The semantics of string require</span>
  <span class="Comment">## a copy here:</span>
  <span class="Keyword">let</span> <span class="Identifier">idx</span> <span class="Operator">=</span> <span class="Identifier">findInsertionPosition</span><span class="Punctuation">(</span><span class="Identifier">key</span><span class="Punctuation">)</span>
  <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">key</span>
  <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">val</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Table</span><span class="Punctuation">,</span> <span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">call</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">call</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment">## puts a (key, value)-pair into `t`. Optimized version that knows that</span>
  <span class="Comment">## the strings are unique and thus don't need to be copied:</span>
  <span class="Keyword">let</span> <span class="Identifier">idx</span> <span class="Operator">=</span> <span class="Identifier">findInsertionPosition</span><span class="Punctuation">(</span><span class="Identifier">key</span><span class="Punctuation">)</span>
  <span class="Identifier">shallowCopy</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">key</span>
  <span class="Identifier">shallowCopy</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">val</span>

<span class="Keyword">var</span> <span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">Table</span>
<span class="Comment"># overloading resolution ensures that the optimized []= is called here:</span>
<span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">g</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="modules" href="#modules">Modules</a></h1><p>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own <span id="namespace_1">namespace</span>. Modules enable <span id="information-hiding_1">information hiding</span> and <span id="separate-compilation_1">separate compilation</span>. A module may gain access to symbols of another module by the <span id="import_1">import</span> statement. <span id="recursive-module-dependencies_1">Recursive module dependencies</span> are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (<tt class="docutils literal"><span class="pre">*</span></tt>) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is <tt class="docutils literal"><span class="pre">identifier.nim</span></tt>).</p>
<p>The algorithm for compiling modules is:</p>
<ul class="simple"><li>compile the whole module as usual, following import statements recursively</li>
<li>if there is a cycle only import the already parsed symbols (that are exported); if an unknown identifier occurs then abort</li>
</ul>
<p>This is best illustrated by an example:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">type</span>
  <span class="Identifier">T1</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">int</span>  <span class="Comment"># Module A exports the type ``T1``</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>     <span class="Comment"># the compiler starts parsing B</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># works because B has been parsed completely here</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>  <span class="Comment"># A is not parsed here! Only the already known symbols</span>
          <span class="Comment"># of A are imported.</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span> <span class="Operator">=</span>
  <span class="Comment"># this works because the compiler has already</span>
  <span class="Comment"># added T1 to A's interface symbol table</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">1</span></pre>
<h3><a class="toc-backref" id="modules-import-statement" href="#modules-import-statement">Import statement</a></h3><p>After the <tt class="docutils literal"><span class="pre">import</span></tt> statement a list of module names can follow or a single module name followed by an <tt class="docutils literal"><span class="pre">except</span></tt> list to prevent some symbols to be imported:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">except</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="Identifier">toUpper</span>

<span class="Comment"># doesn't work then:</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span></pre><p>It is not checked that the <tt class="docutils literal"><span class="pre">except</span></tt> list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.</p>

<h3><a class="toc-backref" id="modules-include-statement" href="#modules-include-statement">Include statement</a></h3><p>The <tt class="docutils literal"><span class="pre">include</span></tt> statement does something fundamentally different than importing a module: it merely includes the contents of a file. The <tt class="docutils literal"><span class="pre">include</span></tt> statement is useful to split up a large module into several files:</p>
<pre><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre>
<h3><a class="toc-backref" id="modules-module-names-in-imports" href="#modules-module-names-in-imports">Module names in imports</a></h3><p>A module alias can be introduced via the <tt class="docutils literal"><span class="pre">as</span></tt> keyword:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">su</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span> <span class="Keyword">as</span> <span class="Identifier">qu</span>

<span class="Identifier">echo</span> <span class="Identifier">su</span><span class="Operator">.</span><span class="Identifier">format</span><span class="Punctuation">(</span><span class="StringLit">&quot;$1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lalelu&quot;</span><span class="Punctuation">)</span></pre><p>The original module name is then not accessible. The notations <tt class="docutils literal"><span class="pre">path/to/module</span></tt> or <tt class="docutils literal"><span class="pre">path.to.module</span></tt> or <tt class="docutils literal"><span class="pre">&quot;path/to/module&quot;</span></tt> can be used to refer to a module in subdirectories:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">os</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lib/pure/times&quot;</span></pre><p>Note that the module name is still <tt class="docutils literal"><span class="pre">strutils</span></tt> and not <tt class="docutils literal"><span class="pre">lib.pure.strutils</span></tt> and so one <strong>cannot</strong> do:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span>
<span class="Identifier">echo</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span></pre><p>Likewise the following does not make sense as the name is <tt class="docutils literal"><span class="pre">strutils</span></tt> already:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">strutils</span></pre>
<h3><a class="toc-backref" id="modules-from-import-statement" href="#modules-from-import-statement">From import statement</a></h3><p>After the <tt class="docutils literal"><span class="pre">from</span></tt> statement a module name follows followed by an <tt class="docutils literal"><span class="pre">import</span></tt> to list the symbols one likes to use without explict full qualification:</p>
<pre><span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Comment"># always possible: full qualification:</span>
<span class="Identifier">echo</span> <span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;z&quot;</span><span class="Punctuation">)</span></pre><p>It's also possible to use <tt class="docutils literal"><span class="pre">from module import nil</span></tt> if one wants to import the module but wants to enforce fully qualified access to every symbol in <tt class="docutils literal"><span class="pre">module</span></tt>.</p>

<h3><a class="toc-backref" id="modules-export-statement" href="#modules-export-statement">Export statement</a></h3><p>An <tt class="docutils literal"><span class="pre">export</span></tt> statement can be used for symbol fowarding so that client modules don't need to import a module's dependencies:</p>
<pre><span class="Comment"># module B</span>
<span class="Keyword">type</span> <span class="Identifier">MyObject</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre><pre><span class="Comment"># module A</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>
<span class="Keyword">export</span> <span class="Identifier">B</span><span class="Operator">.</span><span class="Identifier">MyObject</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;my object&quot;</span></pre><pre><span class="Comment"># module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Comment"># B.MyObject has been imported implicitly here:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="modules-scope-rules" href="#modules-scope-rules">Scope rules</a></h2><p>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</p>

<h3><a class="toc-backref" id="scope-rules-block-scope" href="#scope-rules-block-scope">Block scope</a></h3><p>The <em>scope</em> of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</p>

<h3><a class="toc-backref" id="scope-rules-tuple-or-object-scope" href="#scope-rules-tuple-or-object-scope">Tuple or object scope</a></h3><p>The field identifiers inside a tuple or object definition are valid in the following places:</p>
<ul class="simple"><li>To the end of the tuple/object definition.</li>
<li>Field designators of a variable of the given tuple/object type.</li>
<li>In all descendant types of the object type.</li>
</ul>

<h3><a class="toc-backref" id="scope-rules-module-scope" href="#scope-rules-module-scope">Module scope</a></h3><p>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are <em>not</em> available. The <span id="system_1">system</span> module is automatically imported in every other module.</p>
<p>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre><pre><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: x is ambiguous</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># no error: qualifier used</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># not ambiguous: uses the module C's x</span></pre>
<h1><a class="toc-backref" id="compiler-messages" href="#compiler-messages">Compiler Messages</a></h1><p>The Nim compiler emits different kinds of messages: <span id="hint_1">hint</span>, <span id="warning_1">warning</span>, and <span id="error_1">error</span> messages. An <em>error</em> message is emitted if the compiler encounters any static error.</p>

<h1><a class="toc-backref" id="pragmas" href="#pragmas">Pragmas</a></h1><p>Pragmas are Nim's method to give the compiler additional information / commands without introducing a massive number of new keywords. Pragmas are processed on the fly during semantic checking. Pragmas are enclosed in the special <tt class="docutils literal"><span class="pre">{.</span></tt> and <tt class="docutils literal"><span class="pre">.}</span></tt> curly brackets. Pragmas are also often used as a first implementation to play with a language feature before a nicer syntax to access the feature becomes available.</p>

<h2><a class="toc-backref" id="pragmas-deprecated-pragma" href="#pragmas-deprecated-pragma">deprecated pragma</a></h2><p>The deprecated pragma is used to mark a symbol as deprecated:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">char</span></pre><p>It can also be used as a statement. Then it takes a list of <em>renamings</em>. The upcoming <tt class="docutils literal"><span class="pre">nimfix</span></tt> tool can automatically update the code and perform these renamings:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">File</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">Stream</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">TFile</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">PStream</span><span class="Punctuation">:</span> <span class="Identifier">Stream</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="pragmas-nosideeffect-pragma" href="#pragmas-nosideeffect-pragma">noSideEffect pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">noSideEffect</span></tt> pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type <tt class="docutils literal"><span class="pre">var T</span></tt> or <tt class="docutils literal"><span class="pre">ref T</span></tt> or <tt class="docutils literal"><span class="pre">ptr T</span></tt> this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</p>
<p>As a special semantic rule, the built-in <a class="reference external" href="system.html#debugEcho">debugEcho</a> pretends to be free of side effects, so that it can be used for debugging routines marked as <tt class="docutils literal"><span class="pre">noSideEffect</span></tt>.</p>
<p><strong>Future directions</strong>: <tt class="docutils literal"><span class="pre">func</span></tt> may become a keyword and syntactic sugar for a proc with no side effects:</p>
<pre><span class="Keyword">func</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre>
<h2><a class="toc-backref" id="pragmas-destructor-pragma" href="#pragmas-destructor-pragma">destructor pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">destructor</span></tt> pragma is used to mark a proc to act as a type destructor. Its usage is deprecated, use the <tt class="docutils literal"><span class="pre">override</span></tt> pragma instead. See <a class="reference external" href="#type-bound-operations">type bound operations</a>.</p>

<h2><a class="toc-backref" id="pragmas-override-pragma" href="#pragmas-override-pragma">override pragma</a></h2><p>See <a class="reference external" href="#type-bound-operations">type bound operations</a> instead.</p>

<h2><a class="toc-backref" id="pragmas-procvar-pragma" href="#pragmas-procvar-pragma">procvar pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">procvar</span></tt> pragma is used to mark a proc that it can be passed to a procedural variable.</p>

<h2><a class="toc-backref" id="pragmas-compiletime-pragma" href="#pragmas-compiletime-pragma">compileTime pragma(compileTime编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">compileTime</span></tt> 编译指示用来标记过程或则变量只在编译期使用，将不会产生相关的代码。编译期的过程在编写宏时非常有用。</p>

<h2><a class="toc-backref" id="pragmas-noreturn-pragma" href="#pragmas-noreturn-pragma">noReturn pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">noreturn</span></tt> pragma is used to mark a proc that never returns.</p>

<h2><a class="toc-backref" id="pragmas-acyclic-pragma" href="#pragmas-acyclic-pragma">acyclic pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an <strong>optimization</strong> for the garbage collector to not consider objects of this type as part of a cycle:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">acyclic</span><span class="Punctuation">,</span> <span class="Identifier">final</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre><p>In the example a tree structure is declared with the <tt class="docutils literal"><span class="pre">Node</span></tt> type. Note that the type definition is recursive and the GC has to assume that objects of this type may form a cyclic graph. The <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma passes the information that this cannot happen to the GC. If the programmer uses the <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma for data types that are in reality cyclic, the GC may leak memory, but nothing worse happens.</p>
<p><strong>Future directions</strong>: The <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma may become a property of a <tt class="docutils literal"><span class="pre">ref</span></tt> type:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Identifier">acyclic</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre>
<h2><a class="toc-backref" id="pragmas-final-pragma" href="#pragmas-final-pragma">final pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">final</span></tt> pragma can be used for an object type to specify that it cannot be inherited from.</p>

<h2><a class="toc-backref" id="pragmas-shallow-pragma" href="#pragmas-shallow-pragma">shallow pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">shallow</span></tt> pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">,</span> <span class="Identifier">nkInner</span>
  <span class="Identifier">Node</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">final</span><span class="Punctuation">,</span> <span class="Identifier">shallow</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>
    <span class="Keyword">of</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">:</span>
      <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInner</span><span class="Punctuation">:</span>
      <span class="Identifier">children</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Node</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="pragmas-pure-pragma" href="#pragmas-pure-pragma">pure pragma</a></h2><p>An object type can be marked with the <tt class="docutils literal"><span class="pre">pure</span></tt> pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</p>
<p>An enum type can be marked as <tt class="docutils literal"><span class="pre">pure</span></tt>. Then access of its fields always requires full qualification.</p>

<h2><a class="toc-backref" id="pragmas-asmnostackframe-pragma" href="#pragmas-asmnostackframe-pragma">asmNoStackFrame pragma</a></h2><p>A proc can be marked with the <tt class="docutils literal"><span class="pre">AsmNoStackFrame</span></tt> pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like <tt class="docutils literal"><span class="pre">return result;</span></tt> generated and the generated C function is declared as <tt class="docutils literal"><span class="pre">__declspec(naked)</span></tt> or <tt class="docutils literal"><span class="pre">__attribute__((naked))</span></tt> (depending on the used C compiler).</p>
<p><strong>Note</strong>: This pragma should only be used by procs which consist solely of assembler statements.</p>

<h2><a class="toc-backref" id="pragmas-error-pragma" href="#pragmas-error-pragma">error pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">error</span></tt> pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</p>
<p>The <tt class="docutils literal"><span class="pre">error</span></tt> pragma can also be used to annotate a symbol (like an iterator or proc). The <em>usage</em> of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</p>
<pre><span class="Comment">## check that underlying int values are compared and not the pointers:</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="pragmas-fatal-pragma" href="#pragmas-fatal-pragma">fatal pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">fatal</span></tt> pragma is used to make the compiler output an error message with the given content. In contrast to the <tt class="docutils literal"><span class="pre">error</span></tt> pragma, compilation is guaranteed to be aborted by this pragma. Example:</p>
<pre><span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">objc</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">fatal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Compile this program with the objc command!&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="pragmas-warning-pragma" href="#pragmas-warning-pragma">warning pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">warning</span></tt> pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</p>

<h2><a class="toc-backref" id="pragmas-hint-pragma" href="#pragmas-hint-pragma">hint pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">hint</span></tt> pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</p>

<h2><a class="toc-backref" id="pragmas-line-pragma" href="#pragmas-line-pragma">line pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">line</span></tt> pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">myassert</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Comment"># change run-time line information of the 'raise' statement:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">InstantiationInfo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EAssertionFailed</span><span class="Punctuation">,</span> <span class="Identifier">msg</span><span class="Punctuation">)</span></pre><p>If the <tt class="docutils literal"><span class="pre">line</span></tt> pragma is used with a parameter, the parameter needs be a <tt class="docutils literal"><span class="pre">tuple[filename: string, line: int]</span></tt>. If it is used without a parameter, <tt class="docutils literal"><span class="pre">system.InstantiationInfo()</span></tt> is used.</p>

<h2><a class="toc-backref" id="pragmas-linearscanend-pragma" href="#pragmas-linearscanend-pragma">linearScanEnd pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> pragma can be used to tell the compiler how to compile a Nim <span id="case_1">case</span> statement. Syntactically it has to be used as a statement:</p>
<pre><span class="Keyword">case</span> <span class="Identifier">myInt</span>
<span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">linearScanEnd</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;second most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely: use branch table&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely too: use branch table for &quot;</span><span class="Punctuation">,</span> <span class="Identifier">myInt</span></pre><p>In the example, the case branches <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt> are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.</p>
<p>The <tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole <tt class="docutils literal"><span class="pre">case</span></tt> statement, the whole <tt class="docutils literal"><span class="pre">case</span></tt> statement uses linear scanning.</p>

<h2><a class="toc-backref" id="pragmas-computedgoto-pragma" href="#pragmas-computedgoto-pragma">computedGoto pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">computedGoto</span></tt> pragma can be used to tell the compiler how to compile a Nim <span id="case_2">case</span> in a <tt class="docutils literal"><span class="pre">while true</span></tt> statement. Syntactically it has to be used as a statement inside the loop:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">enumA</span><span class="Punctuation">,</span> <span class="Identifier">enumB</span><span class="Punctuation">,</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">,</span> <span class="Identifier">enumE</span>

<span class="Keyword">proc</span> <span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">instructions</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">100</span><span class="Punctuation">,</span> <span class="Identifier">MyEnum</span><span class="Punctuation">]</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">7</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">8</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumB</span>
  
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumE</span>
  <span class="Keyword">var</span> <span class="Identifier">pc</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">computedGoto</span><span class="Operator">.</span><span class="Punctuation">}</span>
    <span class="Keyword">let</span> <span class="Identifier">instr</span> <span class="Operator">=</span> <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="Identifier">pc</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">instr</span>
    <span class="Keyword">of</span> <span class="Identifier">enumA</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah A&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah CD&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumB</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah B&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumE</span><span class="Punctuation">:</span>
      <span class="Keyword">break</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">pc</span><span class="Punctuation">)</span>

<span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>As the example shows <tt class="docutils literal"><span class="pre">computedGoto</span></tt> is mostly useful for interpreters. If the underlying backend (C compiler) does not support the computed goto extension the pragma is simply ignored.</p>

<h2><a class="toc-backref" id="pragmas-unroll-pragma" href="#pragmas-unroll-pragma">unroll pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">unroll</span></tt> pragma can be used to tell the compiler that it should unroll a <span id="for_2">for</span> or <span id="while_1">while</span> loop for runtime efficiency:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">searchChar</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unroll</span><span class="Punctuation">:</span> <span class="FloatNumber">4.</span><span class="Punctuation">}</span>
    <span class="Keyword">if</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">i</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span></pre><p>In the above example, the search loop is unrolled by a factor 4. The unroll factor can be left out too; the compiler then chooses an appropriate unroll factor.</p>
<p><strong>Note</strong>: Currently the compiler recognizes but ignores this pragma.</p>

<h2><a class="toc-backref" id="pragmas-immediate-pragma" href="#pragmas-immediate-pragma">immediate pragma</a></h2><p>See <a class="reference external" href="#ordinary-vs-immediate-templates">Ordinary vs immediate templates</a>.</p>

<h2><a class="toc-backref" id="pragmas-compilation-option-pragmas" href="#pragmas-compilation-option-pragmas">compilation option pragmas</a></h2><p>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</p>
<p>The implementation currently provides the following possible options (various others may be added later).</p>
<table border="1" class="docutils"><tr><th>pragma</th><th>allowed values</th><th>description</th></tr>
<tr><td>checks</td><td>on|off </td><td>Turns the code generation for all runtime checks on or off.</td></tr>
<tr><td>boundChecks</td><td>on|off </td><td>Turns the code generation for array bound checks on or off.</td></tr>
<tr><td>overflowChecks</td><td>on|off </td><td>Turns the code generation for over- or underflow checks on or off.</td></tr>
<tr><td>nilChecks</td><td>on|off </td><td>Turns the code generation for nil pointer checks on or off.</td></tr>
<tr><td>assertions</td><td>on|off </td><td>Turns the code generation for assertions on or off.</td></tr>
<tr><td>warnings</td><td>on|off </td><td>Turns the warning messages of the compiler on or off.</td></tr>
<tr><td>hints</td><td>on|off </td><td>Turns the hint messages of the compiler on or off.</td></tr>
<tr><td>optimization</td><td>none|speed|size </td><td>Optimize the code for speed or size, or disable optimization.</td></tr>
<tr><td>patterns</td><td>on|off </td><td>Turns the term rewriting templates/macros on or off.</td></tr>
<tr><td>callconv</td><td>cdecl|...</td><td>Specifies the default calling convention for all procedures (and procedure types) that follow.</td></tr>
</table><p>Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">optimization</span><span class="Punctuation">:</span> <span class="Identifier">speed</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># compile without runtime checks and optimize for speed</span></pre>
<h2><a class="toc-backref" id="pragmas-push-and-pop-pragmas" href="#pragmas-push-and-pop-pragmas">push and pop pragmas</a></h2><p>The <span id="push-pop_1">push/pop</span> pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># compile this section without runtime checks as it is</span>
<span class="Comment"># speed critical</span>
<span class="Comment"># ... some code ...</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># restore old settings</span></pre>
<h2><a class="toc-backref" id="pragmas-register-pragma" href="#pragmas-register-pragma">register pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">register</span></tt> pragma is for variables only. It declares the variable as <tt class="docutils literal"><span class="pre">register</span></tt>, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</p>
<p>In highly specific cases (a dispatch loop of an bytecode interpreter for example) it may provide benefits, though.</p>

<h2><a class="toc-backref" id="pragmas-global-pragma" href="#pragmas-global-pragma">global pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">global</span></tt> pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">isHexNumber</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">pattern</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="RawData">re&quot;[0-9a-fA-F]+&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">match</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span></pre><p>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</p>

<h2><a class="toc-backref" id="pragmas-deadcodeelim-pragma" href="#pragmas-deadcodeelim-pragma">deadCodeElim pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">deadCodeElim</span></tt> pragma only applies to whole modules: It tells the compiler to activate (or deactivate) dead code elimination for the module the pragma appears in.</p>
<p>The <tt class="docutils literal"><span class="pre">--deadCodeElim:on</span></tt> command line switch has the same effect as marking every module with <tt class="docutils literal"><span class="pre">{.deadCodeElim:on}</span></tt>. However, for some modules such as the GTK wrapper it makes sense to <em>always</em> turn on dead code elimination - no matter if it is globally active or not.</p>
<p>Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deadCodeElim</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="pragmas-pragma-pragma" href="#pragmas-pragma-pragma">pragma pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">pragma</span></tt> pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</p>
<p>Example:</p>
<pre><span class="Keyword">when</span> <span class="Identifier">appType</span> <span class="Operator">==</span> <span class="StringLit">&quot;lib&quot;</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;client.dll&quot;</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">rtl</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">b</span></pre><p>In the example a new pragma named <tt class="docutils literal"><span class="pre">rtl</span></tt> is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.</p>

<h2><a class="toc-backref" id="pragmas-disabling-certain-messages" href="#pragmas-disabling-certain-messages">Disabling certain messages</a></h2><p>Nim generates some warnings and hints (&quot;line too long&quot;) that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">hint</span><span class="Punctuation">[</span><span class="Identifier">LineTooLong</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># turn off the hint about too long lines</span></pre><p>This is often better than disabling all warnings at once.</p>

<h2><a class="toc-backref" id="pragmas-experimental-pragma" href="#pragmas-experimental-pragma">experimental pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">experimental</span></tt> pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</p>
<p>Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">useUsing</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">using</span> <span class="Identifier">dest</span>
  <span class="Identifier">add</span> <span class="StringLit">&quot;foo&quot;</span>
  <span class="Identifier">add</span> <span class="StringLit">&quot;bar&quot;</span></pre>
<h1><a class="toc-backref" id="foreign-function-interface" href="#foreign-function-interface">Foreign function interface(外部函数接口)</a></h1>
<p>Nim的 <span id="ffi_1">FFI</span> (外部函数接口)应用的太广泛了，因此就简单的说两句(总感觉哪里不对的样子)</p>
<h2><a class="toc-backref" id="foreign-function-interface-importc-pragma" href="#foreign-function-interface-importc-pragma">Importc pragma(importc编译指示)</a></h2>
<p>通过 <tt class="docutils literal"><span class="pre">importc</span></tt> 可以从C中导入一个过程或则变量。<br/>
可选的参数是一个字符串(也就是C中导出的符号)，如果这个参数省略，则默认C中的符号是Nim这个过程的名字:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>

<h2><a class="toc-backref" id="foreign-function-interface-exportc-pragma" href="#foreign-function-interface-exportc-pragma">Exportc pragma(exportc编译指示)</a></h2>
<p>通过 <tt class="docutils literal"><span class="pre">exportc</span></tt> 可以将类型、变量或过程以C的方式导出，其中枚举和常量不能导出。<br/>
同上有个可选的参数作为导出的符号，如省略则默认符号为过程的名字</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;callMe&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="foreign-function-interface-extern-pragma" href="#foreign-function-interface-extern-pragma">Extern pragma(extern编译指示)</a></h2>
<p>和 <tt class="docutils literal"><span class="pre">exportc</span></tt> 或 <tt class="docutils literal"><span class="pre">importc</span></tt>类似，<tt class="docutils literal"><span class="pre">extern</span></tt> 编译指示影响名称查找。<br/>
传递给 <tt class="docutils literal"><span class="pre">extern</span></tt> 的字符串可以是一个格式化字符串:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">extern</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre>
  <p>例子中 <tt class="docutils literal"><span class="pre">p</span></tt> 输出到C的名字设定为 <tt class="docutils literal"><span class="pre">prefixp</span></tt></p>

<h2><a class="toc-backref" id="foreign-function-interface-bycopy-pragma" href="#foreign-function-interface-bycopy-pragma">Bycopy pragma(bycopy编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">bycopy</span></tt> 编译指示应用到 对象或元组 类型上，用来指示编译器这个类型传递到过程时采用值方式:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Vector</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bycopy</span><span class="Punctuation">,</span> <span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span></pre>
<h2><a class="toc-backref" id="foreign-function-interface-byref-pragma" href="#foreign-function-interface-byref-pragma">Byref pragma(byref编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">byref</span></tt> 编译指示应用到 对象或元组类型上，用来指示编译器这个类型传递到过程时采用引用方式(隐藏的指针)</p>
<h2><a class="toc-backref" id="foreign-function-interface-varargs-pragma" href="#foreign-function-interface-varargs-pragma">Varargs pragma(varargs编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">varargs</span></tt> 编译指示只能应用到过程或则过程类型上，通知Nim这个过程在指定的参数后还可接受可变数目的参数。<br/>
Nim中字符串的值将自动的转化为C的字符串:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nodecl</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;hallo %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span> <span class="Comment"># &quot;world&quot; 将自动的作为C字符串传递</span></pre>
<h2><a class="toc-backref" id="foreign-function-interface-union-pragma" href="#foreign-function-interface-union-pragma">Union pragma(Union编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">union</span></tt> 编译指示能够应用到任意的<tt class="docutils literal"><span class="pre">对象</span></tt>类型。<br/>
这意味这对象的全部字段都会重复的覆盖在同一片内存中(C中的union)。<br/>
在产生C/C++代码时，将用 <tt class="docutils literal"><span class="pre">union</span></tt> 代替 <tt class="docutils literal"><span class="pre">struct</span></tt>。<br/>
对象的申明必须不能有继承和任何被GC的内存</p>
<p><strong>将来方向</strong>: GC'ed内存应当被允许使用</p>

<h2><a class="toc-backref" id="foreign-function-interface-packed-pragma" href="#foreign-function-interface-packed-pragma">Packed pragma(packed编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">packed</span></tt> 编译指示能被应用到任意的<tt class="docutils literal"><span class="pre">对象</span></tt> 类型上。<br/>
它保证对象的字段在内存中是一个接一个紧密连在一起的。这在网络传输和硬件驱动开发中非常有用，也能和C紧密联系在一次保持字节上的对齐。同样继承关系和GC应当也不能使用的。</p>
<p><strong>将来方向</strong>: GC'ed的内存应当被允许使用</p>

<h2><a class="toc-backref" id="foreign-function-interface-unchecked-pragma" href="#foreign-function-interface-unchecked-pragma">Unchecked pragma(unchecked编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">unchecked</span></tt> 编译只是能用来标记一个数组为<tt class="docutils literal"><span class="pre">unchecked</span></tt>，这意味着这个数组的边界是不会检查的。<br/>
这在当希望实现一个自己的灵活尺寸的数组时是非常有用的:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">ArrayPart</span><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unchecked</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">MySeq</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">ArrayPart</span></pre>
<p>将产生粗鲁的C代码:</p>
<pre><span class="Keyword">typedef</span> <span class="Keyword">struct</span> <span class="Punctuation">{</span>
  <span class="Identifier">NI</span> <span class="Identifier">len</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">cap</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">data</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span> <span class="Identifier">MySeq</span><span class="Punctuation">;</span></pre><p>The bounds checking done at compile time is not disabled for now, so to access <tt class="docutils literal"><span class="pre">s.data[C]</span></tt> (where <tt class="docutils literal"><span class="pre">C</span></tt> is a constant) the array's index needs needs to include <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
<p>unchecked数组的基类不能包含任何GC'ed内存</p>

<h2><a class="toc-backref" id="foreign-function-interface-dynlib-pragma-for-import" href="#foreign-function-interface-dynlib-pragma-for-import">Dynlib pragma for import(import时的dynlib编译指示)</a></h2>
<p><tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示用来确定某个过程或变量是从动态库中导入的 (视窗中的<tt class="docutils literal"><span class="pre">.dll</span></tt>, Unix中的<tt class="docutils literal"><span class="pre">lib*.so</span></tt>)<br/>
没有可选参数这意味则导入的符号名与Nim定义的一样:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">gtk_image_new</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PGtkWidget</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libgtk-x11-2.0.so&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<p><tt class="docutils literal"><span class="pre">dynlib</span></tt> 导入机制还支持一个版本语法:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">Tcl_Eval</span><span class="Punctuation">(</span><span class="Identifier">interp</span><span class="Punctuation">:</span> <span class="Identifier">pTcl_Interp</span><span class="Punctuation">,</span> <span class="Identifier">script</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span>
  <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libtcl(|8.5|8.4|8.3).so.(1|0)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
  <p>运行时，动态库按照如下的顺序依次进行搜索:<pre>
libtcl.so.1
libtcl.so.0
libtcl8.5.so.1
libtcl8.5.so.0
libtcl8.4.so.1
libtcl8.4.so.0
libtcl8.3.so.1
libtcl8.3.so.0</pre>
</p>
<p><tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示不仅仅支持字符串作为参数也支持字符串表达式:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">proc</span> <span class="Identifier">getDllName</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib2.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;could not load dynamic library&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">myImport</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="Identifier">getDllName</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<p><strong>注</strong>: 类似 <tt class="docutils literal"><span class="pre">libtcl(|8.5|8.4).so</span></tt> 的模式只支持字符串常量，因为他们是预编译的</p>
<p><strong>注</strong>: 传递参数给 <tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译至少可能会失败，因为初始化顺序的问题??</p>
<p><strong>注</strong>: <tt class="docutils literal"><span class="pre">dynlib</span></tt> 导入会在编译命令行时的选项 <tt class="docutils literal"><span class="pre">--dynlibOverride:name</span></tt> 所覆盖。</p>

<h2><a class="toc-backref" id="foreign-function-interface-dynlib-pragma-for-export" href="#foreign-function-interface-dynlib-pragma-for-export">Dynlib pragma for export(export时的dynlib编译指示)</a></h2>
<p>用 <tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示可以将过程导出到动态库中。 <br/>
这个编译指示必须和<tt class="docutils literal"><span class="pre">exportc</span></tt>编译指示一起使用，同时不能接任何参数:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">exportme</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<p>只有在命令行传递<tt class="docutils literal"><span class="pre">--app:lib</span></tt>时，也就是程序将被编译为动态库时，这个编译指示才起作用。</p>

<h1><a class="toc-backref" id="threads" href="#threads">Threads(线程)</a></h1>
<p>为了启用线程支持，命令行开关 <tt class="docutils literal"><span class="pre">--threads:on</span></tt> 需要打开。<br/>
<tt class="docutils literal"><span class="pre">system</span></tt> 模块中包含几个线程原语。<br/>
<a class="reference external" href="threads.html">threads</a> 和 <a class="reference external" href="channels.html">channels</a> 模块中含有低层次的线程API。 当然也有高层次的并发机构，见 <a class="reference external" href="#spawn">spawn</a>。</p>
<p>Nim的线程内存模型不同于其他的编程语言(如C,Pascal,Java): <br/>
每一个线程拥有自己的可GC的堆 ，并且共享内置严格的只限于全局变量，这有助于减少竞争情形的发生。<br/>
GC效率也大幅度提升因为GC将不会停止其他的线程来查看他们是否有被引用，内存分配也不在需要锁了！！！<br/>
 这个设计也更容易分散到多核处理器环境中</p>

<h2><a class="toc-backref" id="threads-thread-pragma" href="#threads-thread-pragma">Thread pragma(thread编译指示)</a></h2>
<p>作为新线程执行的过程应该用 <tt class="docutils literal"><span class="pre">thread</span></tt> 编译指示加以标识，这样阅读性会跟好。编译器也将检查是否没有堆分享的约束条件是否满足：堆分享即在别的线程的堆上分配一个数据结构，这样的是不行的。</p>
<p>一个线程过程被传递给 <tt class="docutils literal"><span class="pre">createThread</span></tt> 或 <tt class="docutils literal"><span class="pre">spawn</span></tt> 随后被间接的调用。因此 <tt class="docutils literal"><span class="pre">thread</span></tt> 编译指示也暗示了这个过程是包含了 <tt class="docutils literal"><span class="pre">procvar</span></tt>编译指示的</p>

<h2><a class="toc-backref" id="threads-gc-safety" href="#threads-gc-safety">GC safety(GC安全)</a></h2>
<p>过程 <tt class="docutils literal"><span class="pre">p</span></tt> <span id="gc-safe_1">称为GC安全</span>的条件是:<br/>
1. 它不访问那些被自动GC内存的全局变量(<tt class="docutils literal"><span class="pre">string</span></tt>, <tt class="docutils literal"><span class="pre">seq</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt> or a closure)<br/>
2. 也不直接间接的调用那些GC不安全的过程</p>
<p><span id="gcsafe_1">gcsafe</span> 标识用来表示一个过程是GC安全的,否则将由编译器来判断是否安全。<br/>
注意 <tt class="docutils literal"><span class="pre">noSideEfect</span></tt> 编译指示也暗示了是 <tt class="docutils literal"><span class="pre">gcsafe</span></tt>的。<br/>
创建线程的唯一途径是通过 <tt class="docutils literal"><span class="pre">spawn</span></tt> 或 <tt class="docutils literal"><span class="pre">createThead</span></tt>，<tt class="docutils literal"><span class="pre">spawn</span></tt> 相对更优。<br/>
无论通过哪种途径调用过程既不能使用 <tt class="docutils literal"><span class="pre">var</span></tt> 参数,也不能包含任何一个 <tt class="docutils literal"><span class="pre">ref</span></tt> 或 <tt class="docutils literal"><span class="pre">closure</span></tt> 类型的参数。这条就保证了不会违反 <em>堆共享约束</em>。</p>
<p>从C导入的过程总是假定为 <tt class="docutils literal"><span class="pre">gcsafe</span></tt>的。<br/>
通过使用编译命令行开关 <tt class="docutils literal"><span class="pre">--threadAnalysis:off</span></tt> 可以关闭这个安全性检查，通常这至少个临时的解决手段，最好不要关闭！</p>

<h2><a class="toc-backref" id="threads-threadvar-pragma" href="#threads-threadvar-pragma">Threadvar pragma(Threadvar编译指示)</a></h2>
<p>一个全局变量可以标识为 <tt class="docutils literal"><span class="pre">threadvar</span></tt> 编译指示，这说明这个变量是 <span id="thread-local_1">thread-local线程独立</span>的(每个线程一个，独立的)　:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">checkpoints</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre>
<p>由于实现的约束，线程独立变量不能在 <tt class="docutils literal"><span class="pre">var</span></tt>区间时直接初始化(每个线程独立变量在线程创建的时候都会复制一份)，编译器会报错的</p>

<h2><a class="toc-backref" id="threads-threads-and-exceptions" href="#threads-threads-and-exceptions">Threads and exceptions(线程和异常)</a></h2>
<p>线程与异常之间的互动很简单: 莫个线程中被<em>捕捉</em> 的异常不会影响其他的线程，然而某个线程中<em>未被捕捉</em>的异常会终结整个 <em>进程</em>!</p>

<h1><a class="toc-backref" id="parallel-spawn" href="#parallel-spawn">Parallel &amp; Spawn</a></h1>
<p>Nim有两种风格的并行方式:</p>
<ol class="simple"><li>通过 <tt class="docutils literal"><span class="pre">parallel</span></tt>语句实现的<span id="structured_1">结构化</span>并行</li>
<li>使用独立的<tt class="docutils literal"><span class="pre">spawn</span></tt>语句实现的 <span id="unstructured_1">非结构化</span> 并行</li>
</ol>
<p>Nim内建一个线程池可用于CPU敏感的任务，对IO敏感的任务来说 <tt class="docutils literal"><span class="pre">async</span></tt> 和 <tt class="docutils literal"><span class="pre">await</span></tt> 特性更适合。<br/>
parallel 和 spawn 都需要 <a class="reference external" href="threadpool.html">threadpool</a> 模块配合才能运行</p>
<p>有些困惑的地方， <tt class="docutils literal"><span class="pre">spawn</span></tt> 在 <tt class="docutils literal"><span class="pre">parallel</span></tt> 语句中使用时有少许的不同语义。<br/>
<tt class="docutils literal"><span class="pre">spawn</span></tt> 总是后跟着一个形如<tt class="docutils literal"><span class="pre">f(a, ...)</span></tt>的表达式调用，<tt class="docutils literal"><span class="pre">T</span></tt> 是 <tt class="docutils literal"><span class="pre">f</span></tt>的返回类型。<br/>
1. 如果 <tt class="docutils literal"><span class="pre">T</span></tt> 是 <tt class="docutils literal"><span class="pre">void</span></tt>，那么 <tt class="docutils literal"><span class="pre">spawn</span></tt>的返回值也是 <tt class="docutils literal"><span class="pre">void</span></tt>。<br/>
2. 如果 <tt class="docutils literal"><span class="pre">T</span></tt> 不是 <tt class="docutils literal"><span class="pre">void</span></tt>，那么<tt class="docutils literal"><span class="pre">spawn</span></tt>的返回值是 <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt></p>
<p>但是当<tt class="docutils literal"><span class="pre">spawn</span></tt>在 <tt class="docutils literal"><span class="pre">parallel</span></tt> 区块中时，有时 <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> 会被还原为 <tt class="docutils literal"><span class="pre">T</span></tt>。 <br/>
还原只有在当 <tt class="docutils literal"><span class="pre">T</span></tt> 中不包含任何被GC追踪的内存时才会发生。<br/>
当编译器能确保这个位置 <tt class="docutils literal"><span class="pre">location = spawn f(...)</span></tt> 在<tt class="docutils literal"><span class="pre">parallel</span></tt>区块中不会被过早的被读取时，这样才不需要再包裹一层 <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> 去保证读取的正确性了</p>
<p><strong>注意</strong>: 当前实现中，异常不会在 <tt class="docutils literal"><span class="pre">spawn</span></tt> 的任务间传播</p>

<h2><a class="toc-backref" id="parallel-spawn-spawn-statement" href="#parallel-spawn-spawn-statement">Spawn statement</a></h2>
<p><span id="spawn_1">spawn</span> 用来将一个任务提交到线程池中:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">threadpool</span>

<span class="Keyword">proc</span> <span class="Identifier">processLine</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span> <span class="StringLit">&quot;do some heavy lifting here&quot;</span>

<span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">lines</span><span class="Punctuation">(</span><span class="StringLit">&quot;myinput.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">spawn</span> <span class="Identifier">processLine</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Identifier">sync</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<p>为了类型安全和实现简单的原因，<tt class="docutils literal"><span class="pre">spawn</span></tt>提交任务的表达式限制如下:</p>
<ul class="simple"><li>必须是一个调用表达式 <tt class="docutils literal"><span class="pre">f(a, ...)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> 必须是 <tt class="docutils literal"><span class="pre">gcsafe</span></tt></li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> 的调用约定不能是 <tt class="docutils literal"><span class="pre">closure</span></tt></li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> 的参数类型不能含有 <tt class="docutils literal"><span class="pre">var</span></tt>。这意味要传递数据必须使用 <tt class="docutils literal"><span class="pre">ptr</span></tt>了，也能提醒开发人员此时得非常小心</li>
<li><tt class="docutils literal"><span class="pre">ref</span></tt> 参数传递时是<span class="pre">深度拷贝</span>的。<br/>
这个有语义上的改变因为ref就是引用的意思不应该是深度拷贝的，而且会带来性能上的一些问题。<br/>
！但是！ 这能保证内存是安全的。<br/>
深度拷贝通过 <tt class="docutils literal"><span class="pre">system.deepCopy</span></tt> 来执行，因此也是可以被overriden的。</li>
<li>为了在<tt class="docutils literal"><span class="pre">f</span></tt> 和调用者之间 <em>安全</em> 的交换数据，可以使用全局的 <tt class="docutils literal"><span class="pre">TChannel</span></tt>。<br/>
然而通常情况下都没使用，因为 spawn 能返回一个值，这样就不需要额外的交互渠道了。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">spawn</span></tt> 将表达式传送到线程池执行，并且返回一个 <span id="data-flow-variable_1">data flow variable(数据流变量)</span> <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt>（可从此中读取最终的返回值）。<br/>
从<tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt>中读取返回值可用 <tt class="docutils literal"><span class="pre">^</span></tt> 操作符，这是一个 <strong>阻塞</strong>操作。<br/>
幸好还能用 <tt class="docutils literal"><span class="pre">awaitAny</span></tt> 去同时等待多个数据流变量的结果:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">threadpool</span><span class="Punctuation">,</span> <span class="Operator">...</span>

<span class="Comment"># 等待直到３台服务器中有２台相应了update操作</span>
<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">responses</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">RawFlowVar</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">:</span>
    <span class="Identifier">responses</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">spawn</span> <span class="Identifier">tellServer</span><span class="Punctuation">(</span><span class="Identifier">Update</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">index</span> <span class="Operator">=</span> <span class="Identifier">awaitAny</span><span class="Punctuation">(</span><span class="Identifier">responses</span><span class="Punctuation">)</span>
  <span class="Identifier">assert</span> <span class="Identifier">index</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span>
  <span class="Identifier">responses</span><span class="Operator">.</span><span class="Identifier">del</span><span class="Punctuation">(</span><span class="Identifier">index</span><span class="Punctuation">)</span>
  <span class="Keyword">discard</span> <span class="Identifier">awaitAny</span><span class="Punctuation">(</span><span class="Identifier">responses</span><span class="Punctuation">)</span></pre>
  <p>数据流变量确保不会有数据竞争的情况发生。<br/>
  由于技术原因，不是每个类型<tt class="docutils literal"><span class="pre">T</span></tt>都可以放到数据流变量中: <br/>
  <tt class="docutils literal"><span class="pre">T</span></tt> 必须是 <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">string</span></tt>, <tt class="docutils literal"><span class="pre">seq</span></tt> 或其他不包含被GC追踪的类型的类型(如:基础类型、结构)。实践中这个要求是不难达到的</p>

<h2><a class="toc-backref" id="parallel-spawn-parallel-statement" href="#parallel-spawn-parallel-statement">Parallel statement(Parallel语句)</a></h2><p>例:</p>
<pre><span class="Comment"># 一个效率不高的PI计算</span>
<span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">math</span><span class="Punctuation">,</span> <span class="Identifier">threadpool</span>

<span class="Keyword">proc</span> <span class="Identifier">term</span><span class="Punctuation">(</span><span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="DecNumber">4</span> <span class="Operator">*</span> <span class="Identifier">math</span><span class="Operator">.</span><span class="Identifier">pow</span><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">k</span><span class="Punctuation">)</span> <span class="Operator">/</span> <span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Operator">*</span><span class="Identifier">k</span> <span class="Operator">+</span> <span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">pi</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ch</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">+</span><span class="DecNumber">1</span><span class="Punctuation">)</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">k</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">ch</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
      <span class="Identifier">ch</span><span class="Punctuation">[</span><span class="Identifier">k</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">spawn</span> <span class="Identifier">term</span><span class="Punctuation">(</span><span class="Identifier">float</span><span class="Punctuation">(</span><span class="Identifier">k</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">k</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">ch</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">+=</span> <span class="Identifier">ch</span><span class="Punctuation">[</span><span class="Identifier">k</span><span class="Punctuation">]</span>

<span class="Identifier">echo</span> <span class="Identifier">formatFloat</span><span class="Punctuation">(</span><span class="Identifier">pi</span><span class="Punctuation">(</span><span class="DecNumber">5000</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre>
<p>parallel语句在Nim中介绍并行时是被推崇的机制(实际不好用:) <br/>
在 <tt class="docutils literal"><span class="pre">parallel</span></tt>区块中只有一个Nim的语言子集可以适用，这个子集在编译期会检查避免掉数据竞争的情况发生。 <br/>
一个复杂的 <span id="disjoint-checker_1">disjoint checker(可分离检查)</span> 确保没有数据竞争的情况，甚至对共享内存的大多数方面也支持这种检查!</p>
<p>这个子集其实是完整的语言只是增加了如下的限制和改变:</p>
<ul class="simple"><li>在<tt class="docutils literal"><span class="pre">parallel</span></tt>中的<tt class="docutils literal"><span class="pre">spawn</span></tt> 有特别的语义(从FlowVar中自动还原)</li>
<li>形如 <tt class="docutils literal"><span class="pre">a[i]</span></tt> 和 <tt class="docutils literal"><span class="pre">a[i..j]</span></tt> 以及 <tt class="docutils literal"><span class="pre">dest</span></tt> ( <tt class="docutils literal"><span class="pre">dest</span></tt> 是这个形式 <tt class="docutils literal"><span class="pre">dest = spawn f(...)</span></tt>)都必须保证是可分离的。这称为 <em>disjoint check(可分离检查)</em></li>
<li>其他用于spawn过程中复杂的地址 (<tt class="docutils literal"><span class="pre">spawn f(loc)</span></tt>) 中的<tt class="docutils literal"><span class="pre">loc</span></tt> 在<tt class="docutils literal"><span class="pre">parallel</span></tt>区块中必须是不可变的。这称为 <em>immutability check(不可变检查)</em></li>
<li>数据读写必须边界检查。这称为<em>bounds check(边界检查)</em></li>
<li>Slice切片被优化了，因此无需拷贝操作。但是<tt class="docutils literal"><span class="pre">parallel</span></tt>区块外的序数切片依旧没这么优化。</li>
</ul>

<h1><a class="toc-backref" id="guards-and-locks" href="#guards-and-locks">Guards and locks(守卫和锁)</a></h1>
<p>除了 <tt class="docutils literal"><span class="pre">spawn</span></tt> 和 <tt class="docutils literal"><span class="pre">parallel</span></tt>，Nim也提供全部通用的低层次并发设计如:　锁、原子指令、条件变量</p>
<p>Nim通过附加的编译指示已提高这些特性的安全性:</p>
<ol class="simple">
<li><span id="guard_1">guard</span> 指示用来阻止数据竞争</li>
<li>每次读写被守卫的内存地址需要一条相应的 <span id="locks_1">locks</span> 语句</li>
<li>锁和程序后面可以跟随一个 <span id="lock-levels_1">lock levels(锁的程度)</span> 用以在编译器阻止死锁</li>
</ol>
<h2><a class="toc-backref" id="guards-and-locks-guards-and-the-locks-section" href="#guards-and-locks-guards-and-the-locks-section">Guards and the locks section(守卫和锁)</a></h2>
<h3><a class="toc-backref" id="guards-and-the-locks-section-protecting-global-variables" href="#guards-and-the-locks-section-protecting-global-variables">Protecting global variables(保护全局变量)</a></h3>
<p>对象的字段以及全局变量能够附加一个 <tt class="docutils literal"><span class="pre">guard</span></tt> 编译指示:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">glock</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span>
<span class="Keyword">var</span> <span class="Identifier">gdata</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">glock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre>
<p>编译器确保每次读写 <tt class="docutils literal"><span class="pre">gdata</span></tt>都必须是在一个 <tt class="docutils literal"><span class="pre">locks</span></tt> 区块内:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">invalid</span> <span class="Operator">=</span>
  <span class="Comment"># 非法: 没有守卫的读写:</span>
  <span class="Identifier">echo</span> <span class="Identifier">gdata</span>

<span class="Keyword">proc</span> <span class="Identifier">valid</span> <span class="Operator">=</span>
  <span class="Comment"># 合法读写:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">glock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">gdata</span></pre>
<p>最顶层读写 <tt class="docutils literal"><span class="pre">gdata</span></tt> 总是被允许的，这样就能很容易的初始化了。<br/>
这就一个<em>假设</em>每一个最顶层的语句总是在任何并发动作之前执行的(不强求，以后也可以的)。</p>
<p><tt class="docutils literal"><span class="pre">locks</span></tt> 故意设计的丑陋，因为它没有运行期语义，因此也不应当被直接使用！<br/>反过来它应当运用在模板中，这样能实现运行期的各种样式的锁:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">;</span> <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></pre>
<p>守卫不需要绑定某个特定的类型。它是足够灵活的也能适用于模型化各种低层次的lockfree设计:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">dummyLock</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">atomicCounter</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">dummyLock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">template</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">dummyLock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">memoryReadBarrier</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">atomicCounter</span><span class="Punctuation">)</span></pre>
<p><tt class="docutils literal"><span class="pre">locks</span></tt> 编译指示后接一个锁表达式列表 <tt class="docutils literal"><span class="pre">locks: [a, b, ...]</span></tt> 以便支持 <em>多重锁</em> 语句。</p>

<h3><a class="toc-backref" id="guards-and-the-locks-section-protecting-general-locations" href="#guards-and-the-locks-section-protecting-general-locations">Protecting general locations(保护地址)</a></h3>
<p><tt class="docutils literal"><span class="pre">guard</span></tt> 申明也能用来保护对象的字段，此时这个 guard需要同一个对象的字段或则全局变量。</p>

<pre><span class="Keyword">type</span>
  <span class="Identifier">ProtectedCounter</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">v</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">L</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">L</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span>

<span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">lock</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">:</span>
      <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre>
      <p>读写字段 <tt class="docutils literal"><span class="pre">x.v</span></tt> 是被允许的了因为字段对应的护卫 <tt class="docutils literal"><span class="pre">x.L</span></tt>  已经激活。<br/>
      解开模板,源码类似如下:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">try</span><span class="Punctuation">:</span>
        <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span>
      <span class="Keyword">finally</span><span class="Punctuation">:</span>
        <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span></pre><p>There is an analysis that checks that <tt class="docutils literal"><span class="pre">counters[i].L</span></tt> is the lock that corresponds to the protected location <tt class="docutils literal"><span class="pre">counters[i].v</span></tt>. This analysis is called <span id="path-analysis_1">path analysis</span> because it deals with paths to locations like <tt class="docutils literal"><span class="pre">obj.field[i].fieldB[j]</span></tt>.</p>
<p>虽然path analysis(路径分析)当前还<strong>不完善</strong>,但是并不妨碍他派上用场。如果两条路径句法上相同那么可以认为他们就是相等的。</p>
<p>就算是下面的语句现在都能编译，虽然不应当这样用(语法正确，bug):</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Identifier">inc</span> <span class="Identifier">i</span>
  <span class="Identifier">access</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre>
<h2><a class="toc-backref" id="guards-and-locks-lock-levels" href="#guards-and-locks-lock-levels">Lock levels</a></h2>
<p>Lock levels用来确保一个全局的锁的顺序，这样在编译期就能避免可能发生死锁的情况。<br/>
lock level可以是任意一个在[0，1000]间的整数常量，Lock level = 0则说明根本就不需要锁</p>
<p>If a section of code holds a lock of level <tt class="docutils literal"><span class="pre">M</span></tt> than it can also acquire any lock of level <tt class="docutils literal"><span class="pre">N &lt; M</span></tt>. Another lock of level <tt class="docutils literal"><span class="pre">M</span></tt> cannot be acquired. Locks of the same level can only be acquired <em>at the same time</em> within a single <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
<span class="Comment"># invalid locking order: TLock[1] cannot be acquired before TLock[2]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>
<span class="Comment"># valid locking order: TLock[2] acquired before TLock[1]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>

<span class="Comment"># invalid locking order: TLock[2] acquired before TLock[2]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>

<span class="Comment"># valid locking order, locks of the same level acquired at the same time:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre><p>Here is how a typical multilock statement can be implemented in Nim. Note how the runtime check is required to ensure a global ordering for two locks <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> of the same lock level:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">multilock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">TLock</span><span class="Punctuation">;</span> <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">ByteAddress</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">&lt;</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">ByteAddress</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span></pre><p>Whole routines can also be annotated with a <tt class="docutils literal"><span class="pre">locks</span></tt> pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="FloatNumber">3.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Comment"># p's locklevel (3) is strictly less than a's (4) so the call is allowed:</span>
  <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>As usual <tt class="docutils literal"><span class="pre">locks</span></tt> is an inferred effect and there is a subtype relation: <tt class="docutils literal"><span class="pre">proc () {.locks: N.}</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">proc () {.locks: M.}</span></tt> iff (M &lt;= N). </p>

<h1><a class="toc-backref" id="taint-mode" href="#taint-mode">Taint mode(Taint模式) 没意思的，删除</a></h1>
<p>在编译命令行中启用开关 <tt class="docutils literal"><span class="pre">--taintMode:on</span></tt></p>  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-05-04 19:40:46 UTC</small>
         <small> <a href="http://d-l.github.io" target="_blank">D-L</a>更新于</small>
      </div>
    </div>
  </div>
</div>    
</body>
</html>